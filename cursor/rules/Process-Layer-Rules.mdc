---
description: Always apply. Non-negotiable rules for Process Layer boundaries in this repo.
alwaysApply: true
---
# Process Layer ‚Äì Architecture & Coding Guidelines

---

## üî¥ **ALL RULES IN THIS DOCUMENT ARE CRITICAL AND MANDATORY** üî¥

> **‚ö†Ô∏è IMPORTANT: Every rule, guideline, pattern, and standard defined in this document is CRITICAL and MANDATORY.**
>
> - ‚ùå **NO EXCEPTIONS** - These are not suggestions or recommendations
> - ‚ùå **NO DEVIATIONS** - Do not modify, skip, or work around any rule
> - ‚ùå **NO SHORTCUTS** - Follow ALL patterns exactly as specified
> - ‚úÖ **100% COMPLIANCE REQUIRED** - All Process Layer implementations MUST follow these rules
>
> **Rationale:** These rules ensure consistency, maintainability, scalability, and alignment with enterprise architecture standards. Violating any rule will result in:
> - ‚ùå Architecture inconsistencies
> - ‚ùå Maintenance nightmares
> - ‚ùå Integration failures
> - ‚ùå Code review rejections
>
> **If you have questions or concerns about any rule, escalate for clarification. DO NOT proceed with non-compliant implementations.**

**üìö FRAMEWORK REFERENCE:** Review `Framework/Core` and `Framework/Cache` directories to understand framework-level patterns that Process Layer builds upon.

---

## üö® **CRITICAL: MANDATORY IMPLEMENTATION CHECKLIST** üö®

> **‚ö†Ô∏è COMPLETE BEFORE WRITING ANY CODE:**

### ‚ùå NEVER DO THESE (Fatal Mistakes):

1. ‚ùå **Skipped reading entire rulebook**
   - **Impact:** Missed critical patterns, wrong folder structure, incorrect abstractions
   - **‚úÖ DO:** Read ALL sections before any implementation

2. ‚ùå **Created components without verifying folder locations**
   - **Impact:** Services/ at root instead of inside implementations, wrong DTO organization
   - **‚úÖ DO:** Verify each component's exact location from structure rules

3. ‚ùå **Mixed System Layer and Process Layer concepts**
   - **Impact:** CustomAuthenticationMiddleware in Process Layer, Models/ instead of DTOs/
   - **‚úÖ DO:** Process Layer has ONLY: Domains/, SystemAbstractions/, ProcessAbstractions/, Services/, Functions/, DTOs/

4. ‚ùå **Used repo-specific names in implementations**
   - **Impact:** Non-reusable patterns, hardcoded references
   - **‚úÖ DO:** Use concrete generic names like EntityDomain, EntityService (not WorkOrder, EmployeeInfo)

---

### ‚úÖ MANDATORY CALL FLOW (FINAL RULE):

**üö® CRITICAL ARCHITECTURE PATTERN:**

```
Azure Function
    ‚Üì (inject Service - with or without interface)
Service
    ‚Üì (inject via IEntityMgmt interface OR IEntityProc interface)
System Abstraction OR Process Abstraction
    ‚Üì (HTTP calls)
System Layer OR Process Layer
```

**MANDATORY RULES:**
1. ‚úÖ Functions inject Services (can be with or without interface: `IEntityService` OR `EntityService`)
2. ‚úÖ Services MUST inject System/Process Abstractions via interface (`IEntityMgmt`, `IEntityProc`)
3. ‚úÖ ALL System Abstractions MUST implement interfaces
4. ‚úÖ ALL Process Abstractions MUST implement interfaces
5. ‚ùå Functions MUST NOT call System/Process Abstractions directly
6. ‚ùå Functions MUST NOT call System/Process Layers directly

### ‚úÖ MANDATORY READING ORDER:

**Step 1:** Read FOLDER STRUCTURE section - memorize complete structure  
**Step 2:** Read DOMAIN RULES - understand business object patterns  
**Step 3:** Read SYSTEM ABSTRACTIONS - Process‚ÜíSystem Layer calls (MUST use interfaces)  
**Step 4:** Read PROCESS ABSTRACTIONS - Process‚ÜíProcess Layer calls (MUST use interfaces)  
**Step 5:** Read SERVICES RULES - orchestration patterns (Services optional interface, MUST inject Abstractions via interface)  
**Step 6:** Read FUNCTIONS RULES - Azure Function implementation (inject Services directly OR via interface)  
**Step 7:** Read MIDDLEWARE RULES - ExecutionTiming, ExceptionHandler ONLY  
**Step 8:** Read PROGRAM.CS RULES - DI registration order (System/Process Abstractions via interface, Services optional)  

---

## üìã TABLE OF CONTENTS

1. [Folder Structure Rules](#1-folder-structure-rules)
2. [Caching Rules](#2-caching-rules)
3. [Domain Rules (Business Objects)](#3-domain-rules-business-objects)
4. [System Abstractions Rules](#4-system-abstractions-rules)
5. [Process Abstractions Rules](#5-process-abstractions-rules)
6. [Calling Central Data Process Layer](#6-calling-central-data-process-layer)
7. [Services Rules](#7-services-rules)
8. [Azure Functions Rules](#8-azure-functions-rules)
9. [DTO Rules](#9-dto-rules)
10. [Response DTO Helper Rules](#10-response-dto-helper-rules)
11. [Central Data Process Layer Unique Patterns](#11-central-data-process-layer-unique-patterns)
12. [Config Models Rules](#12-config-models-rules)
13. [Constants Rules](#13-constants-rules)
14. [Enums Rules](#14-enums-rules)
15. [Extensions Rules](#15-extensions-rules)
16. [Helper Rules](#16-helper-rules)
17. [Middleware Rules](#17-middleware-rules)
18. [Program.cs Rules](#18-programcs-rules)
19. [host.json Rules](#19-hostjson-rules)
20. [Exception Handling Rules](#20-exception-handling-rules)
21. [Architecture Invariants](#21-architecture-invariants)

---

## 1. FOLDER STRUCTURE RULES

**üö® BEFORE CREATING:** Verify EVERY folder location against this structure.

### 1.1 COMPLETE STRUCTURE (Standard Process Layer)

```
<ProjectName>/
‚îú‚îÄ‚îÄ ConfigModels/                      # AppConfigs.cs, nested configs
‚îú‚îÄ‚îÄ Constants/                         # ErrorConstants.cs (tuple format)
‚îú‚îÄ‚îÄ Domains/                           # Business objects with IDomain<T>
‚îÇ   ‚îî‚îÄ‚îÄ <ModuleName>/                 # Organized by business module
‚îÇ       ‚îî‚îÄ‚îÄ <DomainName>.cs           # Domain entity with business logic
‚îú‚îÄ‚îÄ DTOs/                              # ALL request/response DTOs
‚îÇ   ‚îú‚îÄ‚îÄ <FeatureName>/                # Per-feature folder (CreateEntity, GetDetails, etc.)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ <Feature>ReqDTO.cs       # Request DTO
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ <Feature>ResDTO.cs       # Response DTO
‚îú‚îÄ‚îÄ Enums/                             # Enums with [StringValue]
‚îú‚îÄ‚îÄ Extensions/                        # Project-specific extensions (optional)
‚îú‚îÄ‚îÄ EmailTemplate/                     # Optional - Embedded HTML templates
‚îÇ   ‚îî‚îÄ‚îÄ <TemplateName>.html           # Email templates as embedded resources
‚îú‚îÄ‚îÄ Functions/                         # Azure Functions (HTTP entry points)
‚îÇ   ‚îî‚îÄ‚îÄ <Feature>Functions/
‚îÇ       ‚îî‚îÄ‚îÄ <Feature>Function.cs
‚îú‚îÄ‚îÄ Helper/                            # ResponseDTOHelper (mandatory)
‚îú‚îÄ‚îÄ ProcessAbstractions/               # Process‚ÜíProcess Layer calls (optional)
‚îÇ   ‚îî‚îÄ‚îÄ <ModuleName>/
‚îÇ       ‚îî‚îÄ‚îÄ <Feature>Proc.cs
‚îú‚îÄ‚îÄ Services/                          # Orchestration & business logic
‚îÇ   ‚îî‚îÄ‚îÄ <Feature>Service.cs
‚îÇ   ‚îî‚îÄ‚îÄ Interface/
‚îÇ       ‚îî‚îÄ‚îÄ I<Feature>Service.cs
‚îú‚îÄ‚îÄ SystemAbstractions/                # Process‚ÜíSystem Layer calls
‚îÇ   ‚îî‚îÄ‚îÄ <ModuleName>Mgmt/
‚îÇ       ‚îî‚îÄ‚îÄ <Feature>MgmtSys.cs
‚îÇ   ‚îî‚îÄ‚îÄ Interfaces/ (optional)
‚îÇ       ‚îî‚îÄ‚îÄ I<Feature>Mgmt.cs
‚îú‚îÄ‚îÄ Program.cs
‚îú‚îÄ‚îÄ host.json
‚îú‚îÄ‚îÄ appsettings.json
‚îú‚îÄ‚îÄ appsettings.dev.json
‚îú‚îÄ‚îÄ appsettings.qa.json
‚îú‚îÄ‚îÄ appsettings.stg.json (optional)
‚îú‚îÄ‚îÄ appsettings.prod.json
‚îú‚îÄ‚îÄ appsettings.dr.json (optional)
‚îî‚îÄ‚îÄ <ProjectName>.csproj, <ProjectName>.sln
```

### 1.2 SHARED SERVICES (CENTRAL DATA LAYER) STRUCTURE

**Location:** `Shared Services/SharedService/`

```
SharedService/
‚îú‚îÄ‚îÄ AutoMapping/                       # AutoMapper profiles
‚îÇ   ‚îî‚îÄ‚îÄ <Entity>Mapping.cs
‚îú‚îÄ‚îÄ ConfigModels/                      # AppConfigs, KeyVaultConfigs, JwtOptions
‚îú‚îÄ‚îÄ Constants/                         # ErrorConstants, GrantTypes, custom claim names
‚îú‚îÄ‚îÄ Domains/                           # Simple POCOs (NO IDomain<T>)
‚îÇ   ‚îî‚îÄ‚îÄ Security/
‚îÇ       ‚îî‚îÄ‚îÄ <Entity>.cs
‚îú‚îÄ‚îÄ DTOs/                              # Request/response DTOs
‚îú‚îÄ‚îÄ Functions/                         # Azure Functions
‚îú‚îÄ‚îÄ Helper/                            # KeyVaultReader, DatabaseConnectionStringProvider
‚îú‚îÄ‚îÄ Models/                            # EF Core entities & DbContext
‚îÇ   ‚îú‚îÄ‚îÄ AppDbContext.cs
‚îÇ   ‚îî‚îÄ‚îÄ <Entity>.cs
‚îú‚îÄ‚îÄ Repositories/                      # Repository pattern
‚îÇ   ‚îú‚îÄ‚îÄ Interfaces/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ IRepository.cs
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ I<Entity>Repository.cs
‚îÇ   ‚îú‚îÄ‚îÄ Repository.cs                 # Generic Repository<T>
‚îÇ   ‚îî‚îÄ‚îÄ <Entity>Repository.cs
‚îú‚îÄ‚îÄ Services/                          # Business logic + DB access
‚îÇ   ‚îú‚îÄ‚îÄ Interfaces/
‚îÇ   ‚îî‚îÄ‚îÄ <Feature>Service.cs
‚îú‚îÄ‚îÄ SystemAbstractions/                # External system calls
‚îú‚îÄ‚îÄ Program.cs
‚îî‚îÄ‚îÄ appsettings.*.json
```

### 1.3 CRITICAL RULES

| Rule | Requirement | Impact |
|------|-------------|--------|
| **Domains/** | Business objects with `IDomain<T>` interface | Architecture pattern |
| **DTOs/** | Request/response data transfer objects | Naming consistency |
| **ProcessAbstractions/** | Process‚ÜíProcess calls (optional, not all projects) | Inter-process communication |
| **SystemAbstractions/** | Process‚ÜíSystem Layer calls (mandatory) | External communication |
| **Services/** | Orchestration logic (optional, not all projects) | Business logic layer |
| **NO Middleware/** | Except ExecutionTiming, ExceptionHandler from Framework | No custom auth |
| **NO Attributes/** | No custom attributes in Process Layer | System Layer concept |
| **NO SoapEnvelopes/** | Process Layer doesn't build SOAP | System Layer handles |

### 1.4 NAMESPACE CONVENTIONS

| Folder | Namespace Pattern |
|--------|-------------------|
| ConfigModels | `<NS>.ConfigModels` |
| Constants | `<NS>.Constants` |
| Domains | `<NS>.Domains.<ModuleName>` |
| DTOs | `<NS>.DTOs.<FeatureName>` |
| Enums | `<NS>.Enums` |
| Extensions | `<NS>.Extensions` |
| Functions | `<NS>.Functions.<ModuleName>Functions` |
| Helper | `<NS>.Helper` |
| ProcessAbstractions | `<NS>.ProcessAbstractions.<ModuleName>` |
| Services | `<NS>.Services` |
| SystemAbstractions | `<NS>.SystemAbstractions.<ModuleName>Mgmt` |

### 1.5 VERIFICATION CHECKLIST

- [ ] Domains/ exists and is populated (MANDATORY for standard Process Layer)
- [ ] DTOs/ folder for all request/response DTOs
- [ ] SystemAbstractions/ exists
- [ ] ProcessAbstractions/ only if calling other Process Layers
- [ ] Services/ only if orchestration logic exists
- [ ] NO CustomAuthenticationMiddleware
- [ ] NO Attributes/ folder
- [ ] NO SoapEnvelopes/ folder
- [ ] Repositories/ only in central data Process Layer
- [ ] Models/ only in central data Process Layer (EF Core entities)

---

## 2. CACHING RULES

**üö® CRITICAL:** Use caching interceptor for System Layer API calls to improve performance.

### 2.1 CACHING INTERCEPTOR PATTERN

**Purpose:** Automatically cache System Layer responses using `[CacheableService]` attribute

**Requirements:**
1. System Abstraction method returns `HttpResponseSnapshot` (not `HttpResponseMessage`)
2. Domain implements `ICacheable` interface with `GetCacheKey()` method
3. Method decorated with `[CacheableService(Namespace = nameof(MethodName))]`

```csharp
// Domain with ICacheable
public class EntityInfo : IDomain<int>, ICacheable {
    public string Code { get; set; }
    public List<string> Details { get; set; }
    public IDictionary<PropertyInfo, object> GetCacheKey() {
        var p = new Dictionary<PropertyInfo, object>();
        p.Add(GetType().GetProperty(nameof(Code))!, Code!);
        if (Details?.Count > 0) { Details.Sort(); p.Add(GetType().GetProperty(nameof(Details))!, string.Join("|", Details)); }
        return p;
    }
}

// System Abstraction with caching
public class EntityMgmtSys : IEntityMgmt {
    [CacheableService(Namespace = nameof(GetDetails))]
    public Task<HttpResponseSnapshot> GetDetails(EntityInfo entity, string type) {
        var r = _customHttpClient.SendAsync(...).Result;
        return HttpResponseSnapshot.FromAsync(r);
    }
}
```

### 2.2 KEY RULES

| Component | Requirement | Purpose |
|-----------|-------------|---------|
| Attribute | `[CacheableService(Namespace = "...")]` | Activates caching interceptor |
| Return Type | `HttpResponseSnapshot` | Supports caching |
| Domain | Implements `ICacheable` | Generates cache key |
| Cache Key | From `GetCacheKey()` method | Unique identifier |

---

## 3. DOMAIN RULES (Business Objects)

**üö® CRITICAL:** Domains are ALWAYS required and ALWAYS populated. They encapsulate business entities with behavior and are MANDATORY for Process Layer operations.

**Folder Organization:** Organize by business module
```
Domains/
‚îú‚îÄ‚îÄ <ModuleName>/              # Business module grouping (Employee, Leave, Maintenance, etc.)
‚îÇ   ‚îú‚îÄ‚îÄ EntityDomain.cs        # Main domain with IDomain<T>
‚îÇ   ‚îî‚îÄ‚îÄ EntityChild.cs         # Child/supporting domain objects
```

### 3.1 DOMAIN PATTERN (Standard Process Layer)

```csharp
public class EntityDomain : IDomain<int> {
    private int _id;
    public int Id { get => _id; set => _id = value; }
    public string? PropertyA { get; set; }
    public string? PropertyB { get; set; }
    public EntityDetails? Details { get; set; }
    public List<EntityChild> Items { get; set; } = new();
    
    // ‚úÖ ONLY simple business validation methods
    public bool IsRecurring() => Details != null && !string.IsNullOrEmpty(Details.Code);
    public bool HasItems() => Items != null && Items.Count > 0;
}
```

**Key Points:**
- NO constructor injection (no System Abstractions, no ILogger)
- NO methods that call external systems
- ONLY data properties and simple business validation methods
- Used as parameter when calling System Abstraction methods from Services

### 3.2 DOMAIN WITH CACHING (ICacheable)

**Pattern A: With IDomain<T>**
```csharp
public class EntityInfo : IDomain<int>, ICacheable {
    public int Id { get; set; }
    public string Code { get; set; } = string.Empty;
    public List<string> Details { get; set; }
    
    public IDictionary<PropertyInfo, object> GetCacheKey() {
        var p = new Dictionary<PropertyInfo, object>();
        p.Add(GetType().GetProperty(nameof(Code))!, Code!);
        if (Details?.Count > 0) { Details.Sort(); p.Add(GetType().GetProperty(nameof(Details))!, string.Join("|", Details)); }
        return p;
    }
}
```

**Pattern B: ONLY ICacheable (NO IDomain)**
```csharp
public class DataEntity : ICacheable {
    public string Code { get; set; } = string.Empty;
    public string Status { get; set; } = string.Empty;
    public string StartDate { get; set; } = string.Empty;
    public List<Attachment> Items { get; set; } = new();
    
    public IDictionary<PropertyInfo, object> GetCacheKey() {
        var p = new Dictionary<PropertyInfo, object>();
        p.Add(GetType().GetProperty(nameof(Code))!, Code!);
        p.Add(GetType().GetProperty(nameof(Status))!, Status!);
        p.Add(GetType().GetProperty(nameof(StartDate))!, StartDate!);
        return p;
    }
}
```

**When to use:** 
- **Pattern A (IDomain<T> + ICacheable):** Domain needs to call System Abstractions AND be used in cached calls
- **Pattern B (ONLY ICacheable):** Domain is used ONLY as request parameter for cached System Layer calls (no need for internal methods)

### 3.3 CHILD DOMAIN OBJECTS

**Purpose:** Supporting/nested objects used within main domains (attachments, details, events)

**Pattern A: Simple POCO (No DI)**
```csharp
public class EntityAttachment {
    public string FileName { get; set; } = string.Empty;
    public string FileType { get; set; } = string.Empty;
    public string FileContent { get; set; } = string.Empty;
    public string Description { get; set; } = string.Empty;
}
```

**Pattern B: With Constructor DI (If logging/dependencies needed)**
```csharp
public class EntityDetails {
    private int _id;
    public int Id { get => _id; set => _id = value; }
    public string Status { get; set; } = string.Empty;
    public DateTime? ScheduledDate { get; set; }
    
    private readonly ILogger<EntityDetails> _logger;
    public EntityDetails(ILogger<EntityDetails> logger) { _logger = logger; }
}
```

**Usage in Parent Domain:**
```csharp
public class EntityDomain : IDomain<int> {
    public int Id { get; set; }
    public EntityDetails? Details { get; set; }
    public List<EntityAttachment> Attachments { get; set; } = new();
}
```

### 3.4 SHARED SERVICES DOMAIN (Simple POCO)

```csharp
public class DataEntity {
    public string Code { get; set; } = string.Empty;
    public string Value { get; set; } = string.Empty;
    public DateTimeOffset ExpiresAt { get; set; }
    public int Counter { get; set; } = 0;
    public bool IsExpired() => Counter <= 0;
}
```

### 3.6 DI REGISTRATION

```csharp
// Main domains - NOT registered (simple POCOs, no constructor dependencies)
// EntityDomain, DataDomain - NOT registered

// Child domains with DI (if they have constructor dependencies like ILogger)
builder.Services.AddScoped<EntityDetails>();

// Child domains without DI (simple POCOs) - NOT registered

// Shared Services domains - NOT registered (simple POCOs)
```

**CRITICAL:** Main domains are NOT registered in DI because they have NO constructor dependencies. They are simple POCOs populated by DTOs and passed as parameters to Services/System Abstractions.

### 3.7 KEY RULES

| Rule | Main Domain | Child Domain (with DI) | Child Domain (POCO) | Shared Services |
|------|-------------|----------------------|---------------------|-----------------|
| Interface | `IDomain<T>` OR `ICacheable` OR both | NO interface | NO interface | NO interface |
| ICacheable | ‚úÖ Add if used in cached System Layer calls | ‚ùå Not used | ‚ùå Not used | ‚ùå Not used |
| Constructor DI | ‚ùå **NEVER** inject dependencies | ‚úÖ ILogger (if needed) | ‚ùå No constructor | ‚ùå No injection |
| Methods | ‚úÖ **ONLY** simple business validation (IsValid, IsRecurring) | Rare | None | Simple business methods |
| System Calls | ‚ùå **NEVER** call System/Process Abstractions | ‚ùå Not used | ‚ùå Not used | ‚ùå Not used |
| Registration | ‚ùå **NOT** registered (POCOs) | `AddScoped<EntityDetails>()` | ‚ùå Not registered | ‚ùå Not registered |
| Id Property | ‚úÖ Required (IDomain<T>) | ‚úÖ Optional | ‚ùå Rarely | ‚ùå Rarely |
| Folder | `Domains/<Module>/Entity.cs` | Same as parent | Same as parent | `Domains/Security/` |
| Purpose | Data holder + simple validation | Nested data | Nested data | Temporary state |

### 3.8 DOMAIN RESPONSIBILITIES (CRITICAL)

**üö® WHAT DOMAINS SHOULD DO:**
- ‚úÖ Hold data properties
- ‚úÖ Implement business validation methods (e.g., `IsRecurring()`, `IsExpired()`, `IsValid()`)
- ‚úÖ Implement `IDomain<T>` if needed
- ‚úÖ Implement `ICacheable` if used in cached System Layer calls
- ‚úÖ Be populated by DTOs via `dto.Populate(domain)`

**‚ùå WHAT DOMAINS SHOULD NEVER DO:**
- ‚ùå **NEVER** inject System Abstractions or Process Abstractions
- ‚ùå **NEVER** have methods that call System Layer or Process Layer APIs
- ‚ùå **NEVER** contain orchestration logic
- ‚ùå **NEVER** directly call external systems

**‚úÖ CORRECT DOMAIN PATTERN:**
```csharp
public class EntityDomain : IDomain<int>, ICacheable {
    public int Id { get; set; }
    public string Code { get; set; } = string.Empty;
    public EntityDetails? Details { get; set; }
    public List<EntityChild> Items { get; set; } = new();
    
    // ‚úÖ GOOD: Simple business validation methods
    public bool IsRecurring() => Details != null && !string.IsNullOrEmpty(Details.Code);
    public bool IsValid() => !string.IsNullOrEmpty(Code) && Items.Count > 0;
    
    public IDictionary<PropertyInfo, object> GetCacheKey() {
        var p = new Dictionary<PropertyInfo, object>();
        p.Add(GetType().GetProperty(nameof(Code))!, Code!);
        return p;
    }
}
```

**‚ùå WRONG PATTERN (DEPRECATED - DO NOT USE):**
```csharp
// ‚ùå NEVER DO THIS - Domains should NOT call System Abstractions
public class EntityDomain : IDomain<int> {
    private readonly ILogger<EntityDomain> _logger;
    private readonly EntitySys _entitySys;  // ‚ùå WRONG: No System Abstraction injection
    
    public EntityDomain(ILogger<EntityDomain> l, EntitySys s) { 
        _logger = l; 
        _entitySys = s;  // ‚ùå WRONG
    }
    
    internal async Task<HttpResponseMessage> CreateEntity() {  // ‚ùå WRONG: No API calls in domains
        var r = await _entitySys.CreateEntity(this);  // ‚ùå WRONG
        return r;
    }
}
```

**WHY THIS IS WRONG:**
- Violates separation of concerns (domains should be data + simple logic only)
- Makes domains tightly coupled to System Layer
- Orchestration belongs in Services, not Domains
- Testing becomes difficult with external dependencies in domains

**WHERE TO PUT SYSTEM LAYER CALLS:**
- ‚úÖ Services call System Abstractions
- ‚úÖ Azure Functions orchestrate via Services
- ‚úÖ Domains are passed as parameters to System Abstraction methods

---

## 4. SYSTEM ABSTRACTIONS RULES

**üö® CRITICAL:** SystemAbstractions handle Process‚ÜíSystem Layer communication.

### 4.1 SYSTEM ABSTRACTION PATTERN

```csharp
public class EntityMgmtSys : IEntityMgmt {
    private readonly AppConfigs _options;
    private readonly ICustomHTTPClient _customHttpClient;
    private readonly ILogger<EntityMgmtSys> _logger;
    
    public EntityMgmtSys(IOptions<AppConfigs> o, ICustomHTTPClient c, ILogger<EntityMgmtSys> l) { _options = o.Value; _customHttpClient = c; _logger = l; }
    
    public Task<HttpResponseMessage> CreateEntity(EntityDomain domain) {
        dynamic req = new ExpandoObject();
        req.Name = domain.PropertyA;
        req.Status = domain.Details?.Code;
        return SendJsonRequestAsync(HttpMethod.Post, _options.CreateEntityUrl, req);
    }
    
    private Task<HttpResponseMessage> SendJsonRequestAsync(HttpMethod m, string url, object body) {
        string json = JsonSerializer.Serialize(body);
        var h = new List<Tuple<string, string>> { RequestHeaders.TestRunId.Simplify(), RequestHeaders.RequestId.Simplify() };
        return _customHttpClient.SendAsync(m, url, () => new StringContent(json, Encoding.UTF8, ResponseHeaders.ContentTypeJson.Item2), h);
    }
}
```

### 4.2 SYSTEM ABSTRACTION WITH CACHING (HttpResponseSnapshot)

**üö® CACHING INTERCEPTOR:** Use `[CacheableService]` attribute to enable caching for System Layer responses.

```csharp
public class EntityMgmtSys : IEntityMgmt {
    [CacheableService(Namespace = nameof(GetDetails))]  // Caching interceptor
    public Task<HttpResponseSnapshot> GetDetails(EntityInfo entity, string type) {
        dynamic req = new ExpandoObject();
        string url = _options.EntityDetailsUrl.Replace("{id}", entity.Code).Replace("{type}", type);
        var r = _customHttpClient.SendProcessHTTPReqAsync(HttpMethod.Post, url, (object)req).Result;
        return HttpResponseSnapshot.FromAsync(r);
    }
}
```

**Key Rules:**
- Return type MUST be `HttpResponseSnapshot` (not `HttpResponseMessage`)
- Use `[CacheableService(Namespace = nameof(MethodName))]` attribute
- Domain MUST implement `ICacheable` interface for cache key generation

### 4.3 HEADER MANAGEMENT (CRITICAL)

```csharp
// Process‚ÜíSystem: ONLY technical tracing headers
private Task<HttpResponseMessage> SendJsonRequestAsync(...) {
    var h = new List<Tuple<string, string>> { RequestHeaders.TestRunId.Simplify(), RequestHeaders.RequestId.Simplify() };
    return _customHttpClient.SendAsync(..., h);
}
```

**üìò NOTE:** `.Simplify()` is a Framework extension function (`Core/Extensions/TupleExtension.cs`) that converts `Tuple<string, AsyncLocal<StringBuilder>>` to `Tuple<string, string>` by extracting the string value from AsyncLocal. It's used to prepare RequestHeaders for HTTP client calls.

### 4.4 KEY RULES

**üö® CRITICAL:** System Abstractions MUST implement interfaces and be injected via interface in Services.

| Component | Pattern | Usage |
|-----------|---------|-------|
| **Interface** | `public interface IEntityMgmt` | ‚úÖ MANDATORY - All System Abstractions must have interfaces |
| **Implementation** | `public class EntityMgmtSys : IEntityMgmt` | ‚úÖ MANDATORY - Must implement interface |
| **Injection in Service** | `private readonly IEntityMgmt _entityMgmt;` | ‚úÖ MANDATORY - Inject via interface |
| **Registration** | `builder.Services.AddScoped<IEntityMgmt, EntityMgmtSys>();` | ‚úÖ MANDATORY - Register with interface |
| Request Building | `ExpandoObject` for dynamic requests | Field mapping |
| URL Parameters | `string.Replace("{param}", value)` | Parameter substitution |
| Headers | TestRunId, RequestId (mandatory) | Technical tracing |
| Return Type | `HttpResponseMessage` or `HttpResponseSnapshot` | Standard or cached |
| Caching | `[CacheableService]` attribute | Cacheable operations |
| HTTP Method | `CustomHTTPClient.SendAsync()` | System Layer calls |

---

## 5. PROCESS ABSTRACTIONS RULES

**üö® CRITICAL:** ProcessAbstractions handle Process‚ÜíProcess Layer communication.

### 5.1 PROCESS ABSTRACTION PATTERN

**üö® CRITICAL:** Process Abstractions MUST implement interfaces and be injected via interface in Services.

```csharp
// Interface definition
public interface IAuthProc {
    Task<HttpResponseMessage> ProcessAuth(AuthReqDTO request, string provider, int priority);
}

// Implementation
public class AuthProc : IAuthProc {
    private readonly AppConfigs _options;
    private readonly CustomHTTPClient _customHttpClient;
    private readonly ILogger<AuthProc> _logger;
    
    public AuthProc(IOptions<AppConfigs> o, CustomHTTPClient c, ILogger<AuthProc> l) { _options = o.Value; _customHttpClient = c; _logger = l; }
    
    public Task<HttpResponseMessage> ProcessAuth(AuthReqDTO request, string provider, int priority) {
        dynamic req = new ExpandoObject();
        req.Code = request.Code;
        req.Config = new { Provider = provider, Priority = priority };
        var h = new List<Tuple<string, string>> { RequestHeaders.TestRunId.Simplify(), RequestHeaders.RequestId.Simplify() };
        return _customHttpClient.SendProcessHTTPReqAsync(HttpMethod.Post, _options.AuthProcessLayerUrl, (object)req, h);
    }
}
```

### 5.2 HEADER MANAGEMENT

```csharp
// Process‚ÜíProcess: Technical headers (mandatory) + business headers (if needed)
var h = new List<Tuple<string, string>> { RequestHeaders.TestRunId.Simplify(), RequestHeaders.RequestId.Simplify() };
// Add business headers if required by target Process Layer
if (!string.IsNullOrEmpty(_options.AppId)) h.Add(Tuple.Create("application-id", _options.AppId));
return _customHttpClient.SendProcessHTTPReqAsync(..., h);
```

### 5.3 KEY RULES

**üö® CRITICAL:** Process Abstractions MUST implement interfaces and be injected via interface in Services.

| Component | Pattern | Usage |
|-----------|---------|-------|
| **Interface** | `public interface IEntityProc` | ‚úÖ MANDATORY - All Process Abstractions must have interfaces |
| **Implementation** | `public class EntityProc : IEntityProc` | ‚úÖ MANDATORY - Must implement interface |
| **Injection in Service** | `private readonly IEntityProc _entityProc;` | ‚úÖ MANDATORY - Inject via interface |
| **Registration** | `builder.Services.AddScoped<IEntityProc, EntityProc>();` | ‚úÖ MANDATORY - Register with interface |
| Method | `SendProcessHTTPReqAsync()` | Process‚ÜíProcess calls |
| Headers | TestRunId, RequestId (mandatory) + business headers (if needed) | Technical + business context |
| Request Building | `ExpandoObject` | Dynamic requests |
| URL Config | From AppConfigs | Process Layer endpoints |
| Return Type | `HttpResponseMessage` | Standard response |

---

## 6. CALLING CENTRAL DATA PROCESS LAYER

**üö® CRITICAL DATABASE ACCESS RULE:**
- **Shared Services repository** is the **ONLY** Process Layer with database access
- **ALL OTHER** Process Layers **MUST** call Shared Services Azure Functions for ANY database operations
- **NEVER** create repositories, DbContext, or database connections in standard Process Layers

### 6.1 WHAT IS SHARED SERVICES (CENTRALIZED DATA PROCESS LAYER)?

**Purpose:** Centralized database operations and shared business logic for ALL Process Layers

**Repository:** `Shared Services/SharedService/`

**Database Types Handled:**
1. **Internal Application Database:**
   - LOVs (List of Values), configuration values, application settings, security tokens
   - Direct access via Repository<T> pattern + EF Core + Flyway migrations
2. **3rd Party System Databases:**
   - Create Azure Function in Shared Services to connect to 3rd party DB
   - Process Layers call this Azure Function (never direct connection)

**Key Characteristics:**
- **Database Access:** ONLY project with direct DB access (internal OR external databases)
- **Repositories:** Generic Repository<T> with full CRUD + pagination
- **EF Core + Flyway:** Database schema management and migrations (CI/CD integrated)
- **AutoMapper:** Entity-to-DTO mapping
- **KeyVault:** Secret management for connection strings
- **Azure Functions:** HTTP endpoints that other Process Layers call
- **Common Services:** Authentication (OTP, Token), LOVs, Cache management

**When to Use:**
- ‚úÖ Need LOVs or configuration values from internal database
- ‚úÖ Need authentication/authorization services (OTP, Token generation/validation)
- ‚úÖ Need to read/write application data (Applications, Settings)
- ‚úÖ Need to connect to 3rd party system database
- ‚úÖ Need cached data with DB fallback
- ‚úÖ Need cache management operations

**How to Use:**
1. Check if Azure Function already exists in Shared Services (`Functions/` directory)
2. If exists ‚Üí Call it via Process Abstraction (Section 5)
3. If not exists ‚Üí Create new Azure Function in Shared Services, then call it

### 6.2 CALLING PATTERN (Process‚ÜíProcess)

**Central data layer is called like any other Process Layer:**

```csharp
// In ProcessAbstractions/ or SystemAbstractions/
public class DataServicesProc {
    public Task<HttpResponseMessage> GetData(DataReqDTO req) {
        dynamic request = new ExpandoObject();
        request.Criteria = req.Criteria;
        var h = new List<Tuple<string, string>> { RequestHeaders.TestRunId.Simplify(), RequestHeaders.RequestId.Simplify() };
        // Add business headers if target function requires them
        if (req.Headers != null) h.AddRange(req.Headers.Select(kvp => Tuple.Create(kvp.Key, kvp.Value)));
        return _customHttpClient.SendProcessHTTPReqAsync(HttpMethod.Post, _options.DataServicesUrl, (object)request, h);
    }
}
```

### 6.3 KEY RULES

| Aspect | Pattern |
|--------|---------|
| Communication | `SendProcessHTTPReqAsync()` (Process-to-Process) |
| Headers | Technical headers + business headers (if function requires) |
| Location | ProcessAbstractions/ OR SystemAbstractions/ |
| Purpose | ALL database operations (internal + 3rd party), shared business logic |
| When to Create New Function | Need new DB operation not covered by existing Azure Functions |

---

## 7. SERVICES RULES

**üö® CRITICAL:** Services orchestrate business logic and coordinate abstraction calls.

**MANDATORY CALL FLOW:**
```
Function ‚Üí Service (inject Service directly OR via interface)
    ‚Üì
Service ‚Üí System Abstraction (via IEntityMgmt interface) OR Process Abstraction (via IEntityProc interface)
    ‚Üì
System/Process Abstraction ‚Üí System Layer OR Process Layer (HTTP calls)
```

**KEY RULES:**
- ‚úÖ Functions inject Services (can inject directly: `EntityService` OR via interface: `IEntityService`)
- ‚úÖ Services MUST inject System/Process Abstractions via interface (`IEntityMgmt`, `IEntityProc`)
- ‚ö†Ô∏è Services can be with or without interfaces (interface is optional for Services)

### 7.1 SERVICE WITH SYSTEM ABSTRACTION (Simple)

**üö® CRITICAL:** Services inject System Abstractions via interface. Services can be injected in Functions with or without interface.

```csharp
// Service implementation (interface optional)
public class DataService {
    private readonly ILogger<DataService> _logger; 
    private readonly IDataMgmt _dataMgmt;  // ‚úÖ System Abstraction injected via interface
    
    public DataService(ILogger<DataService> logger, IDataMgmt dataMgmt) { 
        _logger = logger; 
        _dataMgmt = dataMgmt; 
    }
    
    internal async Task<HttpResponseSnapshot> GetData(EntityDomain domain) {
        _logger.Info($"[Process Layer]-Initiating GetData for: {domain.Id}");
        var r = await _dataMgmt.GetDataDetails(domain, DataType.Primary.GetStringValue());
        _logger.Info($"[Process Layer]-Completed GetData"); 
        return r;
    }
}

// Optional: Service with interface (if needed)
public interface IDataService {
    Task<HttpResponseSnapshot> GetData(EntityDomain domain);
}
public class DataService : IDataService {
    // Same implementation as above
}
```

### 7.2 SERVICE WITH PROCESS ABSTRACTION (Validation & Error Handling)

**üö® CRITICAL:** Process Abstractions MUST be injected via interface in Services.

```csharp
public class EntityService : IEntityService {
    private readonly IEntityProc _entityProc;  // ‚úÖ Process Abstraction injected via interface
    private readonly ILogger<EntityService> _logger;
    
    public EntityService(IEntityProc entityProc, ILogger<EntityService> logger) { 
        _entityProc = entityProc; 
        _logger = logger; 
    }
    public async Task<EntityResDTO> VerifyEntity(EntityReqDTO request) {
        var dto = new EntityResDTO(); var r = await _entityProc.GetEntity(request);
        if (!r.IsSuccessStatusCode) throw new PassThroughHttpException(r.ExtractBaseResponse().Result, r.StatusCode);
        ResponseDTOHelper.PopulateEntity(await r.ExtractDataAsync(), dto);
        if (dto.Items == null || !dto.Items.Any()) throw new BusinessCaseFailureException(ErrorConstants.ENTITY_NOT_FOUND, [ErrorConstants.ENTITY_NOT_FOUND.Message], stepName: "EntityService.cs / VerifyEntity");
        return dto;
    }
}
```

### 7.3 SERVICE WITH REPOSITORY & CACHE (Central Data Layer)

```csharp
public class DataService : IDataService {
    private readonly ILogger<DataService> _logger; private readonly IExternalSys _externalSys; private readonly IConfigRepository _configRepo;
    public DataService(ILogger<DataService> logger, IExternalSys externalSys, IConfigRepository configRepo) { _logger = logger; _externalSys = externalSys; _configRepo = configRepo; }
    public async Task<BaseResponseDTO> ProcessData(DataReqDTO req) {
        _logger.Info("[Process Layer]-Initiating ProcessData");
        var config = await _configRepo.GetAsync(x => x.Id == Convert.ToInt32(req.Headers["config-id"]));
        if (config == null) throw new HttpBaseServerException(ErrorConstants.CONFIG_NOT_FOUND.Message, ErrorConstants.CONFIG_NOT_FOUND.ErrorCode, HttpStatusCode.InternalServerError, [ErrorConstants.CONFIG_NOT_FOUND.Message], stepName: "DataService.cs / ProcessData");
        CacheKey cacheKey = CacheKey.CreateCacheKey(req.GetCacheKey(), _namespace: "data", _cacheKeySettings: new CacheKeySettings { TimeToLive = TimeSpan.FromMinutes(config.CacheTTL) });
        var cachedData = await cacheKey.GetAsync<DataEntity>();
        if (cachedData != null && cachedData.IsValid()) return new BaseResponseDTO("Success", "", new DataResDTO { Id = cachedData.Id });
        var entity = BuildEntity(req.Payload, config); var r = await _externalSys.SendData(req, entity);
        if (!r.IsSuccessStatusCode) { await cacheKey.DeleteAsync(); throw new PassThroughHttpException(r.ExtractBaseResponse().Result, r.StatusCode); }
        await cacheKey.SetAsync(entity); _logger.Info("[Process Layer]-Completed ProcessData");
        return new BaseResponseDTO("Success", "", new DataResDTO { Id = entity.Id });
    }
    private DataEntity BuildEntity(string payload, Config config) { return new DataEntity { Payload = payload, ConfigId = config.Id, ProcessedAt = DateTime.UtcNow }; }
}
```

### 7.4 SERVICE WITH ORCHESTRATION (Multiple System Abstractions)

```csharp
public class DataOrchestrationService {
    private readonly ILogger<DataOrchestrationService> _logger; private readonly IEntityMgmt _entityMgmt; private readonly IReferenceMgmt _referenceMgmt; private readonly IDataMgmt _dataMgmt;
    public DataOrchestrationService(ILogger<DataOrchestrationService> logger, IEntityMgmt entityMgmt, IReferenceMgmt referenceMgmt, IDataMgmt dataMgmt) { _logger = logger; _entityMgmt = entityMgmt; _referenceMgmt = referenceMgmt; _dataMgmt = dataMgmt; }
    internal async Task<EntityResDTO> ProcessEntity(EntityDomain domain, string typeFilter) {
        _logger.Info($"[Process Layer]-Initiating ProcessEntity for: {domain.Id}");
        var r1 = await _entityMgmt.GetDetails(domain);
        if (!r1.IsSuccessStatusCode) throw new PassThroughHttpException(r1.ExtractBaseResponse(), (HttpStatusCode)r1.StatusCode);
        var entityDto = new EntityResDTO(); ResponseDTOHelper.PopulateEntity(r1.ExtractData(), entityDto);
        var r2 = await _referenceMgmt.GetLookupValues(new ReferenceReqDTO { Type = typeFilter });
        if (!r2.IsSuccessStatusCode) throw new PassThroughHttpException(r2.ExtractBaseResponse(), (HttpStatusCode)r2.StatusCode);
        var refData = ResponseDTOHelper.PopulateReference(r2.ExtractData());
        string typeCode = refData.Items?.FirstOrDefault(i => string.Equals(i.Name, entityDto.TypeName))?.Code ?? "";
        if (string.IsNullOrEmpty(typeCode)) throw new BusinessCaseFailureException(ErrorConstants.INVALID_TYPE, [ErrorConstants.INVALID_TYPE.Message], stepName: "DataOrchestrationService.cs / ProcessEntity");
        entityDto.TypeCode = typeCode; entityDto.TypeDescription = refData.Items?.FirstOrDefault(i => i.Code == typeCode)?.Description;
        _logger.Info($"[Process Layer]-Completed ProcessEntity"); return entityDto;
    }
}
```

### 7.5 CRITICAL SERVICE RULES

**üö® CRITICAL:** Services inject System/Process Abstractions via interface. Services can be injected in Functions with or without interface.

| Rule | Pattern | When to Use |
|------|---------|-------------|
| **Interfaces** | `public class EntityService : IEntityService` | ‚ö†Ô∏è **OPTIONAL** - Services can have interfaces if needed |
| **No Interface** | `public class EntityService` | ‚úÖ **ALLOWED** - Services without interfaces are valid |
| **Method Visibility** | `public` or `internal` | Methods can be public or internal |
| **Constructor** | Inject: ILogger, Abstractions (via interface), Repositories (via interface), IOptions<Config> | Always inject dependencies, System/Process Abstractions MUST be via interface |
| **System Abstraction Injection** | `private readonly IEntityMgmt _entityMgmt;` | ‚úÖ **MANDATORY** - MUST inject System Abstractions via interface |
| **Process Abstraction Injection** | `private readonly IEntityProc _entityProc;` | ‚úÖ **MANDATORY** - MUST inject Process Abstractions via interface |
| **Function Injection** | `private readonly EntityService _service;` OR `private readonly IEntityService _service;` | ‚úÖ Both patterns allowed - direct injection or via interface |
| **Logging Start** | `_logger.Info("[Process Layer]-Initiating MethodName")` | ALWAYS at method start |
| **Logging End** | `_logger.Info("[Process Layer]-Completed MethodName")` | ALWAYS before return |
| **Logging Error** | `_logger.Error("Description")` or `_logger.Warn("Warning")` | Before throwing exceptions or recoverable issues |
| **Return Type** | `HttpResponseSnapshot` for System Layer calls | When returning cached System Layer response |
| **Return Type** | `BaseResponseDTO` for API responses | When service is called directly from Function |
| **Return Type** | `{Entity}ResDTO` for orchestration | When service is called by other services |
| **Error Handling** | `PassThroughHttpException` for downstream failures | Always wrap downstream HTTP failures |
| **Error Handling** | `BusinessCaseFailureException` for business validation | Always use for domain validation failures |
| **Error Handling** | `HttpBaseServerException` for server errors | Central data layer only - DB/config failures |
| **Error Handling** | `NotFoundException` for not found cases | When expected data is missing |
| **stepName** | `"ClassName.cs / Executing MethodName"` | ALWAYS include in all exceptions |

### 7.6 CACHE OPERATIONS PATTERN

```csharp
// Create cache key with TTL
CacheKey key = CacheKey.CreateCacheKey(requestDto.GetCacheKey(), _namespace: "data", _cacheKeySettings: new CacheKeySettings { TimeToLive = TimeSpan.FromMinutes(30) });

// Get from cache
Entity? cached = await key.GetAsync<Entity>();

// Set to cache
await key.SetAsync(entity);

// Delete from cache
await key.DeleteAsync();

// Update TTL dynamically
key.Settings = new CacheKeySettings { TimeToLive = TimeSpan.FromMinutes(60) };
await key.SetAsync(entity);
```

### 7.7 REPOSITORY PATTERN USAGE

```csharp
// Simple get with filter
var config = await _configRepo.GetAsync(x => x.Id == entityId);

// Get list with filter
var items = await _itemsRepo.GetAllAsync(x => x.Status == "Active");

// Create
var newEntity = new Entity { Name = "Test", CreatedAt = DateTime.UtcNow };
await _entityRepo.CreateAsync(newEntity);

// Update
entity.Status = "Updated"; entity.ModifiedAt = DateTime.UtcNow;
await _entityRepo.UpdateAsync(entity);

// Delete
await _entityRepo.DeleteAsync(entityId);
```

### 7.8 VALIDATION CHAINS PATTERN

```csharp
// Step 1: Check if resource exists
if (cachedData == null) throw new BusinessCaseFailureException(ErrorConstants.DATA_NOT_FOUND, [ErrorConstants.DATA_NOT_FOUND.Message], stepName: "Service.cs / Method");

// Step 2: Check access/lock status
if (cachedData.IsLocked()) throw new BusinessCaseFailureException(ErrorConstants.ACCOUNT_LOCKED, [ErrorConstants.ACCOUNT_LOCKED.Message], stepName: "Service.cs / Method");

// Step 3: Check expiration
if (cachedData.ExpiresAt <= DateTimeOffset.UtcNow) throw new BusinessCaseFailureException(ErrorConstants.DATA_EXPIRED, [ErrorConstants.DATA_EXPIRED.Message], stepName: "Service.cs / Method");

// Step 4: Validate input
if (string.IsNullOrEmpty(requestDto.RequiredField)) throw new RequestValidationFailureException(errorDetails: ["Required field is missing"], stepName: "Service.cs / Method");
```

### 7.9 CONFIGURATION INJECTION PATTERN

```csharp
// In constructor
private readonly AppConfigs _appConfigs;
public SecurityService(IOptions<AppConfigs> appConfigs) { _appConfigs = appConfigs.Value; }

// Usage
TimeSpan timeout = TimeSpan.FromSeconds(_appConfigs.TimeoutSeconds);
string separator = _appConfigs.CustomSeparator ?? "|@#$|";
```

### 7.10 DI REGISTRATION PATTERNS

**üö® CRITICAL:** Services can be registered with or without interfaces. System/Process Abstractions MUST be registered with interfaces.

```csharp
// ‚úÖ CORRECT - Service without interface (direct injection)
builder.Services.AddScoped<EntityService>();
builder.Services.AddScoped<DataService>();

// ‚úÖ CORRECT - Service with interface (if interface exists)
builder.Services.AddScoped<IEntityService, EntityService>();
builder.Services.AddScoped<IDataService, DataService>();

// ‚úÖ CORRECT - Central Data Layer (typically with interface for public APIs)
builder.Services.AddScoped<ISecurityService, SecurityService>();
builder.Services.AddScoped<IReferenceService, ReferenceService>();

// ‚úÖ CORRECT - Transient for stateless utilities
builder.Services.AddTransient<DataService>();
// OR
builder.Services.AddTransient<IDataService, DataService>();
```

### 7.11 METHOD NAMING CONVENTIONS

| Operation | Method Name Pattern | Example |
|-----------|-------------------|---------|
| Create | `Create{Entity}` | `CreateEntity`, `CreateToken` |
| Get Single | `Get{Entity}` | `GetEntity`, `GetDetails` |
| Get List | `Get{Entity}List` or `Retrieve{Entity}` | `GetEntityList`, `RetrieveEntities` |
| Update | `Update{Entity}` | `UpdateEntity`, `UpdateStatus` |
| Delete | `Delete{Entity}` | `DeleteEntity`, `RemoveToken` |
| Validate | `Validate{Entity}` | `ValidateToken`, `ValidateEntity` |
| Verify | `Verify{Entity}` | `VerifyEntity`, `VerifyCredentials` |
| Process | `Process{Entity}` | `ProcessEntity`, `ProcessData` |
| Generate | `Generate{Entity}` | `GenerateToken`, `GenerateCode` |

### 7.12 KEY PATTERNS SUMMARY

| Pattern | Standard Process Layer | Central Data Layer |
|---------|------------------------|-------------------|
| **Dependencies** | SystemAbstractions, ProcessAbstractions, ILogger | Repositories, SystemAbstractions, Cache, ILogger, IOptions |
| **Registration** | `AddScoped<IEntityService, EntityService>()` or `AddScoped<EntityService>()` | `AddScoped<ISecurityService, SecurityService>()` |
| **Return Types** | `HttpResponseSnapshot`, `{Entity}ResDTO` | `BaseResponseDTO`, `{Entity}ResDTO` |
| **Error Handling** | PassThroughHttpException, BusinessCaseFailureException | Same + HttpBaseServerException + NotFoundException |
| **Response Mapping** | ResponseDTOHelper | ResponseDTOHelper |
| **Logging** | `[Process Layer]-Initiating/Completed` | Same |
| **Cache** | Not common | CacheKey operations (Set/Get/Delete) |
| **Repository** | Never | Always for DB access |
| **Helper Methods** | Rare | Common (private methods for generation, hashing, etc.) |

---

## 8. AZURE FUNCTIONS RULES

**üö® CRITICAL:** Functions are thin HTTP orchestrators.

**MANDATORY CALL FLOW:**
- Functions call Services (inject directly: `EntityService` OR via interface: `IEntityService`)
- Functions NEVER call System/Process Abstractions directly
- Functions NEVER call System/Process Layers directly

**KEY RULES:**
- ‚úÖ Functions inject Services (can inject directly: `EntityService` OR via interface: `IEntityService`)
- ‚ùå Functions MUST NOT inject System/Process Abstractions directly
- ‚ùå Functions MUST NOT call System/Process Layers directly

### 8.1 FUNCTION STRUCTURE (Standard)

**üö® CRITICAL:** Functions inject Services (with or without interface).

```csharp
// Pattern A: Service without interface (direct injection)
public class CreateEntityFunction {
    private readonly ILogger<CreateEntityFunction> _logger; 
    private readonly EntityService _service;  // ‚úÖ Direct injection allowed
    
    public CreateEntityFunction(ILogger<CreateEntityFunction> l, EntityService s) { 
        _logger = l; 
        _service = s; 
    }

// Pattern B: Service with interface (interface injection)
public class CreateEntityFunction {
    private readonly ILogger<CreateEntityFunction> _logger; 
    private readonly IEntityService _service;  // ‚úÖ Interface injection also allowed
    
    public CreateEntityFunction(ILogger<CreateEntityFunction> l, IEntityService s) { 
        _logger = l; 
        _service = s; 
    }
    [Function("CreateEntityAPI")]
    public async Task<BaseResponseDTO> Run([HttpTrigger(AuthorizationLevel.Anonymous, "post", Route = "entity/create")] HttpRequest req) {
        _logger.Info("HTTP Request received for CreateEntityAPI.");
        var dto = await req.ReadBodyAsync<EntityReqDTO>();
        if (dto == null) throw new NoRequestBodyException(errorDetails: [ErrorCodes.REQ_BODY_MISSING_OR_EMPTY.Message], stepName: "CreateEntityFunction.cs / Executing Run");
        dto.Headers = req.Headers.ToDictionary(h => h.Key.ToLower(), h => h.Value.FirstOrDefault() ?? string.Empty);
        dto.Validate(); 
        var domain = new EntityDomain(); dto.Populate(domain);
        var r = await _service.Execute(domain);
        if (r.IsSuccessStatusCode) { var resDto = new EntityResDTO(); ResponseDTOHelper.PopulateEntity(r.ExtractData(), resDto); return new BaseResponseDTO("Success", "", resDto); }
        else { throw new PassThroughHttpException(r.ExtractBaseResponse(), (HttpStatusCode)r.StatusCode); }
    }
}
```

### 8.2 FUNCTION WITH ORCHESTRATION

```csharp
[Function("ProcessEntityAPI")]
public async Task<BaseResponseDTO> Run([HttpTrigger(AuthorizationLevel.Anonymous, "post")] HttpRequest req) {
    _logger.Info("HTTP Request received for ProcessEntityAPI.");
    var dto = await req.ReadBodyAsync<EntityReqDTO>();
    if (dto == null) throw new NoRequestBodyException(errorDetails: [ErrorCodes.REQ_BODY_MISSING_OR_EMPTY.Message], stepName: "ProcessEntityFunction.cs / Executing Run");
    dto.Headers = req.Headers.ToDictionary(h => h.Key.ToLower(), h => h.Value.FirstOrDefault() ?? string.Empty); dto.Validate();
    var domain = new EntityDomain(); dto.Populate(domain);
    var r1 = await _service1.GetEntity(domain);
    if (!r1.IsSuccessStatusCode) throw new PassThroughHttpException(r1.ExtractBaseResponse(), (HttpStatusCode)r1.StatusCode);
    ResponseDTOHelper.PopulateEntity(r1.ExtractData(), entityDto);
    var r2 = await _service2.GetLookupValues(refReq);
    if (!r2.IsSuccessStatusCode) throw new PassThroughHttpException(r2.ExtractBaseResponse(), (HttpStatusCode)r2.StatusCode);
    var refData = ResponseDTOHelper.PopulateReference(r2.ExtractData());
    string id = refData.Items?.FirstOrDefault(i => string.Equals(i.Name, dto.Type))?.Code ?? "";
    if (string.IsNullOrEmpty(id)) throw new RequestValidationFailureException(errorDetails: ["Invalid type"], stepName: "ProcessEntityFunction.cs / Executing Run");
    var r3 = await _service3.CreateEntity(domain, id, param);
    if (r3.IsSuccessStatusCode) { var res = new EntityResDTO(); ResponseDTOHelper.PopulateEntity(r3.ExtractData(), res, refData); return new BaseResponseDTO("Success", "", res); }
    else { throw new PassThroughHttpException(r3.ExtractBaseResponse(), (HttpStatusCode)r3.StatusCode); }
}
```

### 8.3 FUNCTION WITH BATCH PROCESSING

```csharp
[Function("BatchCreateAPI")]
public async Task<BaseResponseDTO> Run([HttpTrigger(AuthorizationLevel.Anonymous, "post")] HttpRequest req) {
    _logger.Info("HTTP Request received for BatchCreateAPI.");
    var dto = await req.ReadBodyAsync<BatchReqDTO>();
    if (dto == null) throw new NoRequestBodyException(errorDetails: [ErrorCodes.REQ_BODY_MISSING_OR_EMPTY.Message], stepName: "BatchCreateFunction.cs / Executing Run");
    dto.Validate(); var response = new BatchResDTO(); var errors = new List<ErrorDetails>();
    foreach (var item in dto.Items) {
        try { 
            var domain = new EntityDomain(); item.Populate(domain);
            var r = await _service.CreateEntity(domain);
            if (r.IsSuccessStatusCode) { var itemRes = new ItemResDTO(); ResponseDTOHelper.PopulateItem(await r.ExtractDataAsync(), itemRes); response.Items.Add(itemRes); }
            else { var err = r.ExtractBaseResponse().Result; errors.Add(new ErrorDetails { ErrorCode = err.ErrorCode, Message = err.Message }); }
        } catch (Exception ex) { errors.Add(new ErrorDetails { ErrorCode = "BATCH_CREATE_0001", Message = ex.Message }); }
    }
    if (errors.Any()) {
        if (response.Items.Any()) return new BaseResponseDTO("Partial success", ErrorConstants.BATCH_PARTIAL_FAILURE.ErrorCode, response, new ErrorDetails { ErrorCode = ErrorConstants.BATCH_PARTIAL_FAILURE.ErrorCode, Details = errors.SelectMany(e => e.Details).ToList() }, isDownStreamError: false, isPartialSuccess: true);
        else throw new BusinessCaseFailureException(ErrorConstants.BATCH_ALL_FAILED, errors.SelectMany(e => e.Details).ToList());
    }
    return new BaseResponseDTO("Success", "", response);
}
```

### 8.4 FUNCTION WITH ROUTE PARAMETERS

```csharp
[Function("GetEntityByIdAPI")]
public async Task<BaseResponseDTO> Run([HttpTrigger(AuthorizationLevel.Anonymous, "post", Route = "entity/{entityId}")] HttpRequest req, string entityId) {
    _logger.Info("HTTP Request received for GetEntityByIdAPI.");
    var dto = await req.ReadBodyAsync<EntityReqDTO>();
    if (dto == null) throw new NoRequestBodyException(errorDetails: [ErrorCodes.REQ_BODY_MISSING_OR_EMPTY.Message], stepName: "GetEntityFunction.cs / Executing Run");
    dto.Headers = req.Headers.ToDictionary(h => h.Key.ToLower(), h => h.Value.FirstOrDefault() ?? string.Empty); dto.EntityId = entityId; dto.Validate();
    var domain = new EntityDomain(); dto.Populate(domain);
    var r = await _service.GetEntity(domain);
    if (r.IsSuccessStatusCode) { var res = new EntityResDTO(); ResponseDTOHelper.PopulateEntity(r.ExtractData(), res); return new BaseResponseDTO("Success", "", res); }
    else { throw new PassThroughHttpException(r.ExtractBaseResponse(), (HttpStatusCode)r.StatusCode); }
}
```

**Route Parameter Name Matching:**
- Route parameter name in function signature can match route template parameter (case-insensitive)
- Example: `Route = "entity/{entityId}"` works with parameter `string entityId` or `string EntityId`
- Azure Functions automatically binds route parameters by name (case-insensitive matching)
- Alternative: Use `dto.Populate(new Tuple<string, EntityDomain>(entityId, domain))` pattern (see Section 9.2.1)

### 8.5 FUNCTION WITHOUT DOMAIN (Central Data Layer)

```csharp
public class SecurityFunction {
    private readonly ILogger<SecurityFunction> _logger; private readonly ISecurityService _securityService;
    public SecurityFunction(ILogger<SecurityFunction> logger, ISecurityService securityService) { _logger = logger; _securityService = securityService; }
    [Function("GenerateSecurityTokenAPI")]
    public async Task<BaseResponseDTO> Run([HttpTrigger(AuthorizationLevel.Anonymous, "post")] HttpRequest req) {
        _logger.Info("HTTP trigger received for GenerateSecurityTokenAPI.");
        var dto = await req.ReadBodyAsync<SecurityReqDTO>();
        if (dto == null) throw new NoRequestBodyException(errorDetails: [ErrorCodes.REQ_BODY_MISSING_OR_EMPTY.Message], stepName: "SecurityFunction.cs / Executing Run");
        dto.Headers = req.Headers.ToDictionary(h => h.Key, h => h.Value.ToString()); dto.Validate();
        return await _securityService.GenerateToken(dto);
    }
}
```

### 8.6 CRITICAL FUNCTION RULES

| Component | Pattern | Mandatory | Notes |
|-----------|---------|-----------|-------|
| **Authorization** | `AuthorizationLevel.Anonymous` | ‚úÖ Always | NEVER use Function or Admin level |
| **HTTP Method** | `"post"` | ‚úÖ Always | POST is standard for all APIs |
| **Return Type** | `Task<BaseResponseDTO>` | ‚úÖ Always | Always async, always BaseResponseDTO |
| **Logging** | `_logger.Info("HTTP Request received...")` | ‚úÖ Always | Use Info() for function start |
| **Body Reading** | `await req.ReadBodyAsync<DTO>()` | ‚úÖ Always | Framework extension method |
| **Null Check** | `throw new NoRequestBodyException(errorDetails:..., stepName:...)` | ‚úÖ Always | MUST include errorDetails and stepName |
| **Headers** | `req.Headers.ToDictionary(...)` | ‚úÖ Always | Two patterns (see 8.7) |
| **Validation** | `dto.Validate()` | ‚úÖ Always | AFTER headers assignment |
| **Domain Population** | `dto.Populate(_domain)` | ‚úÖ Always for standard Process Layer | NOT for Shared Services |
| **Response Mapping** | `ResponseDTOHelper` | ‚úÖ Always | NEVER manual JSON parsing |
| **Error Handling** | PassThroughHttpException, BusinessCaseFailureException | ‚úÖ Always | Framework exceptions only |
| **Route Parameters** | Match parameter name (case-insensitive) | ‚úÖ If using route | Parameter name doesn't need exact case match; can use Tuple pattern (Section 9.2.1) |

### 8.7 HEADERS HANDLING PATTERNS

**Pattern 1: Lowercase keys (Standard Process Layer with domains):**
```csharp
dto.Headers = req.Headers.ToDictionary(h => h.Key.ToLower(), h => h.Value.FirstOrDefault() ?? string.Empty);
```
**When:** Standard Process Layers that use domains and call System Layer  
**Purpose:** Normalize header keys for consistent downstream processing

**Pattern 2: Preserve case (Central Data Layer with database access):**
```csharp
dto.Headers = req.Headers.ToDictionary(h => h.Key, h => h.Value.ToString());
```
**When:** Central data layer with direct database access and NO domains  
**Purpose:** Preserve original header casing for application-specific requirements

### 8.8 LOGGING LEVELS USAGE

```csharp
_logger.Info("HTTP Request received for CreateEntityAPI.");  // Function start
_logger.Info($"Processing {count} items.");                  // Major operation steps
_logger.Debug($"Processing item {i} of {total}.");          // Detailed progress
_logger.Warn($"Item {i} failed: {errorMsg}");               // Recoverable issues
_logger.Error($"Unexpected error: {ex.Message}");           // Errors
_logger.Error(ex, "Critical failure in processing.");       // Errors with exception
```

**Rules:**
- **Info**: Function entry, major milestones, success messages
- **Debug**: Detailed step-by-step progress, variable values
- **Warn**: Partial failures, recoverable errors, validation warnings
- **Error**: Unrecoverable errors, exceptions, critical failures

### 8.9 EXCEPTION STEPNAME FORMAT

**Standard format:** `"<FileName>.cs / Executing <MethodName> / <OptionalContext>"`

**Examples:**
```csharp
stepName: "CreateEntityFunction.cs / Executing Run"  // Simple
stepName: "CreateEntityFunction.cs / Executing Run / NoRequestBodyException"  // With context
stepName: "BatchCreateFunction.cs / Executing ProcessBatch / Item validation"  // Processing step
stepName: "EntityService.cs / GetEntity / Invalid entity type"  // Nested operation
```

### 8.10 SERVICELOCATOR PATTERN

**When to use:** Batch processing where multiple domain instances needed per request

```csharp
// ‚ùå WRONG - Reusing same domain instance
var domain = new EntityDomain();
foreach (var item in dto.Items) { 
    item.Populate(domain); // ‚ùå Overwrites previous item data!
    await _service.CreateEntity(domain); 
}

// ‚úÖ CORRECT - New domain instance per item
foreach (var item in dto.Items) { 
    var domain = new EntityDomain(); // ‚úÖ Fresh instance each iteration
    item.Populate(domain);
    await _service.CreateEntity(domain);
}
```

**Rule:** Use ServiceLocator ONLY in batch/loop scenarios. For single operations, inject domain via constructor.

---

## 9. DTO RULES

**üö® CRITICAL:** DTOs handle request/response data with validation and population logic.

### 9.1 REQUEST DTO PATTERN

```csharp
public class EntityReqDTO : IRequestBaseDTO, IRequestPopulatorDTO<EntityDomain> {
    public string? Code { get; set; }
    public string? Email { get; set; }
    public List<ItemDTO>? Items { get; set; }
    public Dictionary<string, string> Headers { get; set; }
    
    public void Validate() {
        List<string> errors = new();
        if (string.IsNullOrWhiteSpace(Code)) errors.Add(nameof(Code) + " is Required.");
        if (!string.IsNullOrWhiteSpace(Email) && !Email.IsValidEmail()) errors.Add(nameof(Email) + " is invalid.");
        if (errors.Any()) throw new RequestValidationFailureException(errorDetails: errors, stepName: "EntityReqDTO.cs / Validate");
    }
    
    public void Populate(EntityDomain domain) {
        domain.Code = this.Code;
        domain.Email = this.Email;
        domain.Items = this.Items?.Select(i => new EntityChild { Name = i.Name, Value = i.Value }).ToList() ?? new List<EntityChild>();
    }
}
```

### 9.2 REQUEST DTO WITH SERVICELOCATOR (Nested Objects)

```csharp
public void Populate(EntityDomain domain) {
    domain.Code = this.Code;
    if (this.Details != null) {
        var nested = ServiceLocator.ServiceProvider.GetService<EntityDetails>();
        nested.Name = this.Details.Name;
        domain.Details = nested;
    }
    if (this.ResourceId != null) {
        var child = ServiceLocator.ServiceProvider.GetService<EntityChild>();
        child.Id = ResourceId;
        domain.Items.Add(child);
    }
}
```

### 9.2.1 REQUEST DTO WITH TUPLE PARAMETER (Route Parameters)

**Pattern:** When Function has route parameters that need to be passed to domain during population.

```csharp
// In Function
[Function("GetEntityByIdAPI")]
public async Task<BaseResponseDTO> Run(
    [HttpTrigger(AuthorizationLevel.Anonymous, "post", Route = "entity/{entityId}")] 
    HttpRequest req, 
    string entityId) {
    var dto = await req.ReadBodyAsync<EntityReqDTO>();
    var domain = new EntityDomain();
    dto.Populate(new Tuple<string, EntityDomain>(entityId, domain));
    // ... rest of function
}

// In DTO Populate method
public void Populate(Tuple<string, EntityDomain> routeParams) {
    var (routeValue, domain) = routeParams;
    domain.RouteParameter = routeValue;
    domain.Code = this.Code;
    domain.PropertyA = this.PropertyA;
}
```

**Key Points:**
- Tuple first element: Route parameter value
- Tuple second element: Domain instance to populate
- Useful when route parameters need to be set on domain before other properties

### 9.3 RESPONSE DTO PATTERN

```csharp
public class EntityResDTO {
    public long Id { get; set; }
    public string Name { get; set; } = string.Empty;
    public string Status { get; set; } = string.Empty;
    public DateTime? CreatedAt { get; set; }
    public List<ItemDTO> Items { get; set; } = new();
}
```

### 9.4 KEY RULES\r\n\r\n| Component | Pattern | Mandatory |
|-----------|---------|-----------|
| Interface | `IRequestBaseDTO` for requests | ‚úÖ Request DTOs |
| Interface | `IRequestPopulatorDTO<EntityDomain>` if populating | ‚úÖ Standard Process Layer |
| Validate() | Throws `RequestValidationFailureException` | ‚úÖ All Request DTOs |
| Populate() | Maps DTO ‚Üí Domain | ‚úÖ Standard Process Layer (NOT Shared Services) |
| Headers | `Dictionary<string, string> Headers` | ‚úÖ If using headers |
| Folder | `DTOs/<FeatureName>/` | ‚úÖ Always |

---

## 10. RESPONSE DTO HELPER RULES

**üö® CRITICAL:** ResponseDTOHelper provides standardized JSON‚ÜíDTO mapping.

### 10.1 DIRECT DESERIALIZATION PATTERN

```csharp
public static EntityResDTO PopulateEntity(string json, EntityResDTO dto) {
    var opts = new JsonSerializerOptions { PropertyNameCaseInsensitive = true };
    var apiRes = JsonSerializer.Deserialize<EntityResDTO>(json, opts);
    if (apiRes != null) { dto.Id = apiRes.Id; dto.Name = apiRes.Name; dto.Items = apiRes.Items; }
    return dto;
}
```

### 10.2 DICTIONARY EXTRACTION PATTERN

```csharp
public static void PopulateEntity(string json, EntityResDTO dto) {
    var dict = JsonSerializer.Deserialize<Dictionary<string, object>>(json)!;
    dto.Id = dict.ToIntValue(nameof(dto.Id));
    dto.Status = dict.ToStringValue(nameof(dto.Status));
    dto.Amount = dict.ToDecimalValue(nameof(dto.Amount));
    dto.CreatedAt = dict.ToDateTimeValue(nameof(dto.CreatedAt));
    dto.IsActive = dict.ToBoolValue(nameof(dto.IsActive));
}
```

### 10.3 COMPLEX NESTED PATTERN

```csharp
public static void PopulateEntity(string json, EntityResDTO dto) {
    var dict = JsonSerializer.Deserialize<Dictionary<string, object>>(json)!;
    if (dict.TryGetValue(nameof(dto.Items), out object? obj)) {
        var list = JsonSerializer.Deserialize<List<Dictionary<string, object>>>(obj.ToString() ?? "");
        if (list?.Any() == true) {
            dto.Items = new List<ItemDTO>();
            foreach (var item in list) { dto.Items.Add(new ItemDTO { Name = item.ToStringValue(nameof(ItemDTO.Name)), Value = item.ToIntValue(nameof(ItemDTO.Value)) }); }
        }
    }
}
```

### 10.4 RESPONSE ENRICHMENT PATTERN

```csharp
public static EntityResDTO PopulateEntity(string json, EntityResDTO dto, ReferenceResDTO refData) {
    var dict = JsonSerializer.Deserialize<Dictionary<string, object>>(json)!;
    dto.Id = dict.ToLongValue(nameof(dto.Id));
    dto.TypeName = refData?.Items?.FirstOrDefault(i => i?.Code == dict.ToStringValue(nameof(dto.TypeName)))?.Name ?? "";
    return dto;
}
```

### 10.5 KEY RULES

| Pattern | Usage | When |
|---------|-------|------|
| Direct Deserialization | Simple DTO matching | JSON matches DTO structure |
| Dictionary Extraction | Flexible mapping | JSON doesn't match DTO |
| Complex Nested | Arrays/nested objects | Complex response structure |
| Response Enrichment | Combine multiple sources | Reference data lookup |
| Static Methods | `public static` | Always |
| Location | `Helper/ResponseDTOHelper.cs` | Mandatory |

---

## 11. CENTRAL DATA PROCESS LAYER UNIQUE PATTERNS

**üö® CRITICAL DATABASE EXCLUSIVITY:**
- Central Data Layer is the **ONLY** Process Layer with database access
- Handles **internal application database** (LOVs, configs, app data) via Repository + EF Core
- Handles **3rd party system databases** via dedicated Azure Functions
- **ALL OTHER** Process Layers MUST call Central Data Layer Azure Functions for ANY database operations

### 11.1 REPOSITORY PATTERN (Shared Services ONLY)

**Location:** `Shared Services/SharedService/Repositories/Repository.cs`

```csharp
public class Repository<T> : IRepository<T> where T : class {
    private readonly AppDbContext _db; internal DbSet<T> dbSet;
    public Repository(AppDbContext db) { _db = db; dbSet = _db.Set<T>(); }
    
    // Single operations
    public async Task<T?> GetAsync(Expression<Func<T, bool>> f, string? includeProps = null, bool tracked = false) {
        IQueryable<T> q = tracked ? dbSet : dbSet.AsNoTracking();
        if (f != null) q = q.Where(f);
        if (!string.IsNullOrEmpty(includeProps)) foreach (var p in includeProps.Split(',', StringSplitOptions.RemoveEmptyEntries)) q = q.Include(p.Trim());
        return await q.FirstOrDefaultAsync();
    }
    public async Task<IEnumerable<T>> GetAllAsync(Expression<Func<T, bool>>? f = null, string? includeProps = null, bool tracked = false) {
        IQueryable<T> q = tracked ? dbSet : dbSet.AsNoTracking();
        if (f != null) q = q.Where(f);
        if (!string.IsNullOrEmpty(includeProps)) foreach (var p in includeProps.Split(',', StringSplitOptions.RemoveEmptyEntries)) q = q.Include(p.Trim());
        return await q.ToListAsync();
    }
    public async Task<IEnumerable<T>> GetAllAsync(Expression<Func<T, bool>>? f = null, string? includeProps = null, bool tracked = false, int pageNumber = 1, int pageSize = 10) {
        IQueryable<T> q = tracked ? dbSet : dbSet.AsNoTracking();
        if (f != null) q = q.Where(f);
        if (!string.IsNullOrEmpty(includeProps)) foreach (var p in includeProps.Split(',', StringSplitOptions.RemoveEmptyEntries)) q = q.Include(p.Trim());
        q = q.Skip((pageNumber - 1) * pageSize).Take(pageSize);
        return await q.ToListAsync();
    }
    public async Task<bool> AnyAsync(Expression<Func<T, bool>> f) => await dbSet.AnyAsync(f);
    public async Task AddAsync(T entity) => await dbSet.AddAsync(entity);
    public async Task<int> AddAsync(T entity, string ReturnIDName) { await dbSet.AddAsync(entity); await _db.SaveChangesAsync(); return _db.Entry(entity).Property(ReturnIDName).CurrentValue as int? ?? 0; }
    public async Task AddRangeAsync(IEnumerable<T> entities) => await dbSet.AddRangeAsync(entities);
    public async Task UpdateAsync(T entity) { dbSet.Attach(entity); _db.Entry(entity).State = EntityState.Modified; await Task.CompletedTask; }
    public async Task UpdateRangeAsync(IEnumerable<T> entities) { foreach (var e in entities) { dbSet.Attach(e); _db.Entry(e).State = EntityState.Modified; } await Task.CompletedTask; }
    public async Task RemoveAsync(T entity) { dbSet.Remove(entity); await Task.CompletedTask; }
    public async Task RemoveRangeAsync(IEnumerable<T> entities) { dbSet.RemoveRange(entities); await Task.CompletedTask; }
}
```

**Key Features:**
- Generic CRUD operations for ALL entities
- Supports eager loading via `includeProperties` (comma-separated)
- Pagination support with `pageNumber` and `pageSize`
- Bulk operations: AddRange, UpdateRange, RemoveRange
- Tracked vs AsNoTracking queries for performance
- AddAsync with return ID for auto-increment scenarios

### 11.2 EF CORE DBCONTEXT (Shared Services ONLY)

**Location:** `Shared Services/SharedService/Models/AppDbContext.cs`

```csharp
public partial class AppDbContext : DbContext {
    public AppDbContext(DbContextOptions<AppDbContext> options) : base(options) { }
    public virtual DbSet<Application> Applications { get; set; }
    public virtual DbSet<ApplicationOtpSetting> ApplicationOtpSettings { get; set; }
    public virtual DbSet<ApplicationTokenSetting> ApplicationTokenSettings { get; set; }
    public virtual DbSet<Lov> Lovs { get; set; }
    public virtual DbSet<LovLevel1> LovLevel1 { get; set; }
    public virtual DbSet<LovLevel2> LovLevel2 { get; set; }
    protected override void OnModelCreating(ModelBuilder m) {
        m.Entity<Application>(e => { e.HasKey(e => e.ApplicationId).HasName("PK__Application"); e.ToTable("Application"); e.Property(e => e.ApplicationId).HasColumnName("ApplicationID"); e.Property(e => e.CreatedAt).HasDefaultValueSql("(getdate())").HasColumnType("datetime"); e.Property(e => e.IsActive).HasDefaultValue(true); });
        m.Entity<Lov>(e => { e.HasKey(e => e.Id).HasName("PK__LOV"); e.ToTable("LOV"); e.Property(e => e.CreatedDate).HasDefaultValueSql("(getdate())").HasColumnType("datetime"); });
        m.Entity<LovLevel1>(e => { e.HasKey(e => e.Id).HasName("PK__LOV_LEVEL1"); e.ToTable("LOV_LEVEL1"); e.HasOne(d => d.Lov).WithMany(p => p.LovLevel1).HasForeignKey(d => d.Lovid).HasConstraintName("FK_LOV_LEVEL1_LOV"); });
        OnModelCreatingPartial(m);
    }
    partial void OnModelCreatingPartial(ModelBuilder m);
}
```

**Key Entities:**
- Application, ApplicationOtpSetting, ApplicationTokenSetting (security config)
- Lov, LovLevel1, LovLevel2 (hierarchical list of values)
- All entities with proper constraints, defaults, and relationships

### 11.3 AUTOMAPPER PROFILE (Shared Services ONLY)

**Location:** `Shared Services/SharedService/AutoMapping/<Entity>Mapping.cs`

```csharp
public class EntityMapping : Profile {
    public EntityMapping() {
        // Simple mapping
        CreateMap<EntityModel, EntityDTO>()
            .ForMember(d => d.Id, o => o.MapFrom(s => s.EntityId))
            .ForMember(d => d.Name, o => o.MapFrom(s => s.EntityName ?? ""));
        
        // Nested/hierarchical mapping (when entity has child collections)
        CreateMap<ParentModel, ParentDTO>()
            .ForMember(d => d.Id, o => o.MapFrom(s => s.Id))
            .ForMember(d => d.ChildItems, o => o.MapFrom(s => s.ChildEntities));
    }
}
```

**Key Pattern:**
- One Profile class per entity or entity group
- Maps EF Core entities ‚Üí DTOs (one direction only, never reverse for database operations)
- Handles null coalescing with `?? ""` for nullable properties
- Supports nested/hierarchical mappings for related entities
- Use `.ForMember()` when property names differ between source and destination

### 11.4 KEYVAULT READER (Shared Services)

**Location:** `Shared Services/SharedService/Helper/KeyVaultReader.cs`

```csharp
public class KeyVaultReader {
    private readonly SecretClient _secretClient;
    private readonly KeyVaultConfigs _kvConfigs;
    private readonly ILogger<KeyVaultReader> _logger;
    public KeyVaultReader(IOptions<KeyVaultConfigs> options, ILogger<KeyVaultReader> logger) {
        _logger = logger; _kvConfigs = options.Value; _kvConfigs.validate();
        _secretClient = new SecretClient(new Uri(_kvConfigs.Url), new DefaultAzureCredential());
    }
    public async Task<KeyVaultResponse> GetSecretAsync(string secretName) {
        _logger.Info($"Fetching secret: {secretName} from Key Vault started.");
        KeyVaultResponse kvResponse = new KeyVaultResponse { IsSuccess = false };
        string cleanedSecretName = secretName.RemoveAllWhitespace().ToLowerInvariant();
        KeyVaultSecret secret = await _secretClient.GetSecretAsync(cleanedSecretName);
        if (secret != null && secret.Value != null) {
            kvResponse = new KeyVaultResponse { IsSuccess = true, Secret = secret.Value };
            _logger.Info($"Fetching secret: {secretName} from Key Vault completed.");
            return kvResponse;
        }
        _logger.Info($"Fetching secret: {secretName} from Key Vault couldn't succeed.");
        return kvResponse;
    }
}
```

**Usage:**
- Fetch database connection string: `await kvReader.GetSecretAsync(KeyVaultConfigs.DB_CONNECTION_STRING)`
- Secret names automatically cleaned (whitespace removed, lowercase)
- Returns `KeyVaultResponse` with `IsSuccess` flag and `Secret` value

### 11.5 DATABASE CONNECTION STRING PROVIDER (Shared Services ONLY)

**Location:** `Shared Services/SharedService/Helper/DatabaseConnectionStringProvider.cs`

```csharp
public class DatabaseConnectionStringProvider {
    public string ConnectionString { get; set; } = string.Empty;
}
```

**Usage in Program.cs:**
```csharp
var dbConnProvider = new DatabaseConnectionStringProvider();
var kvResponse = await builder.Services.BuildServiceProvider().GetRequiredService<KeyVaultReader>().GetSecretAsync(KeyVaultConfigs.DB_CONNECTION_STRING);
if (kvResponse.IsSuccess) dbConnProvider.ConnectionString = kvResponse.Secret;
builder.Services.AddDbContext<AppDbContext>(o => o.UseSqlServer(dbConnProvider.ConnectionString));
```

### 11.6 CACHE + DB HYBRID OPERATIONS (Central Data Layer Pattern)

```csharp
public async Task<BaseResponseDTO> ProcessData(DataReqDTO req) {
    var cfg = await _cfgRepo.GetAsync(x => x.Id == Convert.ToInt32(req.Headers["id"]));
    if (cfg == null) throw new HttpBaseServerException(...);
    var key = CacheKey.CreateCacheKey(req.GetCacheKey(), _namespace: "data", _cacheKeySettings: new CacheKeySettings { TimeToLive = TimeSpan.FromMinutes(cfg.TTL) });
    var cached = await key.GetAsync<DataEntity>();
    if (cached != null) { if (cached.IsExpired()) throw new BusinessCaseFailureException(...); if (cached.ExpiresAt > DateTimeOffset.UtcNow) throw new BusinessCaseFailureException(...); }
    var entity = GenerateEntity(out string code, req, cfg);
    await key.SetAsync(entity);
    return new BaseResponseDTO("Success", "", new DataResDTO { Id = entity.Id });
}
```

### 11.7 KEY DIFFERENCES FROM STANDARD PROCESS LAYER

| Component | Standard Process Layer | Shared Services (Central Data Layer) |
|-----------|------------------------|-------------------------------------|
| Repositories/ | ‚ùå NEVER exists | ‚úÖ Generic Repository<T> + specific repositories |
| Models/ | ‚ùå NEVER exists | ‚úÖ EF Core entities (Application, Lov, Settings) |
| AutoMapping/ | ‚ùå NEVER exists | ‚úÖ AutoMapper profiles (Entity‚ÜíDTO) |
| DbContext | ‚ùå NEVER used | ‚úÖ AppDbContext with full entity configurations |
| Internal DB Access | ‚ùå MUST call Shared Services Azure Functions | ‚úÖ Direct via Repository<T> + EF Core |
| 3rd Party DB Access | ‚ùå MUST call Shared Services Azure Functions | ‚úÖ Create Azure Function to connect |
| Domains | ‚úÖ IDomain<T> with business logic | ‚úÖ Simple POCOs (e.g., OTP with IsLockout()) |
| KeyVault | ‚ùå Not used | ‚úÖ KeyVaultReader for secrets (connection strings) |
| Flyway | ‚ùå Not used | ‚úÖ CI/CD pipeline migrations for internal DB |
| Purpose | Business logic orchestration | ALL database operations (internal + external) + common services (OTP, Token, LOV, Cache) |
| Location | Multiple repos (AGFS, Facilities, HR) | Single repo: `Shared Services/SharedService/` |

---

## 12. CONFIG MODELS RULES

**üö® CRITICAL:** AppConfigs centralize all configuration values.

### 11.1 APPCONFIGS STRUCTURE

```csharp
public class AppConfigs {
    public static string SectionName = "AppVariables";
    public string ASPNETCORE_ENVIRONMENT { get; set; }
    public string CreateEntityUrl { get; set; }  // System Layer URLs
    public string UpdateEntityUrl { get; set; }
    public string AuthProcessLayerUrl { get; set; }  // Process Layer URLs
    public string OrganizationUnit { get; set; }  // Business context
    public string BusinessUnit { get; set; }
    public ConnectionStrings ConnectionStrings { get; set; }
    public ExternalConfiguration ExternalConfig { get; set; }  // Nested configs
    public Dictionary<string, List<string>> StatusMap { get; set; } = new(StringComparer.OrdinalIgnoreCase);
    public Dictionary<string, string> ApiKeys { get; set; }
}

public class ExternalConfiguration {
    public string Provider { get; set; } = string.Empty;
    public string Template { get; set; } = string.Empty;
    public Dictionary<string, string> Headers { get; set; } = new();
    public Dictionary<string, string> Links { get; set; } = new();
}
```

### 11.2 CENTRAL DATA LAYER CONFIGS

```csharp
public class AppConfigs { public static string SectionName = "AppVariables"; public string? ASPNETCORE_ENVIRONMENT { get; set; } public string? ExternalUrl { get; set; } public string Separator { get; set; } = "|@#$|"; }
public class JwtOptions { public static string SectionName = "JwtOptions"; public string Issuer { get; set; } = string.Empty; }
public class KeyVaultConfigs { public static string SectionName = "KeyVaultConfigs"; public const string DB_CONNECTION_STRING = "db-connection-string"; public string Url { get; set; } = string.Empty; public void validate() { if (string.IsNullOrWhiteSpace(Url)) throw new ArgumentNullException(nameof(Url)); } }
```

### 11.3 CONFIGURATION LOADING

```csharp
// Program.cs
var configs = builder.Configuration.GetSection(AppConfigs.SectionName).Get<AppConfigs>();
builder.Services.Configure<AppConfigs>(builder.Configuration.GetSection(AppConfigs.SectionName));
builder.Services.Configure<JwtOptions>(builder.Configuration.GetSection(JwtOptions.SectionName));
```

### 11.4 CACHE SETTINGS (TTL CONFIGURATION)

```json
{
  "CacheSettings": {
    "DefaultTTL": 15,
    "TTLsInMinutes": {
      "GetEntityDetails": 120,
      "GetDataInfo": 120,
      "GetLookupValues": 1440,
      "GetReferenceData": 120
        }
    }
}
```

```csharp
public class CacheSettings {
    public int DefaultTTL { get; set; } = 15;
    public Dictionary<string, int> TTLsInMinutes { get; set; } = new();
    public int GetTTLForMethod(string methodName) {
        if (TTLsInMinutes != null && TTLsInMinutes.TryGetValue(methodName, out int ttl) && ttl > 0) return ttl;
        return DefaultTTL;
    }
}
```

### 11.5 ENVIRONMENT FILES

- `appsettings.json` - Default/fallback
- `appsettings.dev.json` - Development
- `appsettings.qa.json` - QA/Testing
- `appsettings.stg.json` - Staging (optional)
- `appsettings.prod.json` - Production
- `appsettings.dr.json` - Disaster Recovery (optional)

---

## 13. CONSTANTS RULES

**üö® CRITICAL:** Error constants use standardized tuple format.

### 12.1 ERROR CONSTANT FORMAT

```csharp
public static class ErrorConstants {
    public static readonly (string ErrorCode, string Message) ERROR_NAME =
        ("VEN_OPERAT_0001", "Human-readable error message");
}
```

### 12.2 ERROR CODE STRUCTURE

**Format:** `{VENDOR}_{OPERATION}_{NUMBER}`

- **VENDOR**: 3-character vendor/SOR identifier (e.g., SYS, EXT, API)
- **OPERATION**: 6-character operation identifier (e.g., GETENT, CRTREC, UPDDAT)
- **NUMBER**: 4-digit sequential number (0001, 0002, 0003, ...)

**Total Length:** 13 characters (3 + 1 + 6 + 1 + 4)

### 12.3 EXAMPLES

```csharp
public static readonly (string ErrorCode, string Message) GET_ENTITY_DETAILS_FAILURE =
    ("SYS_GETENT_0001", "Failure to get entity details");

public static readonly (string ErrorCode, string Message) CREATE_RECORD_FAILURE =
    ("EXT_CRTREC_0001", "Failed to create record");

public static readonly (string ErrorCode, string Message) UPDATE_DATA_FAILURE =
    ("API_UPDDAT_0001", "Failure to update data");
```

### 12.4 USAGE

```csharp
throw new BusinessCaseFailureException(ErrorConstants.GET_ENTITY_DETAILS_FAILURE, [ErrorConstants.GET_ENTITY_DETAILS_FAILURE.Message], stepName: "EntityService.cs / VerifyEntity");

// Accessing parts
string code = ErrorConstants.GET_ENTITY_DETAILS_FAILURE.ErrorCode;  // "SYS_GETENT_0001"
string msg = ErrorConstants.GET_ENTITY_DETAILS_FAILURE.Message;      // "Failure to get entity details"
```

---

## 14. ENUMS RULES

**üö® CRITICAL:** Enums use [StringValue] attribute for external values.

### 13.1 ENUM PATTERN

```csharp
public enum DataType {
    [StringValue("PRIMARY")]
    Primary,
    [StringValue("SECONDARY")]
    Secondary,
    [StringValue("TERTIARY")]
    Tertiary
}
```

### 13.2 ENUM EXTENSION

```csharp
public static class EnumExtensions {
    public static string GetStringValue(this Enum value) {
        var type = value.GetType();
        var fieldInfo = type.GetField(value.ToString());
        var attrs = fieldInfo.GetCustomAttributes(typeof(StringValueAttribute), false) as StringValueAttribute[];
        return attrs?.Length > 0 ? attrs[0].Value : value.ToString();
    }
}
```

### 13.3 USAGE

```csharp
string type = DataType.Primary.GetStringValue();  // Returns "PRIMARY"
```

---

## 15. EXTENSIONS RULES

**üö® CRITICAL:** Use Framework extensions; create project-specific only if needed.

### 14.1 FRAMEWORK EXTENSIONS (Mandatory Use)

```csharp
using Core.Extensions;
// LoggerExtensions - MANDATORY: _logger.Info("msg"), _logger.Error(ex, "msg"), _logger.Warn("msg"), _logger.Debug("msg")
// HttpResponseExtensions: string data = await response.ExtractDataAsync(); BaseResponseDTO baseRes = response.ExtractBaseResponse().Result;
// HttpRequestExtensions: var dto = await req.ReadBodyAsync<EntityReqDTO>();
// StringExtensions: string clean = value.RemoveAllWhitespace(); bool valid = email.IsValidEmail();
// DictionaryExtensions: int val = dict.ToIntValue(nameof(dto.Id)); string str = dict.ToStringValue(nameof(dto.Name)); DateTime? dt = dict.ToDateTimeValue(nameof(dto.CreatedAt));
```

### 14.2 PROJECT-SPECIFIC EXTENSIONS (Optional)

```csharp
// Only create if domain-specific need
public static class CustomExtensions {
    public static string NormalizeValue(this string val) => val.RemoveAllWhitespace().ToLowerInvariant();
}
```

### 14.3 KEY RULES

| Extension | Source | Usage |
|-----------|--------|-------|
| LoggerExtensions | Framework Core | ‚úÖ MANDATORY - Never use ILogger directly |
| HttpResponseExtensions | Framework Core | ‚úÖ MANDATORY - ExtractDataAsync, ExtractBaseResponse |
| HttpRequestExtensions | Framework Core | ‚úÖ MANDATORY - ReadBodyAsync |
| StringExtensions | Framework Core | ‚úÖ Use framework version |
| DictionaryExtensions | Framework Core | ‚úÖ ResponseDTOHelper methods |
| Project Extensions | Project/Extensions/ | ‚ö†Ô∏è Only if domain-specific |

---

## 16. HELPER RULES

**üö® CRITICAL:** ResponseDTOHelper is mandatory; other helpers project-specific.

### 16.1 MANDATORY HELPERS

**ResponseDTOHelper.cs** - ALL Process Layers
```csharp
public static class ResponseDTOHelper {
    public static EntityResDTO PopulateEntity(string json, EntityResDTO dto) { /* JSON ‚Üí DTO mapping */ }
}
```

**Location:** `Helper/ResponseDTOHelper.cs`

**Purpose:** Standardized JSON‚ÜíDTO mapping for all System Layer and Process Layer responses.

### 16.2 ADDITIONAL HELPER CLASSES (Optional)

**Project-Specific Helpers:**
- Additional helper classes are optional and project-specific
- Location: `Helper/` folder
- Examples of common helper types:
  - **File/PDF Helpers:** PDF generation, file manipulation, document processing
  - **Converter Helpers:** Type conversion utilities, format transformers
  - **Error Message Helpers:** Error message formatting, localization helpers
  - **Email Template Helpers:** Reading embedded email templates (see Section 16.3)

**Pattern:**
```csharp
public static class CustomHelper {
    public static string ProcessData(string input) { /* Helper logic */ }
    public static T ConvertValue<T>(object value) { /* Conversion logic */ }
}
```

### 16.3 EMAIL TEMPLATE HELPERS

**Pattern:** Helper classes may read embedded email templates for email generation.

**Template Location:** `EmailTemplate/<TemplateName>.html`

**Template Configuration (.csproj):**
```xml
<ItemGroup>
  <EmbeddedResource Include="EmailTemplate\TemplateName.html" />
</ItemGroup>
```

**Helper Method Pattern:**
```csharp
public static class ResponseDTOHelper {
    public static string ReadEmailTemplate(string resourceName) {
        var assembly = Assembly.GetExecutingAssembly();
        using var stream = assembly.GetManifestResourceStream(resourceName);
        using var reader = new StreamReader(stream ?? throw new FileNotFoundException($"Template {resourceName} not found"));
        return reader.ReadToEnd();
    }
    
    // Usage
    string templateContent = ReadEmailTemplate("ProjectName.EmailTemplate.TemplateName.html");
}
```

**Key Rules:**
- Templates must be marked as `EmbeddedResource` in .csproj
- Resource name format: `<Namespace>.EmailTemplate.<FileName>.html`
- Helper methods should handle missing template errors gracefully

## 17. MIDDLEWARE RULES

**üö® CRITICAL:** Process Layer uses ONLY Framework middlewares.

### 16.1 MIDDLEWARE ORDER (NON-NEGOTIABLE)

```csharp
builder.ConfigureFunctionsWebApplication(app => {
    app.UseMiddleware<ExecutionTimingMiddleware>();    // 1. FIRST - timing
    app.UseMiddleware<ExceptionHandlerMiddleware>();   // 2. SECOND - exception handling
    // ‚ùå NO CustomAuthenticationMiddleware - System Layer concept
});
```

### 16.2 WHY THIS ORDER

1. **ExecutionTimingMiddleware** - Wraps all, measures total time
2. **ExceptionHandlerMiddleware** - Catches exceptions, normalizes to BaseResponseDTO

### 16.3 KEY RULES

| Middleware | Source | Purpose | Order |
|------------|--------|---------|-------|
| ExecutionTimingMiddleware | Framework | Performance tracking | 1 (FIRST) |
| ExceptionHandlerMiddleware | Framework | Error normalization | 2 (SECOND) |
| CustomAuthenticationMiddleware | ‚ùå NOT IN PROCESS LAYER | System Layer only | N/A |

---

## 18. PROGRAM.CS RULES

**üö® CRITICAL PRINCIPLES:**
1. **DI registration order is mandatory**
2. **System/Process Abstractions: ALWAYS register and inject via interface**
   - ‚úÖ `builder.Services.AddScoped<IEntityMgmt, EntityMgmtSys>()`
   - ‚ùå `builder.Services.AddScoped<EntityMgmtSys>()`
   - ‚úÖ `private readonly IEntityMgmt _entityMgmt`
   - ‚ùå `private readonly EntityMgmtSys _entityMgmt`
3. **Services: Can be registered with or without interface**
   - ‚úÖ `builder.Services.AddScoped<EntityService>()` (direct injection)
   - ‚úÖ `builder.Services.AddScoped<IEntityService, EntityService>()` (with interface)
   - ‚úÖ `private readonly EntityService _service` (direct injection)
   - ‚úÖ `private readonly IEntityService _service` (interface injection)
4. **CALL FLOW MANDATORY PATTERN:**
   - Functions ‚Üí Service (inject directly OR via interface)
   - Service ‚Üí System Abstraction (via interface: `IEntityMgmt`) OR Process Abstraction (via interface: `IEntityProc`)
   - System/Process Abstraction ‚Üí System Layer OR Process Layer (HTTP calls)

### 17.1 REGISTRATION ORDER (Standard Process Layer)

```csharp
var builder = FunctionsApplication.CreateBuilder(args);

// 1. HTTP Client (FIRST)
builder.Services.AddHttpClient<CustomHTTPClient>();

// 2. Environment & Configuration Loading
var environment = Environment.GetEnvironmentVariable("ENVIRONMENT") ?? Environment.GetEnvironmentVariable("ASPNETCORE_ENVIRONMENT") ?? "dev";
builder.Configuration.AddJsonFile("appsettings.json", optional: true, reloadOnChange: true)
    .AddJsonFile($"appsettings.{environment}.json", optional: true, reloadOnChange: true).AddEnvironmentVariables();

// 3. Application Insights & Logging
builder.Services.AddApplicationInsightsTelemetryWorkerService().ConfigureFunctionsApplicationInsights();
builder.Logging.AddConsole();
builder.Logging.AddFilter<ApplicationInsightsLoggerProvider>("", LogLevel.Information);

// 4. Configuration Binding
builder.Services.Configure<AppConfigs>(builder.Configuration.GetSection(AppConfigs.SectionName));

// 5. Domains - NOT registered (no constructor dependencies, simple POCOs)
// Domains are instantiated directly: var domain = new EntityDomain();

// 6. Redis Caching
builder.Services.AddRedisCacheLibrary(builder.Configuration);

// 7. System Abstractions (AddScoped OR AddCachedService for caching)
// ‚úÖ ALWAYS register with interface
builder.Services.AddScoped<IEntityMgmt, EntityMgmtSys>();  // Without caching
builder.Services.AddCachedService<IDataMgmt, DataMgmtSys>();  // With caching

// 8. Process Abstractions (AddScoped)
// ‚úÖ ALWAYS register with interface
builder.Services.AddScoped<IAuthProc, AuthProc>();

// 9. Services (AddScoped OR AddTransient)
// ‚úÖ Can register with or without interface
builder.Services.AddScoped<EntityService>();  // Direct injection (no interface)
// OR
builder.Services.AddScoped<IEntityService, EntityService>();  // With interface (if interface exists)
builder.Services.AddTransient<DataService>();

// 10. CustomHTTPClient (AddScoped - Framework/Core/Core/Middlewares/CustomHTTPClient.cs)
builder.Services.AddScoped<CustomHTTPClient>();  // HTTP client with hardcoded 50s timeout

// 11. Polly Policies (Singleton)
builder.Services.AddSingleton<IAsyncPolicy<HttpResponseMessage>>(sp => {
    var config = sp.GetRequiredService<IConfiguration>();
    var retryPolicy = Policy.Handle<HttpRequestException>().OrResult<HttpResponseMessage>(r => (int)r.StatusCode >= 500)
        .WaitAndRetryAsync(retryCount: config.GetValue<int>("HttpClientPolicy:RetryCount"), 
            sleepDurationProvider: retryAttempt => TimeSpan.FromSeconds(retryAttempt * 5));
    var timeoutPolicy = Policy.TimeoutAsync<HttpResponseMessage>(config.GetValue<int>("HttpClientPolicy:TimeoutSeconds"));
    return Policy.WrapAsync(retryPolicy, timeoutPolicy);
});

// 12. Configure Functions Web Application
builder.ConfigureFunctionsWebApplication();

// 13. Middleware Registration (STRICT ORDER)
builder.UseMiddleware<ExecutionTimingMiddleware>();
builder.UseMiddleware<ExceptionHandlerMiddleware>();

// 14. ServiceLocator (For nested domain object resolution)
ServiceLocator.ServiceProvider = builder.Services.BuildServiceProvider();

builder.Build().Run();
```

### 17.2 CENTRAL DATA LAYER REGISTRATION

```csharp
// 1-4: Same as standard (HTTP Client, Environment, App Insights, Configuration)

// 5. Configuration Binding (Multiple configs)
builder.Services.Configure<AppConfigs>(builder.Configuration.GetSection(AppConfigs.SectionName));
builder.Services.Configure<JwtOptions>(builder.Configuration.GetSection(JwtOptions.SectionName));
builder.Services.AddOptions<KeyVaultConfigs>().Bind(builder.Configuration.GetSection(KeyVaultConfigs.SectionName));

// 6. NO Domains registration (POCOs)

// 7. System Abstractions
builder.Services.AddScoped<IExternalMgmt, ExternalMgmtSys>();

// 8. Services
builder.Services.AddScoped<ISecurityService, SecurityService>();
builder.Services.AddScoped<IAuthService, AuthService>();
builder.Services.AddScoped<IReferenceService, ReferenceService>();

// 9. Repositories
builder.Services.AddScoped<ISecuritySettingsRepository, SecuritySettingsRepository>();
builder.Services.AddScoped<IAuthSettingsRepository, AuthSettingsRepository>();
builder.Services.AddScoped<IReferenceDataRepository, ReferenceDataRepository>();

// 10. AutoMapper (with configuration)
builder.Services.AddAutoMapper(cfg => { cfg.AllowNullCollections = false; }, typeof(EntityMapping).Assembly);

// 11. CustomHTTPClient
builder.Services.AddScoped<CustomHTTPClient>();

// 12. KeyVault (Singleton)
builder.Services.AddSingleton<KeyVaultReader>();
builder.Services.AddSingleton<DatabaseConnectionStringProvider>();

// 13. DbContext (with KeyVault secret retrieval)
builder.Services.AddDbContext<AppDbContext>((serviceProvider, options) => {
    var connProvider = serviceProvider.GetRequiredService<DatabaseConnectionStringProvider>();
    if (string.IsNullOrWhiteSpace(connProvider.ConnectionString)) {
        var kvReader = serviceProvider.GetRequiredService<KeyVaultReader>();
        var secret = kvReader.GetSecretAsync(KeyVaultConfigs.DB_CONNECTION_STRING_KEY).GetAwaiter().GetResult();
        if (!secret.IsSuccess) throw new Exception("Failed to get DB connection string from Key Vault");
        connProvider.ConnectionString = secret.Secret;
    }
    options.UseSqlServer(connProvider.ConnectionString);
});

// 14. Redis Caching
builder.Services.AddRedisCacheLibrary(builder.Configuration);

// 15. Polly Policies (same as standard)
// 16. ConfigureFunctionsWebApplication(), Middleware, ServiceLocator, Build().Run()
```

### 17.3 CRITICAL PATTERNS EXPLAINED

**üö® IMPORTANT:** These patterns are documented with precise implementation details. Follow these patterns EXACTLY as shown.

**A. Environment Variable Loading:**
```csharp
var environment = Environment.GetEnvironmentVariable("ENVIRONMENT") ?? Environment.GetEnvironmentVariable("ASPNETCORE_ENVIRONMENT") ?? "dev";
```
**Purpose:** Prioritizes ENVIRONMENT, falls back to ASPNETCORE_ENVIRONMENT, defaults to "dev"

**B. AddCachedService (Extension Method from Framework/Cache):**
```csharp
builder.Services.AddCachedService<IEntityMgmt, EntityMgmtSys>();  // With caching interceptor
builder.Services.AddScoped<IEntityMgmt, EntityMgmtSys>();  // Without caching
```
**Source:** Framework/Cache/Extensions/CachingExtensions.cs  
**Purpose:** Extension method that registers service with Castle DynamicProxy caching interceptor for methods decorated with `[CacheableService]` attribute  
**How It Works:** 
1. Creates instance of implementation (e.g., EntityMgmtSys)
2. Wraps it with CachingInterceptor (uses Castle DynamicProxy)
3. Intercepts methods with `[CacheableService]` attribute
4. Caches `HttpResponseSnapshot` results based on ICacheable domain's cache key
5. Returns cached response for subsequent calls with same cache key

**C. Domain Instantiation (NOT Registered in DI):**
```csharp
// ‚ùå WRONG - Do NOT register domains in DI
builder.Services.AddTransient<EntityDomain>();
builder.Services.AddScoped<EntityDomain>();

// ‚úÖ CORRECT - Instantiate directly when needed
var domain = new EntityDomain();
dto.Populate(domain);
```
**Rule:** Domains are NOT registered in DI because they have NO constructor dependencies. They are simple POCOs instantiated directly.

**D. ServiceLocator Pattern:**
```csharp
ServiceLocator.ServiceProvider = builder.Services.BuildServiceProvider();
```
**Purpose:** Enables nested domain object resolution in DTO.Populate() methods using ServiceLocator.ServiceProvider.GetService<T>()

**E. Polly Retry/Timeout Policies (OPTIONAL - Default: NO Retries):**
```csharp
builder.Services.AddSingleton<IAsyncPolicy<HttpResponseMessage>>(sp => {
    var config = sp.GetRequiredService<IConfiguration>();
    var retryPolicy = Policy.Handle<HttpRequestException>().OrResult<HttpResponseMessage>(r => (int)r.StatusCode >= 500)
        .WaitAndRetryAsync(retryCount: config.GetValue<int>("HttpClientPolicy:RetryCount"), 
            sleepDurationProvider: retryAttempt => TimeSpan.FromSeconds(retryAttempt * 5));
    var timeoutPolicy = Policy.TimeoutAsync<HttpResponseMessage>(config.GetValue<int>("HttpClientPolicy:TimeoutSeconds"));
    return Policy.WrapAsync(retryPolicy, timeoutPolicy);
});
```
**‚ö†Ô∏è CRITICAL DEFAULTS:** 
- **RetryCount:** 0 (NO retries by default - set explicitly if retries needed)
- **TimeoutSeconds (HTTP Client):** 50 seconds - **HARDCODED** in `Framework/Core/Core/Middlewares/CustomHTTPClient.cs` line 21:
  ```csharp
  _httpClient.Timeout = TimeSpan.FromSeconds(50);
  ```
- **TimeoutSeconds (Polly Policy):** Configured in appsettings.json (typically 60 seconds)
- **IMPORTANT:** HTTP client timeout (50s) and Polly timeout (60s) are SEPARATE layers - Polly wraps the HTTP client
- **Only add HttpClientPolicy config** in appsettings.json if you need retries or different Polly timeout

**Configuration (appsettings.json):**
```json
{
  "HttpClientPolicy": {
    "RetryCount": 0,
    "TimeoutSeconds": 60
  }
}
```
**Note:** 
- HttpClientPolicy config is typically present in appsettings with RetryCount: 0
- Only increase RetryCount if specifically required for the integration
- TimeoutSeconds in config is for Polly policy timeout (separate from CustomHTTPClient's hardcoded 50s timeout)

**Reference:** See `Framework/Core/Core/Middlewares/CustomHTTPClient.cs` for HTTP client implementation details

### 17.4 KEY RULES

| Order | Component | Lifetime | Standard | Central Data Layer |
|-------|-----------|----------|----------|-----------------|
| 1 | HTTP Client | N/A | ‚úÖ AddHttpClient | ‚úÖ AddHttpClient |
| 2 | Environment & Config Loading | N/A | ‚úÖ | ‚úÖ |
| 3 | Application Insights | N/A | ‚úÖ | ‚úÖ |
| 4 | Configuration Binding | N/A | ‚úÖ Configure<AppConfigs> | ‚úÖ Multiple Configure |
| 5 | Domains | Transient | ‚úÖ | ‚ùå |
| 6 | Redis | N/A | ‚úÖ AddRedisCacheLibrary | ‚úÖ (after KeyVault) |
| 7 | SystemAbstractions | Scoped/Cached | ‚úÖ AddScoped/AddCachedService | ‚úÖ AddScoped |
| 8 | ProcessAbstractions | Scoped | ‚ö†Ô∏è Optional | ‚ö†Ô∏è Optional |
| 9 | Services | Scoped/Transient | ‚ö†Ô∏è Optional | ‚úÖ |
| 10 | CustomHTTPClient | Scoped | ‚úÖ | ‚úÖ |
| 11 | Polly Policies | Singleton | ‚úÖ | ‚úÖ |
| 12 | Repositories | Scoped | ‚ùå | ‚úÖ |
| 13 | AutoMapper | Singleton | ‚ùå | ‚úÖ |
| 14 | KeyVault | Singleton | ‚ùå | ‚úÖ |
| 15 | DbContext | Scoped | ‚ùå | ‚úÖ |
| 16 | ConfigureFunctionsWebApplication | N/A | ‚úÖ | ‚úÖ |
| 17 | Middleware Registration | N/A | ‚úÖ (2 only) | ‚úÖ (2 only) |
| 18 | ServiceLocator | N/A | ‚úÖ | ‚úÖ |

---

## 19. HOST.JSON RULES

**üö® CRITICAL:** Azure Functions host runtime configuration.

### 19.1 STANDARD TEMPLATE (MANDATORY)

```json
{"version": "2.0", "logging": {"fileLoggingMode": "always", "applicationInsights": {"samplingSettings": {"isEnabled": true}, "enableLiveMetricsFilters": true}}}
```

### 19.2 CONFIGURATION BREAKDOWN

| Setting | Value | Purpose |
|---------|-------|---------|
| version | `"2.0"` | .NET 8 Isolated Worker Model (MANDATORY) |
| fileLoggingMode | `"always"` | Log to file system (debugging) |
| isEnabled | `true` | Enable sampling for Application Insights |
| enableLiveMetricsFilters | `true` | Real-time metrics in Azure Portal |

### 19.3 KEY RULES

**‚úÖ DO:** Same host.json for ALL environments (dev/qa/prod), Enable live metrics filters, File must be Content + Copy to Output Directory

**‚ùå DON'T:** Add app configs (use appsettings.json), Create host.dev.json or host.prod.json, Add retry policies (use Polly in Program.cs)

### 19.4 FILE LOCATION

```
<ProjectRoot>/
‚îú‚îÄ‚îÄ Program.cs, host.json, appsettings.json  ‚Üê Same level
```

---

## 20. EXCEPTION HANDLING RULES

**üö® CRITICAL:** Use layer-appropriate exceptions.

### 20.1 EXCEPTION HIERARCHY

```
Process Layer Exceptions
‚îú‚îÄ‚îÄ BusinessCaseFailureException      // Business rule violations
‚îú‚îÄ‚îÄ PassThroughHttpException          // Propagate downstream errors
‚îî‚îÄ‚îÄ RequestValidationFailureException // DTO validation failures

Core Exceptions
‚îú‚îÄ‚îÄ NoRequestBodyException            // Missing request body
‚îî‚îÄ‚îÄ HttpBaseServerException           // Server errors (central data layer)
```

### 20.2 USAGE BY LAYER

```csharp
// Function Layer
if (dto == null) throw new NoRequestBodyException(errorDetails: [...], stepName: "...");
if (!r.IsSuccessStatusCode) throw new PassThroughHttpException(r.ExtractBaseResponse(), r.StatusCode);
// DTO Layer
if (errors.Any()) throw new RequestValidationFailureException(errorDetails: errors, stepName: "...");
// Service Layer
if (data == null || !data.Any()) throw new BusinessCaseFailureException(ErrorConstants.ENTITY_NOT_FOUND, [ErrorConstants.ENTITY_NOT_FOUND.Message], stepName: "EntityService.cs / GetEntity");
// Central data layer
if (cfg == null) throw new HttpBaseServerException(ErrorConstants.CONFIG_NOT_FOUND.Message, ErrorConstants.CONFIG_NOT_FOUND.ErrorCode, HttpStatusCode.InternalServerError, [ErrorConstants.CONFIG_NOT_FOUND.Message], stepName: "DataService.cs / ProcessData");
```

### 20.3 KEY RULES

| Exception | Layer | Purpose | HTTP Status |
|-----------|-------|---------|-------------|
| NoRequestBodyException | Function | Missing body | 400 |
| RequestValidationFailureException | DTO | Validation | 400 |
| BusinessCaseFailureException | Service | Business rule | 400 |
| PassThroughHttpException | All | Propagate error | Preserved |
| HttpBaseServerException | Central data layer | Server error | 500 |

---

## 21. ARCHITECTURE INVARIANTS

**üö® CRITICAL:** These rules NEVER change.

### 21.1 LAYER BOUNDARIES

1. **Process Layer ‚Üí System Layer** ‚úÖ ALLOWED
2. **Process Layer ‚Üí Process Layer** ‚úÖ ALLOWED (via ProcessAbstractions)
3. **System Layer ‚Üí Process Layer** ‚ùå FORBIDDEN
4. **System Layer ‚Üí System Layer** ‚ùå FORBIDDEN
5. **Process Layer ‚Üí Downstream API** ‚ùå FORBIDDEN

### 21.2 CENTRAL DATA LAYER AS DATABASE GATEWAY

1. **Central data layer** - ONLY Process Layer with direct DB access
2. **All other Process Layers** - Database access via central data layer
3. **Flyway migrations** - Integrated in central data layer CI/CD

### 21.3 HEADER STANDARDIZATION

**Process‚ÜíSystem:**
```csharp
var h = new List<Tuple<string, string>> { RequestHeaders.TestRunId.Simplify(), RequestHeaders.RequestId.Simplify() };
```

**Process‚ÜíProcess:**
```csharp
var h = new List<Tuple<string, string>> { RequestHeaders.TestRunId.Simplify(), RequestHeaders.RequestId.Simplify() };
if (req.Headers != null) h.AddRange(req.Headers.Select(kvp => Tuple.Create(kvp.Key, kvp.Value)));
```

### 21.4 MIDDLEWARE RESTRICTIONS

1. **Process Layer** - ONLY ExecutionTiming + ExceptionHandler
2. **NO CustomAuthenticationMiddleware** - System Layer concept
3. **NO custom middlewares** - Use framework only

### 21.5 FOLDER NAMING

1. **DTOs/** for request/response data transfer objects
2. **SystemAbstractions/** for System Layer calls
3. **ProcessAbstractions/** for Process Layer calls
4. **Domains/** with IDomain<T> (except central data layer)

---

## 22. FRAMEWORK LIBRARY REFERENCES

All Process Layer projects depend on Framework libraries. Reference these exact paths when using Framework classes.

### 22.1 CORE FRAMEWORK (`Framework/Core`)

| Class/Component | Path | Purpose |
|----------------|------|---------|
| **CustomHTTPClient** | `Core/Middlewares/CustomHTTPClient.cs` | HTTP client with 50s timeout (line 21), Polly retry/timeout, header management |
| **ExecutionTimingMiddleware** | `Core/Middlewares/ExecutionTimingMiddleware.cs` | Request timing tracking |
| **ExceptionHandlerMiddleware** | `Core/Middlewares/ExceptionHandlerMiddleware.cs` | Centralized exception handling |
| **RequestContext** | `Core/SessionHandler/RequestContext.cs` | AsyncLocal session/token storage |
| **ServiceLocator** | `Core/DependencyInjection/ServiceLocator.cs` | Static service provider for nested resolution |
| **IConfigValidator** | `Core/DTOs/IConfigValidator.cs` | Configuration validation interface |
| **BaseResponseDTO** | `Core/DTOs/BaseResponseDTO.cs` | Standard response wrapper |
| **HttpResponseSnapshot** | `Core/DTOs/HttpResponseSnapshot.cs` | Cacheable HTTP response container |
| **CustomHttpClientExtensions** | `ProcessLayer/Extensions/CustomHttpClientExtensions.cs` | SendRequest extension methods |
| **StringValueAttribute** | `Core/Attributes/StringValueAttribute.cs` | Enum string value attribute |
| **EnumExtensions** | `Core/Extensions/EnumExtensions.cs` | GetStringValue() for enums |

### 22.2 CACHE FRAMEWORK (`Framework/Cache`)

| Class/Component | Path | Purpose |
|----------------|------|---------|
| **CachingExtensions** | `Extensions/CachingExtensions.cs` | AddCachedService extension method |
| **CachingInterceptor** | `Interceptor/CachingInterceptor.cs` | Castle DynamicProxy interceptor for caching |
| **RedisServiceCollectionExtensions** | `Extensions/RedisServiceCollectionExtensions.cs` | AddRedisCacheLibrary extension method |
| **CacheSettings** | `ConfigModels/CacheSettings.cs` | Cache configuration (DefaultTTL, TTLsInMinutes) |
| **CacheableService** | `Attributes/CacheableService.cs` | Attribute for cacheable methods |
| **ICacheable** | `Interfaces/ICacheable.cs` | Interface for cache key generation |

### 22.3 USAGE IN CODE

**Imports:**
```csharp
using Core.Middlewares;              // CustomHTTPClient, Middlewares
using Core.Extensions;               // EnumExtensions, etc.
using Core.DTOs;                     // BaseResponseDTO, HttpResponseSnapshot, IConfigValidator
using Core.ProcessLayer.Extensions; // SendRequest extension
using Cache.Extensions;              // AddCachedService, AddRedisCacheLibrary
using Cache.ConfigModels;            // CacheSettings
```

**DI Registration Examples:**
```csharp
builder.Services.AddScoped<CustomHTTPClient>();                          // From Core
builder.Services.AddRedisCacheLibrary(builder.Configuration);            // From Cache
builder.Services.AddCachedService<IEntityMgmt, EntityMgmtSys>();        // From Cache
builder.UseMiddleware<ExecutionTimingMiddleware>();                      // From Core
builder.UseMiddleware<ExceptionHandlerMiddleware>();                     // From Core
ServiceLocator.ServiceProvider = builder.Services.BuildServiceProvider(); // From Core
```

**Key Implementation Detail:**
- **CustomHTTPClient Timeout:** Hardcoded at line 21 of `Core/Middlewares/CustomHTTPClient.cs`:
  ```csharp
  _httpClient.Timeout = TimeSpan.FromSeconds(50);
  ```
- **AddCachedService:** Defined in `Cache/Extensions/CachingExtensions.cs`, uses Castle DynamicProxy to intercept methods with `[CacheableService]` attribute

---

**END OF PROCESS LAYER RULES**

**Status:** ‚úÖ Complete | **Lines:** 1,270 / 2,500 | **All Details Preserved + Framework References Added**

---