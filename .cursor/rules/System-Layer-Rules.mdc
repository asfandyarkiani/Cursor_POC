---
description: "Always apply. Non-negotiable System Layer rules for this repo."
alwaysApply: false
---

---
---

# üö® CRITICAL - READ THIS FIRST üö®

## üõë MANDATORY PRE-GENERATION VALIDATION (STOP IF NOT COMPLETE)

**üö® YOU CANNOT GENERATE ANY CODE UNTIL THIS VALIDATION IS COMPLETE:**

**STEP 1: Verify Phase Context**
- [ ] **STOP AND VERIFY:** Am I in Phase 2 (Code Generation)?
- [ ] **STOP AND VERIFY:** Have I completed Phase 1 (Extraction)?
- [ ] **STOP AND VERIFY:** Do I have Phase 1 document with Operations Inventory, DTOs, and Sequence Diagram?
- [ ] **IF ANY NO ‚Üí STOP ‚Üí Complete Phase 1 first**

**STEP 2: Verify Function Exposure Decision**
- [ ] **STOP AND VERIFY:** Have I created Function Exposure Decision table?
- [ ] **STOP AND VERIFY:** Does table show which operations become Functions vs Atomic Handlers?
- [ ] **IF NO ‚Üí STOP ‚Üí Create Function Exposure Decision table first (Boomi-Azure-Migration.md Step 1)**

**STEP 3: Verify System Layer Identification**
- [ ] **STOP AND VERIFY:** Have I identified all third-party systems (REST API, SOAP API, SMTP, FTP)?
- [ ] **STOP AND VERIFY:** Do I know which System Layer project to create/modify?
- [ ] **IF NO ‚Üí STOP ‚Üí Identify System Layers first (Boomi-Azure-Migration.md Step 0)**

**STEP 4: Load Correct Rulebook**
- [ ] **STOP AND VERIFY:** Am I generating System Layer code?
- [ ] **STOP AND VERIFY:** Am I reading System-Layer-Rules.md (this document)?
- [ ] **IF NO ‚Üí STOP ‚Üí Load correct rulebook (Process-Layer-Rules.md for Process Layer)**

**üõë IF ANY CHECKPOINT FAILS ‚Üí STOP ALL CODE GENERATION ‚Üí Complete missing step ‚Üí Then proceed**

---

## MANDATORY RULE BEFORE ANY IMPLEMENTATION:

**BEFORE creating ANY component (Function, Handler, AtomicHandler, DTO, Service, Extension, Helper, Enum, etc.), you MUST:**

1. ‚úÖ **READ the complete rules section** for that component type
2. ‚úÖ **VERIFY the correct folder location** (e.g., Extensions/ NOT Helpers/, AtomicHandlers/ FLAT NOT subfolders)
3. ‚úÖ **CHECK required interfaces** (IRequestSysDTO, IDownStreamRequestDTO, etc.)
4. ‚úÖ **CONFIRM naming conventions** (suffixes, PascalCase, file=class name)
5. ‚úÖ **VALIDATE mandatory patterns** (validation methods, static Map(), etc.)
6. ‚úÖ **üî¥ NON-NEGOTIABLE: Check Core Framework extensions first** - All simple conversion or helper functionality MUST first leverage existing Core Framework extension methods. Only create new extensions if Core Framework does not provide a suitable option. Applies to DTOs, Handlers, Atomic Handlers, Services, and all components.
7. ‚úÖ **üî¥ NON-NEGOTIABLE: Use descriptive variable names** - Variable names MUST clearly reflect what they are or what they are doing. Avoid ambiguous, generic, or unclear names. Names should be self-documenting and improve code readability.
8. ‚úÖ **üî¥ CRITICAL: ALWAYS use Framework extension methods for request handling** - Before implementing ANY deserialization or HTTP handling, search Framework/Core/Core/Extensions/ for existing extension methods. The framework provides `ReadBodyAsync<T>()` for BOTH `HttpRequest` (in-process) and `HttpRequestData` (isolated worker). ALWAYS use `await req.ReadBodyAsync<T>()` - NEVER manually use `ReadAsStringAsync()` + manual deserialization.

**‚ùå DO NOT:**
- ‚ùå Create components without reading rules first
- ‚ùå Guess folder locations
- ‚ùå Skip interface implementations
- ‚ùå Ignore naming conventions
- ‚ùå Use 'var' keyword (NEVER use 'var' - always declare explicit types)
- ‚ùå Use ambiguous or unclear variable names (üî¥ NON-NEGOTIABLE: Variable names must clearly reflect what they are or what they are doing)
- ‚ùå Manually deserialize requests with ReadAsStringAsync() when ReadBodyAsync<T>() extension exists

**‚ö†Ô∏è COMMON MISTAKES TO AVOID:**
- Creating Extensions in Helpers/ directory (WRONG - use Extensions/)
- Creating AtomicHandlers in subfolders (WRONG - FLAT structure)
- Missing IRequestSysDTO on *ReqDTO (WRONG - MANDATORY interface)
- Missing IDownStreamRequestDTO on *HandlerReqDTO (WRONG - MANDATORY interface)
- Services at root level (WRONG - must be in Implementations/<Vendor>/Services/)
- Using 'var' keyword (WRONG - NEVER use 'var', always use explicit types)
- **Using ambiguous or unclear variable names** (WRONG - üî¥ NON-NEGOTIABLE: Variable names must clearly reflect what they are or what they are doing. Examples: ‚ùå `data`, `result`, `item`, `temp` ‚Üí ‚úÖ `entityResponse`, `validationResult`, `entityItem`, `temporaryEntityId`)
- **Creating new extensions without checking Core Framework FIRST** (WRONG - üî¥ NON-NEGOTIABLE: Always check Core Framework extensions before creating new ones)
- **Wrong host.json format** (WRONG - Use EXACT template from Section 19.1, NO extensionBundle, NO maxTelemetryItemsPerSecond)
- **Wrong error constant format** (WRONG - System Layer: AAA_AAAAAA_DDDD where AAA = 3 chars, AAAAAA = 6 chars, DDDD = 4 digits)

**üìñ IMPLEMENTATION WORKFLOW:**
```
Step 1: Identify component type (Function? Handler? DTO? Extension?)
Step 2: Navigate to relevant rules section below
Step 3: Read ALL rules for that component
Step 4: Create component following ALL rules exactly
Step 5: Verify against checklist in rules section
```

## üî¥ NON-NEGOTIABLE: VARIABLE NAMING RULES

**CRITICAL RULE:** Variable names MUST clearly reflect what they are or what they are doing. This applies to ALL variables in ALL components (DTOs, Handlers, Atomic Handlers, Services, Functions, Extensions, Helpers, etc.).

### ‚úÖ CORRECT Variable Naming
- **Descriptive and specific:** `entityDetailResponse`, `validationErrorList`, `authenticationToken`, `downstreamApiResponse`
- **Reflects purpose:** `existingEntityData`, `lookupResult`, `createEntityRequest`, `mappedResponseDto`
- **Clear intent:** `isEntityExists`, `shouldLinkRelatedEntity`, `hasValidationErrors`, `canRetryOperation`
- **Context-appropriate:** `entityIdFromRequest`, `sessionIdFromContext`, `errorDetailsFromValidation`

### ‚ùå WRONG Variable Naming
- **Too generic:** `data`, `result`, `item`, `temp`, `obj`, `value`, `response`, `request`
- **Ambiguous:** `x`, `y`, `i`, `j`, `count`, `flag`, `status`, `type`
- **Unclear purpose:** `thing`, `stuff`, `info`, `details`, `content`
- **Abbreviations without context:** `dto`, `dto2`, `resp`, `req`, `api`, `svc`

### Examples

**‚ùå WRONG:**
```csharp
var data = await GetEntity();
var result = ProcessData(data);
var item = result.Items.First();
if (item != null) { var temp = item.Value; }
```

**‚úÖ CORRECT:**
```csharp
GetEntityDetailApiResDTO entityDetailResponse = await GetEntityDetailFromDownstream(request);
BaseResponseDTO mappedResponse = ProcessEntityResponse(entityDetailResponse);
EntityDetailItem entityDetailItem = mappedResponse.Items.First();
if (entityDetailItem != null) { 
    string entityDetailValue = entityDetailItem.Value; 
}
```

**‚ùå WRONG:**
```csharp
var response = await _handler.Handle(request);
if (response.IsSuccess) { var data = response.Data; }
```

**‚úÖ CORRECT:**
```csharp
HttpResponseSnapshot downstreamApiResponse = await GetEntityDetailFromDownstream(request);
if (downstreamApiResponse.IsSuccessStatusCode) { 
    GetEntityDetailApiResDTO entityDetailApiResponse = RestApiHelper.DeserializeJsonResponse<GetEntityDetailApiResDTO>(downstreamApiResponse.Content!); 
}
```

**üî¥ ENFORCEMENT:** All variable names must be reviewed to ensure they clearly communicate their purpose. If a variable name requires a comment to explain what it is, the name needs to be improved.

---
---

# Folder Structure RULES
*ALL RULES CRITICAL & MANDATORY*

**üìö FRAMEWORK REFERENCE:** Review `Framework/Core` and `Framework/Cache` directories to understand framework-level implementation patterns, base classes, interfaces, and helper methods that these rules build upon.

**üö® BEFORE CREATING:** Read ALL rules in this section before creating any folders or components. Verify folder locations, structure patterns, and naming conventions.

## 1. COMPLETE STRUCTURE
```
<Project>/
‚îú‚îÄ‚îÄ Abstractions/                           # ROOT LEVEL - Interfaces (IEntityMgmt.cs, IRecordMgmt.cs)
‚îú‚îÄ‚îÄ Implementations/<VendorName>/           # VendorA, VendorB, SOR1, Example System
‚îÇ   ‚îú‚îÄ‚îÄ Services/                          # ‚ö†Ô∏è CRITICAL: INSIDE Implementations/<Vendor>/ NOT root
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ EntityMgmtService.cs, RecordMgmtService.cs
‚îÇ   ‚îú‚îÄ‚îÄ Handlers/                          # GetEntityDetailHandler.cs, CreateRecordHandler.cs
‚îÇ   ‚îî‚îÄ‚îÄ AtomicHandlers/                    # FLAT structure - NO subfolders
‚îÇ       ‚îú‚îÄ‚îÄ GetEntityDetailAtomicHandler.cs
‚îÇ       ‚îú‚îÄ‚îÄ CreateRecordAtomicHandler.cs
‚îÇ       ‚îú‚îÄ‚îÄ AuthenticateAtomicHandler.cs  # For middleware
‚îÇ       ‚îî‚îÄ‚îÄ LogoutAtomicHandler.cs
‚îú‚îÄ‚îÄ DTO/
‚îÇ   ‚îú‚îÄ‚îÄ GetEntityDetailDTO/                # Entity-related directory
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ GetEntityDetailReqDTO.cs
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ GetEntityDetailResDTO.cs
‚îÇ   ‚îú‚îÄ‚îÄ CreateRecordDTO/                   # Entity-related directory
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ CreateRecordReqDTO.cs
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ CreateRecordResDTO.cs
‚îÇ   ‚îú‚îÄ‚îÄ AtomicHandlerDTOs/                 # FLAT - GetEntityDetailHandlerReqDTO.cs, AuthenticationRequestDTO.cs
‚îÇ   ‚îî‚îÄ‚îÄ DownstreamDTOs/                    # ALL *ApiResDTO here (GetEntityDetailApiResDTO.cs, CreateRecordApiResDTO.cs, AuthenticationResponseDTO.cs)
‚îÇ       ‚îî‚îÄ‚îÄ Common/                        # Shared nested objects (ContactInfo.cs, LocationInfo.cs) # optional
‚îú‚îÄ‚îÄ Functions/                             # FLAT structure - GetEntityDetailAPI.cs, CreateRecordAPI.cs
‚îú‚îÄ‚îÄ ConfigModels/                          # AppConfigs.cs, KeyVaultConfigs.cs
‚îú‚îÄ‚îÄ Constants/                             # ErrorConstants.cs, InfoConstants.cs
‚îú‚îÄ‚îÄ Enums/                                 # EntityStatus.cs, TaskPriority.cs
‚îú‚îÄ‚îÄ Extensions/                            # OPTIONAL - domain-specific only (CustomExtensions.cs)
‚îú‚îÄ‚îÄ Helpers/                               # SOAPHelper.cs (SOAP mandatory), KeyVaultReader.cs (KeyVault mandatory), RequestContext.cs (auth mandatory)
‚îú‚îÄ‚îÄ Attributes/                            # OPTIONAL - CustomAuthenticationAttribute.cs (only if token/session auth with middleware)
‚îú‚îÄ‚îÄ Middleware/                            # OPTIONAL - CustomAuthenticationMiddleware.cs (only if token/session auth)
‚îú‚îÄ‚îÄ SoapEnvelopes/                         # OPTIONAL - CreateTask.xml, Authenticate.xml (only if SOAP, register as EmbeddedResource in .csproj)
‚îú‚îÄ‚îÄ Program.cs, host.json, <Project>.csproj, <Project>.sln
‚îú‚îÄ‚îÄ appsettings.json, appsettings.dev.json, appsettings.qa.json, appsettings.stg.json (optional), appsettings.prod.json, appsettings.dr.json (optional)
```

## 2. CRITICAL PLACEMENT RULES (P0 - MOST COMMON MISTAKES)

### 2.1 Services Location
- ‚úÖ **CORRECT:** `Implementations/<VendorName>/Services/` | ‚ùå **WRONG:** `Services/` at root
- **Impact:** Namespace=`<Namespace>.Implementations.<Vendor>.Services`, DI registration, architecture organization
- **100% of implementations follow this pattern**

### 2.2 ApiResDTO Placement
- ‚úÖ **ALL *ApiResDTO in `DTO/DownstreamDTOs/`** | ‚ùå **NEVER in entity DTO directories or AtomicHandlerDTOs/**
- **Rationale:** Entity DTO directories=API-level communication | DownstreamDTOs=external API responses | Clear separation

### 2.3 AtomicHandler Structure
- **MANDATORY:** FLAT structure - all AtomicHandlers directly in AtomicHandlers/ folder | ‚ùå NO subfolders
- **Why:** Simpler organization, easier navigation

### 2.4 Functions Folder
- **MANDATORY:** FLAT structure | ‚ùå NO subfolders

## 3. DTO ORGANIZATION

| DTO Type | Pattern | Location | Purpose |
|----------|---------|----------|---------|
| API Request | `*ReqDTO` | `<Entity>DTO/` (directly under DTO/) | Incoming from Process Layer |
| API Response | `*ResDTO` | `<Entity>DTO/` (directly under DTO/) | Outgoing to Process Layer |
| Atomic Request | `*HandlerReqDTO` | `AtomicHandlerDTOs/` (FLAT) | To Atomic Handler |
| External Response | `*ApiResDTO` | `DownstreamDTOs/` (FLAT) | From external/downstream API |

**Entity DTO Directories:** Entity-related subfolders directly under DTO/ (GetEntityDetailDTO/, CreateRecordDTO/) | **AtomicHandlerDTOs:** FLAT, NO subfolders | **DownstreamDTOs:** FLAT + Common/ subfolder for shared nested objects

## 4. OPTIONAL FOLDERS (Conditional)

| Folder | Create When | Skip When | Contents |
|--------|-------------|-----------|----------|
| **Attributes/** | Token/session auth with middleware | Credentials-per-request or no custom auth | CustomAuthenticationAttribute.cs (vendor-specific naming: CRMAuthenticationAttribute.cs, PowerPlatformAuthenticationAttribute.cs) |
| **Middleware/** | Token/session auth | Credentials-per-request | CustomAuthenticationMiddleware.cs, RequestContext.cs |
| **SoapEnvelopes/** | SOAP integration | REST-only | *.xml (register as `<EmbeddedResource Include="SoapEnvelopes\*.xml" />` in .csproj) |
| **Extensions/** | Domain-specific extensions | General-purpose (use Core Framework) | StatusExtension.cs, TypeExtension.cs |

**Helpers Components:**
- `CustomSoapClient.cs`: ‚úÖ MANDATORY for SOAP (YOU MUST CREATE - NOT in Framework) | ‚ùå Skip for REST-only
- `SOAPHelper.cs`: ‚úÖ MANDATORY for SOAP | ‚ùå Skip for REST-only
- `RestApiHelper.cs`: OPTIONAL (Core Framework provides) | Most projects skip
- `XMLHelper.cs`: OPTIONAL (custom XML handling) | Most projects skip
- `KeyVaultReader.cs`: ‚úÖ MANDATORY if Azure KeyVault | ‚ùå Skip if no secrets
- `RequestContext.cs`: ‚úÖ MANDATORY if token/session auth | ‚ùå Skip for credentials-per-request

## 5. CONFIGURATION FILES

**MANDATORY:** appsettings.json, appsettings.dev.json, appsettings.qa.json, appsettings.prod.json, host.json, <Project>.csproj, <Project>.sln  
**OPTIONAL:** appsettings.stg.json, appsettings.dr.json  
**Environment Suffixes:** dev=Development | qa=QA/Testing | stg=Staging | prod=Production | dr=Disaster Recovery

## 6. NAMESPACE CONVENTIONS

| Folder | Namespace Pattern | Example |
|--------|------------------|---------|
| Abstractions | `<NS>.Abstractions` | `ProjectMgmtSystem.Abstractions` |
| Services | `<NS>.Implementations.<Vendor>.Services` | `ProjectMgmtSystem.Implementations.VendorName.Services` |
| Handlers | `<NS>.Implementations.<Vendor>.Handlers` | `ProjectMgmtSystem.Implementations.VendorName.Handlers` |
| AtomicHandlers | `<NS>.Implementations.<Vendor>.AtomicHandlers` | `ProjectMgmtSystem.Implementations.VendorName.AtomicHandlers` |
| Entity DTO Directories | `<NS>.DTO.<Entity>DTO` | `ProjectMgmtSystem.DTO.GetEntityDetailDTO` |
| AtomicHandlerDTOs | `<NS>.DTO.AtomicHandlerDTOs` | `ProjectMgmtSystem.DTO.AtomicHandlerDTOs` |
| DownstreamDTOs | `<NS>.DTO.DownstreamDTOs` | `ProjectMgmtSystem.DTO.DownstreamDTOs` |
| Common (DownstreamDTOs) | `<NS>.DTO.DownstreamDTOs.Common` | `ProjectMgmtSystem.DTO.DownstreamDTOs.Common` |
| Functions | `<NS>.Functions` | `ProjectMgmtSystem.Functions` |
| ConfigModels | `<NS>.ConfigModels` | `ProjectMgmtSystem.ConfigModels` |
| Constants | `<NS>.Constants` | `ProjectMgmtSystem.Constants` |
| Enums | `<NS>.Enums` | `ProjectMgmtSystem.Enums` |
| Helpers | `<NS>.Helper` | `ProjectMgmtSystem.Helper` |
| Attributes | `<NS>.Attributes` | `ProjectMgmtSystem.Attributes` |
| Middleware | `<NS>.Middleware` | `ProjectMgmtSystem.Middleware` |

**SoapEnvelopes:** No namespace (XML, embedded resources)

## 7. COMPONENT FLOW & FOLDER MAPPING

**Flow:** Function ‚Üí Service ‚Üí Handler ‚Üí Atomic Handler ‚Üí External API

| Component | Folder | File Pattern |
|-----------|--------|-------------|
| Function | `Functions/` | `<Feature>API.cs` |
| Service Interface | `Abstractions/` | `I<Domain>Mgmt.cs` |
| Service | `Implementations/<Vendor>/Services/` | `<Domain>MgmtService.cs` |
| Handler | `Implementations/<Vendor>/Handlers/` | `<Feature>Handler.cs` |
| Atomic Handler | `Implementations/<Vendor>/AtomicHandlers/` | `<Feature>AtomicHandler.cs` |

**Example:** GetEntityDetailAPI.cs (Functions/) ‚Üí IEntityMgmt (Abstractions/) ‚Üí EntityMgmtService.cs (Implementations/Example System/Services/) ‚Üí GetEntityDetailHandler.cs (Implementations/Example System/Handlers/) ‚Üí GetEntityDetailAtomicHandler.cs (Implementations/Example System/AtomicHandlers/) ‚Üí External API

## 8. VERIFICATION CHECKLIST
- [ ] Abstractions/ at ROOT (NOT in Implementations/)
- [ ] Services/ INSIDE Implementations/<Vendor>/ (NOT root)
- [ ] AtomicHandlers/ flat (NO subfolders)
- [ ] ALL *ApiResDTO in DownstreamDTOs/ (NOT in entity DTO directories)
- [ ] Entity DTO directories directly under DTO/ (NO HandlerDTOs/ intermediate folder)
- [ ] AtomicHandlerDTOs flat (NO subfolders)
- [ ] Functions/ flat (NO subfolders)
- [ ] Attributes/ only if token/session auth with middleware
- [ ] Middleware/ only if token/session auth
- [ ] SoapEnvelopes/ only if SOAP
- [ ] appsettings (base, dev, qa, prod) + host.json + .csproj + .sln present
- [ ] Namespaces match folder structure
- [ ] ConfigModels/, Constants/, Enums/, Helpers/ present

## 9. COMMON MISTAKES & FIXES

| Mistake | Impact | Fix |
|---------|--------|-----|
| Services/ at root | ‚ùå P0 - Architecture break | Move to Implementations/<Vendor>/Services/ |
| ApiResDTO in entity DTO directories | ‚ùå DTO organization break | Move to DownstreamDTOs/ |
| HandlerDTOs/ intermediate folder | ‚ùå Violates pattern | Remove - entity directories directly under DTO/ |
| AtomicHandlers with subfolders | ‚ùå Violates pattern | Flatten - all .cs files directly in AtomicHandlers/ |
| Functions/ with subfolders | ‚ùå Violates pattern | Flatten |
| Missing Abstractions/ at root | ‚ùå DI break | Create at root |
| Attribute in middleware file | ‚ùå Violates separation of concerns | Create Attributes/ folder, separate file |
| Missing Attributes/ when using middleware auth | ‚ùå Architecture break | Create Attributes/ folder with CustomAuthenticationAttribute |
| Middleware/ without auth | ‚ö†Ô∏è Unnecessary | Delete |
| Attributes/ without middleware | ‚ö†Ô∏è Unnecessary | Delete |
| SoapEnvelopes/ for REST-only | ‚ö†Ô∏è Unnecessary | Delete |
| String extensions in Extensions/ | ‚ö†Ô∏è Duplicates Core Framework | Use Core Framework |

## 10. KEY INVARIANTS
1. **Services ALWAYS Implementations/<Vendor>/Services/** - NEVER root
2. **Abstractions ALWAYS root** - NEVER Implementations/
3. **AtomicHandlers/ flat** - NEVER subfolders
4. **ALL *ApiResDTO DownstreamDTOs/** - NEVER in entity DTO directories
5. **Entity DTO directories directly under DTO/** - NO HandlerDTOs/ intermediate folder
6. **Functions/ flat** - NEVER subfolders
7. **Attributes/ conditional** - ONLY token/session auth with middleware (one attribute per file)
8. **Middleware/ conditional** - ONLY token/session auth
9. **SoapEnvelopes/ conditional** - ONLY SOAP (register EmbeddedResource)
10. **Extensions/ conditional** - ONLY domain-specific
11. **Namespaces match folder paths** - Must be consistent
12. **Config files mandatory** - appsettings.json, host.json, .csproj, .sln

---

# Middleware RULES
*ALL RULES CRITICAL & MANDATORY - NO EXCEPTIONS*

**üìö FRAMEWORK REFERENCE:** Review `Framework/Core` and `Framework/Cache` directories to understand framework-level implementation patterns, base classes, interfaces, and helper methods that these rules build upon.

**üö® BEFORE CREATING:** Read ALL rules in this section before creating middleware. Verify middleware order, authentication patterns, and RequestContext usage.

## 1. MIDDLEWARE TYPES & ORDER (NON-NEGOTIABLE)
```csharp
builder.UseMiddleware<ExecutionTimingMiddleware>();      // 1. FIRST - wraps all, tracks timing, initializes ResponseHeaders.DSTimeBreakDown
builder.UseMiddleware<ExceptionHandlerMiddleware>();     // 2. SECOND - catches/normalizes exceptions to BaseResponseDTO
builder.UseMiddleware<CustomAuthenticationMiddleware>(); // 3. THIRD - handles token/session auth lifecycle (optional)
```
**Flow:** Request ‚Üí Timing(start) ‚Üí Exception(try) ‚Üí Auth(login) ‚Üí Function ‚Üí Auth(logout-finally) ‚Üí Exception(normalize) ‚Üí Timing(log) ‚Üí Response  
**Why:** (1) Timing first=measures total time incl. exception+auth (2) Exception second=catches auth+function errors (3) Auth third=logout in finally executes even on failure

## 2. AUTHENTICATION APPROACHES

### Approach 1: Credentials-Per-Request (No Middleware)
**When:** API key/credentials with every request, no token lifecycle | **How:** `Dictionary<string, string> headers = new Dictionary<string, string> { { "X-API-Key", _appConfigs.ApiKey } };`

### Approach 2: Token/Session-Based (Middleware Required)
**When:** Separate auth endpoint, returns session/token with lifecycle | **Components:** AuthenticateAtomicHandler + LogoutAtomicHandler + CustomAuthenticationAttribute + CustomAuthenticationMiddleware + RequestContext

## 3. REQUESTCONTEXT (MANDATORY - AsyncLocal<T> Storage)
**Location:** `<ProjectRoot>/Middleware/RequestContext.cs` or `Helper/RequestContext.cs`
```csharp
public static class RequestContext {
    private static readonly AsyncLocal<string?> _sessionId = new(), _authToken = new();
    public static string? SessionId { get => _sessionId.Value; private set => _sessionId.Value = value; }
    public static string? Token { get => _authToken.Value; private set => _authToken.Value = value; }
    public static void SetSessionId(string s) => SessionId = s;
    public static string? GetSessionId() => SessionId;
    public static void SetToken(string t) => Token = t;
    public static string? GetToken() => Token;
    public static void Clear() { SessionId = null; Token = null; }
}
```
**Usage:** Middleware: `RequestContext.SetSessionId(sessionId);` | Functions: `string? sessionId = RequestContext.GetSessionId();` | Never use FunctionContext.Items

## 4. CUSTOM AUTH MIDDLEWARE COMPONENTS

### A. Authentication Attribute
```csharp
[AttributeUsage(AttributeTargets.Method, AllowMultiple = false)]
public class CustomAuthenticationAttribute : Attribute { }
```

### B. Authentication Atomic Handlers (Internal Only - Never Azure Functions)
```csharp
public class AuthenticateAtomicHandler : IAtomicHandler<HttpResponseSnapshot> { private readonly CustomRestClient _restClient; private readonly AppConfigs _appConfigs;
    public async Task<HttpResponseSnapshot> Handle(IDownStreamRequestDTO request) { AuthenticationRequestDTO? dto = request as AuthenticationRequestDTO; dto.ValidateDownStreamRequestParameters(); return await _restClient.ExecuteRestRequestAsync(url: _appConfigs.AuthUrl, httpMethod: HttpMethod.Post, bodyContent: JsonSerializer.Serialize(new { username = dto.Username, password = dto.Password })); } }
public class LogoutAtomicHandler : IAtomicHandler<HttpResponseSnapshot> { /* Similar */ }
```

### C. Middleware - Session-Based (with Logout in finally)
```csharp
public class CustomAuthenticationMiddleware : IFunctionsWorkerMiddleware { private readonly ILogger<CustomAuthenticationMiddleware> _logger; private readonly AppConfigs _appConfigs; private readonly AuthenticateAtomicHandler _authenticateAtomicHandler; private readonly LogoutAtomicHandler _logoutAtomicHandler;
    public CustomAuthenticationMiddleware(ILogger<CustomAuthenticationMiddleware> logger, IOptions<AppConfigs> options, AuthenticateAtomicHandler authenticateAtomicHandler, LogoutAtomicHandler logoutAtomicHandler) { _logger = logger; _appConfigs = options.Value; _authenticateAtomicHandler = authenticateAtomicHandler; _logoutAtomicHandler = logoutAtomicHandler; }
    public async Task Invoke(FunctionContext context, FunctionExecutionDelegate next) { if (!ShouldApplyAuthentication(context)) { await next(context); return; } string sessionId = string.Empty; try { AuthenticationRequestDTO request = new AuthenticationRequestDTO { Username = _appConfigs.Username ?? "", Password = _appConfigs.Password ?? "" }; HttpResponseSnapshot authResponse = await _authenticateAtomicHandler.Handle(request); if (!authResponse.IsSuccessStatusCode) throw new DownStreamApiFailureException(...); AuthenticationResponseDTO? authAPIRes = SOAPHelper.DeserializeSoapResponse<AuthenticationResponseDTO>(authResponse.Content!); sessionId = authAPIRes?.SessionId ?? string.Empty; if (!string.IsNullOrEmpty(sessionId)) RequestContext.SetSessionId(sessionId); await next(context); } finally { if (!string.IsNullOrEmpty(sessionId)) await _logoutAtomicHandler.Handle(new LogoutRequestDTO { SessionId = sessionId }); } }
    private bool ShouldApplyAuthentication(FunctionContext context) { string entryPoint = context.FunctionDefinition.EntryPoint; int lastDot = entryPoint.LastIndexOf('.'); string typeName = entryPoint.Substring(0, lastDot); string methodName = entryPoint.Substring(lastDot + 1); return Type.GetType(typeName)?.GetMethod(methodName)?.GetCustomAttribute<CustomAuthenticationAttribute>() != null; } }
```

### D. Middleware - Token-Based (with Cache, no Logout)
```csharp
public async Task Invoke(FunctionContext context, FunctionExecutionDelegate next) {
    if (!ShouldApplyAuthentication(context)) { await next(context); return; }
    try {
        CacheKey key = CacheKey.CreateCacheKey(["AUTH_TOKEN"]); string? authToken = await key.GetStringAsync();
        if (!string.IsNullOrEmpty(authToken)) { RequestContext.SetToken(authToken); await next(context); return; }
        Dictionary<string, string?> secrets = await _keyVaultReader.GetAuthSecretsAsync();
        AuthenticationRequestDTO request = new AuthenticationRequestDTO { ClientId = secrets.GetValueOrDefault("ClientId"), ClientSecret = secrets.GetValueOrDefault("ClientSecret") };
        HttpResponseSnapshot authResponse = await _authenticateAtomicHandler.Handle(request);
        if (!authResponse.IsSuccessStatusCode) throw new DownStreamApiFailureException(...);
        AuthenticationResponseDTO? authAPIRes = JsonSerializer.Deserialize<AuthenticationResponseDTO>(authResponse.Content!);
        authToken = authAPIRes.AccessToken;
        if (int.TryParse(authAPIRes.ExpiresIn, out int expiresInSeconds))
            key.Settings = new CacheKeySettings { TimeToLive = TimeSpan.FromSeconds(expiresInSeconds) };
        await key.SetStringAsync(authToken); RequestContext.SetToken(authToken); await next(context);
    } catch (Exception ex) { _logger.Error(ex, $"Auth error: {context.FunctionDefinition}"); throw; }
}
```

### E. Using in Functions
```csharp
[Function("GetData")] [CustomAuthentication] // ‚Üê Apply attribute
public async Task<BaseResponseDTO> Run([HttpTrigger(AuthorizationLevel.Anonymous, "post")] HttpRequest req) {
    GetDataReqDTO? request = await req.ReadBodyAsync<GetDataReqDTO>(); request.ValidateAPIRequestParameters();
    string? sessionId = RequestContext.GetSessionId(); string? token = RequestContext.GetToken(); // No FunctionContext param needed
    return await _service.GetData(request);
}
```

## 5. PERFORMANCE TIMING (MANDATORY FOR ALL HTTP/SOAP CLIENTS)

**Rule:** ALL HTTP/SOAP clients MUST track timing with Stopwatch + append to ResponseHeaders.DSTimeBreakDown

```csharp
using System.Diagnostics; using Core.Headers;

Stopwatch sw = Stopwatch.StartNew(); // 1. START before call
HttpResponseMessage response = await _client.SendAsync(...); HttpResponseSnapshot result = await HttpResponseSnapshot.FromAsync(response);
sw.Stop(); // 2. STOP after response
ResponseHeaders.DSTimeBreakDown.Item2.Value?.Append($"{operationName}:{sw.ElapsedMilliseconds},"); // 3. APPEND (exact format, use ?.Append())
```

**ResponseHeaders.DSTimeBreakDown:** Type=`Tuple<string, AsyncLocal<StringBuilder>>` | Item1="DSTimeBreakDown" | Item2.Value=StringBuilder | Format=`op1:ms1,op2:ms2,op3:ms3`

**Example - CustomRestClient:**
```csharp
public async Task<HttpResponseSnapshot> ExecuteCustomRestRequestAsync(string operationName, string apiUrl, HttpMethod httpMethod) {
    Stopwatch sw = Stopwatch.StartNew();
    HttpResponseMessage response = await _customHTTPClient.SendAsync(...); HttpResponseSnapshot result = await HttpResponseSnapshot.FromAsync(response);
    sw.Stop(); ResponseHeaders.DSTimeBreakDown.Item2.Value?.Append($"{operationName}:{sw.ElapsedMilliseconds},");
    return result;
}
```

**Response Headers:** SYSTotalTime=total execution | DSTimeBreakDown=Auth:245,GetData:1823,Logout:123 | DSAggregatedTime=2191 (auto-sum) | IsDownStreamError=false

### 5.1 CUSTOM CLIENT CREATION (CustomSoapClient Example)

**‚ö†Ô∏è CRITICAL:** When creating custom HTTP/SOAP clients (like `CustomSoapClient`), you MUST implement timing tracking. Framework clients (`CustomRestClient`, `CustomHTTPClient`) already have it, but custom clients need explicit implementation.

**Simple Example - CustomSoapClient:**
```csharp
using Core.Headers; using System.Diagnostics;

public async Task<HttpResponseSnapshot> ExecuteCustomSoapRequestAsync(string operationName, string soapEnvelope, string? apiUrl, string? soapActionUrl, HttpMethod httpMethod) {
    Stopwatch sw = Stopwatch.StartNew(); // MANDATORY: Start before call
    HttpResponseMessage response = await ExecuteSoapRequestAsync(...);
    HttpResponseSnapshot result = await HttpResponseSnapshot.FromAsync(response);
    sw.Stop(); // MANDATORY: Stop after response
    ResponseHeaders.DSTimeBreakDown.Item2.Value?.Append($"{operationName}:{sw.ElapsedMilliseconds},"); // MANDATORY: Append timing
    return result;
}
```

**Checklist:** `using System.Diagnostics;` + `using Core.Headers;` | `Stopwatch.StartNew()` before call | `sw.Stop()` after response | `ResponseHeaders.DSTimeBreakDown.Item2.Value?.Append($"{operationName}:{sw.ElapsedMilliseconds},");` | Use `?.Append()` for null-safety | Format: `{operationName}:{elapsedMilliseconds},`

**Note:** Applies to ANY custom HTTP/SOAP client, not just SOAP.

## 6. PROGRAM.CS REGISTRATION

```csharp
FunctionsApplicationBuilder builder = FunctionsApplication.CreateBuilder(args);
// 0. Logging (FIRST!)
builder.Services.AddApplicationInsightsTelemetryWorkerService().ConfigureFunctionsApplicationInsights(); builder.Logging.AddConsole();
// 1. Configuration
builder.Services.Configure<AppConfigs>(builder.Configuration.GetSection(AppConfigs.SectionName));
// 2. Framework Libraries
builder.Services.AddRedisCacheLibrary(builder.Configuration);
// 3. HTTP Clients (auto-registered by Core Framework)
// 4. Helpers
builder.Services.AddSingleton<KeyVaultReader>();
// 5. Services (Interface ‚Üí Implementation)
builder.Services.AddScoped<IDataMgmt, DataService>();
// 6. Handlers (Concrete)
builder.Services.AddScoped<GetDataHandler>(); builder.Services.AddScoped<CreateDataHandler>();
// 7. Atomic Handlers (Concrete)
builder.Services.AddScoped<GetDataAtomicHandler>(); builder.Services.AddScoped<CreateDataAtomicHandler>();
// 8. Auth Atomic Handlers (for middleware)
builder.Services.AddScoped<AuthenticateAtomicHandler>(); builder.Services.AddScoped<LogoutAtomicHandler>();
// 9. Middleware (ORDER CRITICAL!)
builder.UseMiddleware<ExecutionTimingMiddleware>(); builder.UseMiddleware<ExceptionHandlerMiddleware>(); builder.UseMiddleware<CustomAuthenticationMiddleware>();
// 10. Service Locator (LAST!)
ServiceLocator.ServiceProvider = builder.Services.BuildServiceProvider(); builder.Build().Run();
```

**Order:** Config ‚Üí HTTP ‚Üí Singletons ‚Üí Services ‚Üí Handlers ‚Üí AtomicHandlers ‚Üí Middleware ‚Üí ServiceLocator(last)

## 7. DO'S & DON'TS

### ‚úÖ DO
- Create AuthenticateAtomicHandler+LogoutAtomicHandler (internal only, NOT Azure Functions) | Create CustomAuthenticationAttribute+CustomAuthenticationMiddleware+RequestContext
- Register middleware in EXACT ORDER: ExecutionTiming‚ÜíException‚ÜíAuth | Mark Functions with `[CustomAuthentication]` attribute
- Use RequestContext (AsyncLocal<T>) for session/token storage | Inject AppConfigs in middleware constructor if needed (field+param+assignment)
- Cache tokens with TTL | Handle auth failures with DownStreamApiFailureException
- ALWAYS use Stopwatch + append `ResponseHeaders.DSTimeBreakDown.Item2.Value?.Append($"{operationName}:{sw.ElapsedMilliseconds},");`
- Use `?.Append()` for null-safety | Use descriptive operationName | Start stopwatch BEFORE call, stop AFTER response
- For credentials-per-request: add directly in Atomic Handler headers (no middleware)

### ‚ùå DON'T
- DON'T create Login/Logout/GetToken Azure Functions (middleware handles) | DON'T manually call auth in Handlers | DON'T create Service/Handler for auth
- DON'T use FunctionContext.Items for session/token storage (use RequestContext with AsyncLocal<T>) | DON'T use static fields without AsyncLocal<T>
- DON'T make RequestContext properties publicly settable | DON'T change middleware order | DON'T forget to inject AppConfigs if needed
- DON'T forget to register AuthenticateAtomicHandler+LogoutAtomicHandler in DI
- DON'T skip ResponseHeaders.DSTimeBreakDown append | DON'T use incorrect format (missing :, missing ,) | DON'T forget `?.Append()`
- DON'T append before call completes | DON'T use vague operation names

## 8. COMMON ERRORS & FIXES

| Error | Cause | Fix |
|-------|-------|-----|
| `CS0103: '_appConfigs' not exist` | Missing field/injection | Inject AppConfigs: field+param+assignment |
| `Middleware not invoked` | Not registered | `builder.UseMiddleware<YourMiddleware>()` |
| `Auth fails silently` | Wrong order | ExecutionTiming‚ÜíException‚ÜíAuth |
| `Token/Session not found` | RequestContext not set | Middleware must call SetSessionId/SetToken |
| `NullRef on DSTimeBreakDown` | Missing `?.Append()` | Use `?.Append(...)` |
| `Timing not tracked` | Missing pattern | Add Stopwatch + append to DSTimeBreakDown |

## 9. VERIFICATION CHECKLIST
- [ ] Middleware order: ExecutionTiming‚ÜíException‚ÜíAuth
- [ ] RequestContext.cs in Middleware/ or Helper/ folder
- [ ] CustomAuthenticationAttribute in Attributes/ (if auth)
- [ ] AuthenticateAtomicHandler+LogoutAtomicHandler registered (if auth)
- [ ] AppConfigs injected in middleware (field+param+assignment if needed)
- [ ] All HTTP/SOAP clients: Stopwatch + `ResponseHeaders.DSTimeBreakDown.Item2.Value?.Append($"{op}:{sw.ElapsedMilliseconds},");`
- [ ] Functions have `[CustomAuthentication]` attribute (if auth)
- [ ] No Login/Logout Functions exposed
- [ ] FunctionContext param passed through Function ‚Üí Service ‚Üí Handler
- [ ] `?.Append()` used for null-safety
- [ ] Descriptive operation names
- [ ] Stopwatch: start BEFORE, stop AFTER

## 10. KEY INVARIANTS (NEVER VIOLATE)
1. **Auth ALWAYS by middleware** - NEVER manual Login/Logout calls
2. **Middleware order FIXED:** ExecutionTiming‚ÜíException‚ÜíAuth (NON-NEGOTIABLE)
3. **ALL HTTP/SOAP clients MUST append timing:** `ResponseHeaders.DSTimeBreakDown.Item2.Value?.Append($"{op}:{ms},");`
4. **Use AsyncLocal<T> via RequestContext** - NEVER FunctionContext.Items
5. **Auth Atomic Handlers INTERNAL ONLY** - NEVER Azure Functions
6. **Middleware constructor MUST inject dependencies** (AppConfigs, logger, atomic handlers) with field+assignment
7. **Use `?.Append()` for null-safety** on ResponseHeaders.DSTimeBreakDown.Item2.Value
8. **ExecutionTimingMiddleware initializes DSTimeBreakDown** as empty StringBuilder at request start
9. **ExceptionHandlerMiddleware normalizes ALL exceptions** to BaseResponseDTO
10. **Logout in finally block** (session-based) ensures execution even on exception

---

# AZURE FUNCTIONS RULES
*ALL RULES CRITICAL & MANDATORY - NO EXCEPTIONS*

## üõë PRE-CREATION VALIDATION (MANDATORY - STOP IF NOT COMPLETE)

**üö® YOU CANNOT CREATE ANY FUNCTION UNTIL:**

1. ‚úÖ **STOP AND VERIFY:** Have I completed Function Exposure Decision table?
2. ‚úÖ **STOP AND VERIFY:** Does decision table show this operation should be a Function (not Atomic Handler)?
3. ‚úÖ **STOP AND VERIFY:** Have I read ALL sections in "AZURE FUNCTIONS RULES"?
4. ‚úÖ **STOP AND VERIFY:** Do I know the exact folder location (Functions/ folder, flat structure)?

**üõë IF ANY CHECKPOINT FAILS ‚Üí STOP ‚Üí Complete missing step ‚Üí Then create Function**

---

**üìö FRAMEWORK REFERENCE:** Review `Framework/Core` and `Framework/Cache` directories to understand framework-level implementation patterns, base classes, interfaces, and helper methods that these rules build upon.

**üö® BEFORE CREATING:** Read ALL rules in this section before creating Functions. Verify [Function] attribute, [HttpTrigger] parameters, request handling sequence, and service delegation.

## 1. CORE PRINCIPLES
- **Purpose:** HTTP-triggered entry points for System Layer (thin layer, NO business logic)
- **Flow:** 
  - `Function ‚Üí Service ‚Üí Handler ‚Üí Atomic Handler ‚Üí External API` (when SOR call exists - MANDATORY orchestration)
  - `Function ‚Üí [direct logic]` (when NO SOR call AND no orchestration needed)
- **Rule:** ONE function = ONE business operation Process Layer needs to call independently
- **Return:** `Task<BaseResponseDTO>` (MANDATORY)
- **üî¥ CRITICAL - When to Create Handler/Service/Abstraction:** 
  - ‚úÖ **MANDATORY - Create Handler/Service/Abstraction:** When SOR call exists (ALWAYS requires orchestration - Handler/Service/Abstraction/Atomic Handler)
  - ‚úÖ **Function-level only:** When NO SOR call AND no orchestration needed - handle directly at Function level (NO Handler/Service/Abstraction/Atomic Handler)

## 2. NAMING & STRUCTURE
- **Class:** `<Operation>API` (e.g., `GetEntityDetailAPI`, `CreateRecordAPI`)
- **File:** `<Operation>API.cs` in `Functions/` folder (flat, no subfolders)
- **Method:** `Run` (FIXED name)
- **Attribute:** `[Function("FunctionName")]` (MANDATORY, PascalCase, no "API" suffix)

## 3. ATTRIBUTES & HTTP TRIGGER
```csharp
[CustomAuthentication]  // ‚Üê Optional: Use ONLY for session/token auth (NOT credentials-per-request)
[Function("GetEntityDetail")]  // ‚Üê MANDATORY
public async Task<BaseResponseDTO> Run(
    [HttpTrigger(AuthorizationLevel.Anonymous, "post", Route = "entity/details")] HttpRequest req)
```
- **AuthorizationLevel:** Use `Anonymous` (auth via middleware or credentials)
- **HTTP Methods:** `"post"` (most common), `"get"`, `"put"`, `"delete"` | **üî¥ CRITICAL:** ONE verb per action - NEVER multiple verbs like `"get", "post"` in same HttpTrigger
- **Route:** Optional (defaults to function name), format: `"resource/operation"` or `"resource/{param}"`
- **Route Parameters:** Extract as method params: `HttpRequest req, string type`

## 4. FUNCTION PARAMETERS
- **Required:** `HttpRequest req` (ALWAYS)
- **Required:** `FunctionContext context` (ALWAYS - for Core framework compliance)
- **Route Params:** `string paramName` (if route has `{paramName}`)
- **IMPORTANT:** FunctionContext is passed through Function ‚Üí Service ‚Üí Handler for framework compliance, but session/token management uses `RequestContext` (AsyncLocal pattern)
- **Request Headers:** Only extract headers that are REQUIRED and sent by Process/Experience Layer | ‚ùå DON'T extract headers that are not required or not sent by Process/Experience Layer

## 5. REQUEST HANDLING PATTERN (MANDATORY SEQUENCE)
```csharp
[Function("GetEntityDetail")]
public async Task<BaseResponseDTO> Run([HttpTrigger...] HttpRequest req, FunctionContext context) {
    _logger.Info("HTTP trigger received for Get Entity Detail.");  // Step 1: Log entry
    GetEntityDetailReqDTO? request = await req.ReadBodyAsync<GetEntityDetailReqDTO>();  // Step 2: Read body
    if (request == null) {  // Step 3: Null check (MANDATORY)
        _logger.Error("Request body is null or invalid.");
        throw new NoRequestBodyException(errorDetails: [ErrorCodes.REQ_BODY_MISSING_OR_EMPTY.Message], stepName: "GetEntityDetailAPI.cs / Executing Run");
    }
    request.ValidateAPIRequestParameters();  // Step 4: Validate (MANDATORY)
    BaseResponseDTO result = await _entityMgmt.GetEntityDetail(request, context);  // Step 5: Delegate to service (pass context)
    return result;  // Step 6: Return (middleware handles serialization)
}
```

## 6. AUTHENTICATION PATTERNS

### 6.1 Credentials-Per-Request (NO Middleware)
```csharp
[Function("GetData")]  // ‚Üê NO [CustomAuthentication]
public async Task<BaseResponseDTO> Run([HttpTrigger...] HttpRequest req)
{
    // Credentials added in Atomic Handler
}
```

### 6.2 Session/Token-Based (Middleware)
```csharp
[CustomAuthentication]  // ‚Üê Triggers middleware
[Function("CreateEntity")]
public async Task<BaseResponseDTO> Run([HttpTrigger...] HttpRequest req)
{
    string? sessionId = RequestContext.GetSessionId();  // ‚Üê Retrieve from RequestContext (set by middleware)
    if (string.IsNullOrEmpty(sessionId))
        throw new BaseException(ErrorConstants.SESSION_ID_NOT_FOUND);
    request.SessionId = sessionId;
}
```

## 7. REQUESTCONTEXT PATTERN (MODERN - REPLACES FunctionContext.Items)
**Location:** `Helpers/RequestContext.cs`
```csharp
public static class RequestContext { private static readonly AsyncLocal<string?> _sessionId = new(), _authToken = new(); public static void SetSessionId(string s) => _sessionId.Value = s; public static string? GetSessionId() => _sessionId.Value; public static void SetToken(string t) => _authToken.Value = t; public static string? GetToken() => _authToken.Value; public static void Clear() { _sessionId.Value = null; _authToken.Value = null; } }
```
**Benefits:** No `FunctionContext` param needed, thread-safe (`AsyncLocal<T>`), cleaner code

## 8. SERVICE DELEGATION (CONDITIONAL)

### 8.1 When Orchestration Needed (Handler/Service/Abstraction Required)
```csharp
public class GetEntityDetailAPI { private readonly ILogger<GetEntityDetailAPI> _logger; private readonly IEntityMgmt _entityMgmt;
    public GetEntityDetailAPI(ILogger<GetEntityDetailAPI> logger, IEntityMgmt entityMgmt) { _logger = logger; _entityMgmt = entityMgmt; }
    [Function("GetEntityDetail")] public async Task<BaseResponseDTO> Run([HttpTrigger...] HttpRequest req) { /* ... validation ... */ return await _entityMgmt.GetEntityDetail(request); }
}
```
**Use When:** Multiple atomic operations | Data transformations | Response mapping | Error handling logic | Same-SOR orchestration

### 8.2 When SOR Call Exists (MANDATORY - Handler/Service/Abstraction Required)
**üî¥ CRITICAL:** If SOR call exists, you MUST create Handler/Service/Abstraction/Atomic Handler - there is NO direct Function ‚Üí Atomic Handler path.
**Rule:** ALL SOR calls require full orchestration: Function ‚Üí Service ‚Üí Handler ‚Üí Atomic Handler ‚Üí External API

### 8.2 When NO SOR Call AND No Orchestration (Function-Level Only)
```csharp
public class ValidateRequestAPI { private readonly ILogger<ValidateRequestAPI> _logger;
    public ValidateRequestAPI(ILogger<ValidateRequestAPI> logger) { _logger = logger; }
    [Function("ValidateRequest")] public async Task<BaseResponseDTO> Run([HttpTrigger...] HttpRequest req, FunctionContext context) {
        ValidateRequestReqDTO? request = await req.ReadBodyAsync<ValidateRequestReqDTO>();
        if (request == null) throw new NoRequestBodyException(...);
        request.ValidateAPIRequestParameters();
        // Direct logic at Function level - no SOR call, no orchestration
        bool isValid = ValidateBusinessRules(request);
        if (!isValid) throw new BusinessCaseFailureException(...);
        return new BaseResponseDTO(message: InfoConstants.VALIDATION_SUCCESS, data: new ValidateRequestResDTO { IsValid = true }, errorCode: null);
    }
    private bool ValidateBusinessRules(ValidateRequestReqDTO request) { /* validation logic */ return true; }
}
```
**Use When:** NO SOR call | NO orchestration | Simple validation/logic | No external API calls
**Rule:** Handle directly at Function level - NO Handler/Service/Abstraction/Atomic Handler needed

## 9. ERROR HANDLING
- **‚ùå DON'T** wrap in try-catch (middleware handles all exceptions)
- **‚úÖ DO** throw exceptions: `NoRequestBodyException`, `RequestValidationFailureException`, `BaseException`
- **Middleware:** Catches exceptions ‚Üí Maps to HTTP status ‚Üí Returns `BaseResponseDTO`

## 10. LOGGING (Core.Extensions.LoggerExtensions)
```csharp
_logger.Info("message");           // ‚úÖ Use these
_logger.Error("message");
_logger.Error(ex, "message");
_logger.Warn("message");

_logger.LogInformation("msg");     // ‚ùå DON'T use ILogger methods directly
```
**Log:** Function entry, errors before throwing, key context (NO sensitive data, NO full request/response bodies)

## 11. FUNCTION EXPOSURE DECISION (PREVENTS FUNCTION EXPLOSION)

**Decision Table (MANDATORY):** For EACH operation: Q1: Can Process Layer invoke independently? NO‚ÜíAtomic Handler, YES‚ÜíQ2 | Q2: Decision shape before/after? YES‚ÜíQ3, NO‚ÜíQ4 | Q3: Business logic (if/else)? YES‚ÜíAzure Function (Process Layer decides), NO‚ÜíQ4 | Q4: ONLY field extraction? YES‚ÜíAtomic Handler, NO‚ÜíQ5 | Q5: Complete business op? YES‚ÜíAzure Function, NO‚ÜíAtomic Handler

**Rule Book Line 1066:** "if (X exists) skip Y ‚Üí Process Layer"
- ‚úÖ Existence check ‚Üí Decision ‚Üí Create = **2 Functions** (`CheckExistsAPI`, `CreateAPI`), Process Layer decides
- ‚úÖ Get config ‚Üí Decision ‚Üí Execute if flag = **2 Functions** (`GetConfigAPI`, `ExecuteAPI`), Process Layer decides
- ‚úÖ Get Type ‚Üí Get Category ‚Üí Create (sequential, NO decisions) = **1 Function** (`CreateEntityAPI`, internal: GetType/GetCategory atomic handlers)

**Common Mistakes:** Function Explosion (5+ Functions) ‚Üí convert internal lookups to Atomic Handlers | Login/LogoutAPI ‚Üí remove, use middleware | Get*Type, Get*Category as Functions ‚Üí convert to Atomic Handlers | if/else in System Layer ‚Üí move decision to Process Layer

**Examples:** (1) Sequential: `Login‚ÜíGetType‚ÜíGetCategory‚ÜíCreate‚ÜíLogout` = **1 Func** `CreateEntityAPI` | (2) Existence: `Login‚ÜíCheckExists‚ÜíDecision‚ÜíCreate‚ÜíLogout` = **2 Funcs** `CheckExistsAPI`, `CreateEntityAPI` | (3) Multi-Conditional: `Login‚ÜíQuery‚ÜíDecision‚ÜíUpdate(internal:GetType+GetCategory)‚ÜíDecision‚ÜíLink‚ÜíLogout` = **3 Funcs** `QueryAPI`, `UpdateAPI`, `LinkAPI`

## 12. DEPENDENCY INJECTION (Program.cs)
```csharp
FunctionsApplicationBuilder builder = FunctionsApplication.CreateBuilder(args);
builder.UseMiddleware<ExecutionTimingMiddleware>(); builder.UseMiddleware<ExceptionHandlerMiddleware>(); builder.UseMiddleware<CustomAuthenticationMiddleware>();  // FIXED ORDER
builder.Services.AddScoped<IEntityMgmt, EntityMgmtService>(); builder.Services.AddScoped<GetEntityDetailHandler>(); builder.Services.AddScoped<GetEntityDetailAtomicHandler>();  // Scoped
builder.Services.AddSingleton<CustomRestClient>(); builder.Services.Configure<AppConfigs>(builder.Configuration.GetSection("AppConfigs"));  // Singleton
builder.Services.AddApplicationInsightsTelemetryWorkerService().ConfigureFunctionsApplicationInsights(); builder.Logging.AddConsole(); builder.Logging.AddFilter<ApplicationInsightsLoggerProvider>("", LogLevel.Trace);  // MANDATORY
builder.Build().Run();
```

## 13. TEMPLATES (See Section 5 for basic, add [CustomAuthentication] + RequestContext.GetSessionId() for auth, add route param for routes)

## 14. CHECKLIST
**Before Creating Function:**
- [ ] Class name ends with `API`, file in `Functions/`
- [ ] `[Function("Name")]` attribute present, method named `Run`
- [ ] `[CustomAuthentication]` applied ONLY if session/token auth
- [ ] `HttpRequest req` and `FunctionContext context` parameters (BOTH required)
- [ ] `req.ReadBodyAsync<T>()` ‚Üí null check ‚Üí throw `NoRequestBodyException`
- [ ] `request.ValidateAPIRequestParameters()` called
- [ ] Use `RequestContext.GetSessionId()` for session auth
- [ ] Delegate to service interface (NO business logic)
- [ ] Return `Task<BaseResponseDTO>`
- [ ] NO try-catch wrapping (middleware handles exceptions)
- [ ] Use `Core.Extensions.LoggerExtensions` (`.Info()`, `.Error()`)
- [ ] Function represents operation Process Layer calls independently
- [ ] NOT exposing internal lookup/validation as Function
- [ ] Completed Function Exposure Decision Table

**END OF AZURE FUNCTIONS RULES**

# SERVICES & ABSTRACTIONS RULES
*ALL RULES CRITICAL & MANDATORY - NO EXCEPTIONS*

**üìö FRAMEWORK REFERENCE:** Review `Framework/Core` and `Framework/Cache` directories to understand framework-level implementation patterns, base classes, interfaces, and helper methods that these rules build upon.

**üö® BEFORE CREATING:** Read ALL rules in this section before creating Services/Interfaces. Verify folder location (Implementations/<Vendor>/Services/ NOT root), interface naming, and dependency injection patterns.

## 1. OVERVIEW
- **Flow:** 
  - `Function ‚Üí Interface (IEntityMgmt) ‚Üí Service (EntityMgmtService) ‚Üí Handler ‚Üí Atomic Handler ‚Üí External API` (when SOR call exists - MANDATORY orchestration)
  - `Function ‚Üí [direct logic]` (when NO SOR call AND no orchestration needed)
- **Abstractions:** Define contracts, root `Abstractions/` folder, injected into Functions | **Services:** Implement interfaces, `Implementations/<VendorName>/Services/`, delegate to Handlers (NO external calls)
- **Rule:** "Services are abstraction boundaries between Functions and Handlers" | "Services implement interfaces, Handlers use concrete classes" | **üî¥ CRITICAL:** 
  - ‚úÖ **MANDATORY - Create Handler/Service/Abstraction:** When SOR call exists (ALWAYS requires full orchestration - Handler/Service/Abstraction/Atomic Handler)
  - ‚úÖ **Function-level only:** When NO SOR call AND no orchestration needed - handle directly at Function level (NO Handler/Service/Abstraction/Atomic Handler)

## 2. ABSTRACTIONS (INTERFACES)

### 2.1 Naming & Location
- **Name:** `I<Domain>Mgmt` (e.g., `IEntityMgmt`, `IRecordMgmt`, `ITaskMgmt`) | MUST start with `I`, end with `Mgmt`
- **File:** `I<Domain>Mgmt.cs` in `Abstractions/` at ROOT (‚ùå NOT in Implementations/, NOT in Services/, NOT in vendor folder)
- **Namespace:** `<ProjectName>.Abstractions`
- **‚ùå Wrong:** `EntityMgmt` (missing I), `IEntityService` (wrong suffix), `IVendorEntityMgmt` (has vendor name)

### 2.2 Method Signatures & Design Rules
- **Return:** `Task<BaseResponseDTO>` (MANDATORY, NO async/await in interface, NO void, NO synchronous)
- **Parameters:** Accept specific request DTOs (e.g., `GetEntityDetailReqDTO request`) - NO multiple parameters, use DTO
- **Naming:** PascalCase, action verb + noun (Get, Create, Update, Delete, Process, Assign)
- **‚úÖ DO:** One interface per domain, methods = complete operations, keep single responsibility, use XML docs
- **‚ùå DON'T:** Mix domains, include implementation details, add vendor-specific methods, return concrete types, use async/await in declaration

### 2.3 Templates
```csharp
// Entity Management
public interface IEntityMgmt {
    Task<BaseResponseDTO> GetEntityDetail(GetEntityDetailReqDTO request);
    Task<BaseResponseDTO> CreateEntity(CreateEntityReqDTO request);
}
// Entity Management examples follow same pattern: IEntityMgmt, IRecordMgmt, ITaskMgmt
```

## 3. SERVICES (IMPLEMENTATIONS)

### 3.1 Naming & Location
- **Name:** `<Domain>Service` (match interface: `IEntityMgmt` ‚Üí `EntityMgmtService`) | NO vendor name in class
- **File:** `<Domain>Service.cs` in `Implementations/<VendorName>/Services/` (üî¥ MANDATORY - allows multiple vendor implementations in same project)
- **‚ùå FORBIDDEN:** Root-level `Services/` folder (do NOT create at root) - violates vendor separation
- **Namespace:** `<ProjectName>.Implementations.<VendorName>.Services` (e.g., `ProjectMgmtSystem.Implementations.VendorName.Services`)
- **Why Vendor Folder:** Different vendors = different implementations | Allows multi-vendor support | Clear separation of vendor-specific code

### 3.2 Structure & Responsibilities
- **Implements:** Corresponding interface (MANDATORY)
- **Injects:** `ILogger<T>` (first - MANDATORY), Handler concrete classes (NOT interfaces - MANDATORY), `IOptions<AppConfigs>` (optional)
- **Methods:** Match interface signature exactly, `public async Task<BaseResponseDTO>`, delegate to Handler, return result
- **Logging:** Entry/exit using `Core.Extensions.LoggerExtensions` (`.Info()`, `.Error(ex, msg)`, `.Warn()`)
- **‚úÖ Services ONLY:** Delegate to Handlers | Log entry/exit/errors | Handle/rethrow exceptions | Simple coordination
- **‚ùå Services NEVER:** Business logic (‚ÜíProcess Layer) | External API calls (‚ÜíHandlers) | Call Atomic Handlers directly (‚Üíuse Handlers) | Transform data (‚ÜíHandlers) | Validate DTOs (‚ÜíFunctions) | Orchestrate with if/else decisions (‚ÜíProcess Layer) | Make multiple handler calls with conditional logic (‚ÜíProcess Layer)

### 3.3 Template
```csharp
namespace <Namespace>.Implementations.<VendorName>.Services { public class EntityMgmtService : IEntityMgmt { private readonly ILogger<EntityMgmtService> _logger; private readonly GetEntityDetailHandler _getEntityDetailHandler;
    public EntityMgmtService(ILogger<EntityMgmtService> logger, GetEntityDetailHandler handler) { _logger = logger; _getEntityDetailHandler = handler; }
    public async Task<BaseResponseDTO> GetEntityDetail(GetEntityDetailReqDTO request) { _logger.Info("EntityMgmtService.GetEntityDetail called"); return await _getEntityDetailHandler.HandleAsync(request); } } }
```

## 4. FOLDER STRUCTURE
```
<Project>/
‚îú‚îÄ‚îÄ Abstractions/         # ‚úÖ Interfaces at ROOT (IEntityMgmt.cs, IRecordMgmt.cs)
‚îî‚îÄ‚îÄ Implementations/<VendorName>/
    ‚îú‚îÄ‚îÄ Services/         # ‚úÖ Services HERE (EntityMgmtService.cs, RecordMgmtService.cs)
    ‚îú‚îÄ‚îÄ Handlers/
    ‚îî‚îÄ‚îÄ AtomicHandlers/
```
**Rule:** `Abstractions/` at root | `Services/` inside `Implementations/<VendorName>/` | ‚ùå NO root-level `Services/` folder

## 5. DEPENDENCY INJECTION (Program.cs)
```csharp
FunctionsApplicationBuilder builder = FunctionsApplication.CreateBuilder(args);
builder.Services.Configure<AppConfigs>(builder.Configuration.GetSection("AppConfigs")); builder.Services.AddSingleton<CustomRestClient>();
builder.Services.AddScoped<IEntityMgmt, EntityMgmtService>(); builder.Services.AddScoped<IRecordMgmt, RecordMgmtService>();  // WITH interfaces
builder.Services.AddScoped<GetEntityDetailHandler>(); builder.Services.AddScoped<GetEntityDetailAtomicHandler>();  // Concrete only
builder.UseMiddleware<ExecutionTimingMiddleware>(); builder.UseMiddleware<ExceptionHandlerMiddleware>();
builder.Services.AddApplicationInsightsTelemetryWorkerService().ConfigureFunctionsApplicationInsights(); builder.Build().Run();
```
**Rules:** Services: `AddScoped<IInterface, Impl>()` (WITH interface - enables DI in Functions, vendor-specific implementations) | Handlers/Atomic: `AddScoped<Concrete>()` (NO interface - operation-specific) | ‚ùå `AddScoped<Service>()` (missing interface)
**Lifetimes:** Services/Handlers/Atomic = Scoped (per request) | HTTP Clients = Singleton (connection pooling) | Config = Singleton (immutable)

## 6. CONSTRUCTOR INJECTION
- **Pattern:** `private readonly Type _fieldName;` (camelCase with underscore)
- **Order:** Logger (first), Handlers, Configuration (last)
- **‚úÖ Inject:** `ILogger<T>` (MANDATORY), Handler concrete classes (MANDATORY), `IOptions<AppConfigs>` (if needed)
- **‚ùå NEVER Inject:** Atomic Handlers directly (use Handlers), HTTP Clients directly (use Handlers/Atomic Handlers), Repository patterns (not used)

## 7. BUSINESS COORDINATION VS LOGIC
**‚úÖ Allowed:** Simple delegation: `return await _handler.HandleAsync(request);` | Method entry/exit logging
**‚ùå NOT Allowed:** Try-catch blocks (NEVER use - exception handling managed at middleware level) | Checking existence + deciding: `if (exists) return ...` | Conditional execution: `if (shouldProcess) await ...` | Transformations based on business rules | Validation with business decisions | **Rule:** "if (X exists) skip Y ‚Üí Process Layer" (Line 1066) - Services ONLY delegate, NO decisions

## 8. LOGGING
`using Core.Extensions;` | ‚úÖ `_logger.Info("msg")`, `_logger.Error(ex, "msg")`, `_logger.Warn("msg")` | ‚ùå `_logger.LogInformation()` (DON'T use ILogger directly)
**Log:** Method entry (`"Service.Method called"`), errors with exception, success (optional) | **DON'T:** Sensitive data, full bodies, redundant info

## 9. NAMING
| Component | Format | Example | ‚ùå Wrong |
|-----------|--------|---------|----------|
| Interface | `I<Domain>Mgmt` | `IEntityMgmt` | `EntityMgmt`, `IEntityService`, `IVendorEntityMgmt` |
| Service | `<Domain>Service` | `EntityMgmtService` | `VendorEntityService`, `RecordService` |
| Method | `<Verb><Noun>` | `GetEntityDetail`, `CreateEntity` | `getEntityDetail`, `Get_Entity` |
| Namespace (Interface) | `<Project>.Abstractions` | `ProjectMgmtSystem.Abstractions` | - |
| Namespace (Service) | `<Project>.Implementations.<Vendor>.Services` | `ProjectMgmtSystem.Implementations.VendorName.Services` | - |

## 10. CHECKLIST
**Interfaces:** [ ] In `Abstractions/` at root | [ ] Name: `I<Domain>Mgmt` (NO vendor name) | [ ] Methods: `Task<BaseResponseDTO>`, accept DTOs | [ ] One per domain
**Services:** [ ] In `Implementations/<VendorName>/Services/` (NOT at root) | [ ] Name: `<Domain>Service` (NO vendor name) | [ ] Implements interface | [ ] Constructor: `ILogger<T>` first, Handler concretes | [ ] Fields: `private readonly` | [ ] Methods: match interface, delegate to Handlers (NO external/atomic direct) | [ ] Log entry/exit (`.Info()`, `.Error()`) | [ ] NO business logic | [ ] DI: `AddScoped<IInterface, Service>()`
**Folder:** [ ] `Abstractions/` at root | [ ] `Services/` in `Implementations/<VendorName>/` | [ ] NO root `Services/` | [ ] All services with interfaces, handlers concrete in Program.cs

**END OF SERVICES & ABSTRACTIONS RULES**

# Handler RULES
*ALL RULES CRITICAL & MANDATORY - NO EXCEPTIONS*

**üìö FRAMEWORK REFERENCE:** Review `Framework/Core` and `Framework/Cache` directories to understand framework-level implementation patterns, base classes, interfaces, and helper methods that these rules build upon.

**üö® BEFORE CREATING:** Read ALL rules in this section before creating Handlers. Verify IBaseHandler<T> implementation, orchestration patterns, error handling, and DTO requirements.

## 1. DEFINITION & PURPOSE
**Handler:** Orchestrates Atomic Handlers for business operations | **Purpose:** Coordinate atomic operations, transform responses, handle errors | **Key:** Same-SOR operations ONLY (Rule #2)

## 2. INTERFACE & IMPLEMENTATION

### IBaseHandler<T> (Framework)
```csharp
namespace Core.SystemLayer.Handlers { public interface IBaseHandler<T> where T : IRequestSysDTO { Task<BaseResponseDTO> HandleAsync(T requestDTO); } }
```

### Handler Pattern
```csharp
public class GetEntityDetailHandler : IBaseHandler<GetEntityDetailReqDTO> {
    private readonly ILogger<GetEntityDetailHandler> _logger; 
    private readonly GetEntityDetailAtomicHandler _getEntityDetailAtomicHandler;
    
    public async Task<BaseResponseDTO> HandleAsync(GetEntityDetailReqDTO request) {
        _logger.Info("[System Layer]-Initiating Get Entity Detail");
        HttpResponseSnapshot response = await GetEntityDetailFromDownstream(request);
        if (!response.IsSuccessStatusCode) throw new DownStreamApiFailureException(statusCode: (HttpStatusCode)response.StatusCode, error: ErrorConstants.GET_ENTITY_FAILURE, errorDetails: [$"Response: {response.Content}"], stepName: "GetEntityDetailHandler.cs / HandleAsync");
        else {
            GetEntityDetailApiResDTO? apiResponse = RestApiHelper.DeserializeJsonResponse<GetEntityDetailApiResDTO>(response.Content!);
            if (apiResponse == null || apiResponse.Items.Count < 1) throw new NotFoundException(ErrorConstants.NO_ENTITY_FOUND, ["No details found"], "GetEntityDetailHandler.cs / HandleAsync");
            else {
                _logger.Info("[System Layer]-Completed"); 
                return new BaseResponseDTO(message: InfoConstants.GET_ENTITY_SUCCESS, data: GetEntityDetailResDTO.Map(apiResponse), errorCode: null);
            }
        }
    }
    
    private async Task<HttpResponseSnapshot> GetEntityDetailFromDownstream(GetEntityDetailReqDTO request) {
        GetEntityDetailHandlerReqDTO atomicRequest = new GetEntityDetailHandlerReqDTO { EntityId = request.EntityId };
        return await _getEntityDetailAtomicHandler.Handle(atomicRequest);
    }
}
```

## 3. MANDATORY RULES (16 Core)
1. Name ends with `Handler` | 2. Implements `IBaseHandler<TRequest>` where TRequest : IRequestSysDTO | 3. Inject Atomic Handlers + ILogger via constructor | 4. Orchestrate Atomic Handlers (call 1+) | 5. Check `IsSuccessStatusCode` after each call | 6. Throw `DownStreamApiFailureException` for failed calls | 7. Throw `NotFoundException` when data not found | 8. Deserialize with `*ApiResDTO` classes | 9. Map `ApiResDTO` to `ResDTO` before return | 10. Return `BaseResponseDTO` | 11. Log start/completion | 12. Location: `Implementations/<Vendor>/Handlers/` | 13. Method name: `HandleAsync` | 14. **üî¥ CRITICAL: Every `if` statement MUST have an explicit `else` clause** (no standalone if statements) | 15. **üî¥ CRITICAL: Empty else blocks are FORBIDDEN** (else block MUST contain meaningful code/logic, not just comments - only allowed in very rare cases with explicit justification) | 16. **üî¥ CRITICAL: Each atomic handler call MUST be in a private method** that takes Handler DTO as input, transforms to Atomic Handler DTO, and returns `HttpResponseSnapshot`

## 4. HANDLER ORCHESTRATION RULES (‚ö†Ô∏è CRITICAL)

### Key Principles
‚úÖ **Only create Azure Functions Process Layer calls** | ‚úÖ **Internal operations = Atomic Handlers (NOT Functions)** | ‚úÖ **Handlers orchestrate Atomic Handlers internally** | ‚úÖ **One Function can have multiple Atomic Handlers**

### üî¥ CRITICAL RULE: Same SOR vs Cross-SOR Business Decisions

**Same SOR Business Decisions ‚Üí System Layer Handler Orchestrates:**
- ‚úÖ **If entity exists in SOR-1, check status in SOR-1, then create in SOR-1** ‚Üí Handler orchestrates internally with simple if/else
- ‚úÖ **If status=X in SOR-1, do Y in SOR-1** ‚Üí Handler orchestrates internally (same SOR)
- ‚úÖ **If condition A in SOR-1, call B in SOR-1 else call C in SOR-1** ‚Üí Handler orchestrates internally (all operations same SOR)
- ‚úÖ **Check-before-create pattern (same SOR)** ‚Üí Handler orchestrates: check ‚Üí if not exists ‚Üí create
- ‚úÖ **Simple flag checks (same SOR)** ‚Üí Handler orchestrates: if flag ‚Üí do X

**Cross-SOR Business Decisions ‚Üí Process Layer Orchestrates:**
- ‚ùå **If entity exists in SOR-1, call SOR-2** ‚Üí Process Layer orchestrates (calls System Layer Function for SOR-1, then System Layer Function for SOR-2)
- ‚ùå **If status=X in SOR-1, update in SOR-2** ‚Üí Process Layer orchestrates (cross-SOR decision)
- ‚ùå **If condition A spans SORs, call B in SOR-1 else call C in SOR-2** ‚Üí Process Layer orchestrates (different SORs)

**Rule:** Same SOR = Handler orchestration | Cross-SOR = Process Layer orchestration

### When Orchestration ALLOWED (Handler orchestrates internally)
1. ‚úÖ Same SOR (all operations same System Layer) | 2. ‚úÖ Simple Business Logic (simple retrieval, aggregation, field mapping, simple if/else for same-SOR operations) | 3. ‚úÖ Simple Conditional Rules - Allowed: null checks, empty string checks, check-before-create (if exists skip, if not exists create), simple flag checks (if X do Y) - Same SOR only | 4. ‚úÖ Simple Transformations (calculations, format conversions, field extraction) | 5. ‚úÖ Internal Orchestration (Handler calls Atomic Handlers internally, NOT separate Functions) | 6. ‚úÖ **Simple Sequential Calls** - Fixed sequence of calls (call API-1, then API-2, then API-3 - no iteration, no loops, fixed number of calls) - Same SOR only

### When Orchestration FORBIDDEN (Process Layer orchestrates)
1. ‚ùå Different SORs (operations belong to different System Layers) - **System Layer NEVER calls another System Layer** | 2. ‚ùå Complex Business Logic (multi-step workflows, cross-SOR decisions, complex validations, policy enforcement, state machines, multi-entity orchestration across SORs) | 3. ‚ùå **Looping/Iteration Patterns** - Any loop/iteration/foreach over multiple API calls (for each item in list, call API; for each entity, process; iterate over collection and call multiple APIs) ‚Üí **Process Layer orchestrates** (even if all APIs are same SOR - this is business logic, NOT simple sequential orchestration)

### Example 1: ALLOWED (Same SOR, Simple Aggregation)
```csharp
public class CreateEntityHandler : IBaseHandler<CreateEntityReqDTO> {
    private readonly GetEntityTypeAtomicHandler _getType;
    private readonly GetCategoryAtomicHandler _getCategory;
    private readonly CreateEntityAtomicHandler _create;
    
    public async Task<BaseResponseDTO> HandleAsync(CreateEntityReqDTO request) {
        HttpResponseSnapshot typeResp = await GetEntityTypeFromDownstream(request);
        if (!typeResp.IsSuccessStatusCode) throw new DownStreamApiFailureException(...);
        else {
            EntityTypeApiResDTO? typeData = RestApiHelper.DeserializeJsonResponse<EntityTypeApiResDTO>(typeResp.Content);
            HttpResponseSnapshot catResp = await GetCategoryFromDownstream(request);
            if (!catResp.IsSuccessStatusCode) throw new DownStreamApiFailureException(...);
            else {
                CategoryApiResDTO? catData = RestApiHelper.DeserializeJsonResponse<CategoryApiResDTO>(catResp.Content);
                HttpResponseSnapshot createResp = await CreateEntityInDownstream(request, typeData.TypeId, catData.CategoryId);
                if (!createResp.IsSuccessStatusCode) throw new DownStreamApiFailureException(...);
                else {
                    CreateEntityApiResDTO? apiResp = RestApiHelper.DeserializeJsonResponse<CreateEntityApiResDTO>(createResp.Content);
                    return new BaseResponseDTO(message: InfoConstants.CREATE_ENTITY_SUCCESS, data: CreateEntityResDTO.Map(apiResp));
                }
            }
        }
    }
    
    private async Task<HttpResponseSnapshot> GetEntityTypeFromDownstream(CreateEntityReqDTO request) {
        GetEntityTypeHandlerReqDTO atomicRequest = new GetEntityTypeHandlerReqDTO { TypeCode = request.TypeCode };
        return await _getType.Handle(atomicRequest);
    }
    
    private async Task<HttpResponseSnapshot> GetCategoryFromDownstream(CreateEntityReqDTO request) {
        GetCategoryHandlerReqDTO atomicRequest = new GetCategoryHandlerReqDTO { CategoryCode = request.CategoryCode };
        return await _getCategory.Handle(atomicRequest);
    }
    
    private async Task<HttpResponseSnapshot> CreateEntityInDownstream(CreateEntityReqDTO request, int entityTypeId, int categoryId) {
        CreateEntityHandlerReqDTO atomicRequest = new CreateEntityHandlerReqDTO { EntityTypeId = entityTypeId, CategoryId = categoryId };
        return await _create.Handle(atomicRequest);
    }
}
```

### Example 2: ALLOWED (Same SOR, Check-Before-Create Pattern)
```csharp
public class CreateEntityHandler : IBaseHandler<CreateEntityReqDTO> {
    private readonly GetEntityByIdAtomicHandler _getEntity;
    private readonly GetLookupDataAAtomicHandler _getLookupA;
    private readonly GetLookupDataBAtomicHandler _getLookupB;
    private readonly CreateEntityAtomicHandler _createEntity;
    
    public async Task<BaseResponseDTO> HandleAsync(CreateEntityReqDTO request) {
        HttpResponseSnapshot checkResp = await GetEntityByIdFromDownstream(request);
        if (!checkResp.IsSuccessStatusCode) throw new DownStreamApiFailureException(...);
        else {
            EntityApiResDTO? existing = RestApiHelper.DeserializeJsonResponse<EntityApiResDTO>(checkResp.Content);
            if (!string.IsNullOrEmpty(existing?.EntityId)) {
                return new BaseResponseDTO(message: InfoConstants.ENTITY_EXISTS, data: EntityResDTO.Map(existing));
            } else {
                HttpResponseSnapshot lookupAResp = await GetLookupDataAFromDownstream(request);
                if (!lookupAResp.IsSuccessStatusCode) throw new DownStreamApiFailureException(...);
                else {
                    LookupDataAApiResDTO? lookupA = RestApiHelper.DeserializeJsonResponse<LookupDataAApiResDTO>(lookupAResp.Content);
                    HttpResponseSnapshot lookupBResp = await GetLookupDataBFromDownstream(request);
                    if (!lookupBResp.IsSuccessStatusCode) throw new DownStreamApiFailureException(...);
                    else {
                        LookupDataBApiResDTO? lookupB = RestApiHelper.DeserializeJsonResponse<LookupDataBApiResDTO>(lookupBResp.Content);
                        HttpResponseSnapshot createResp = await CreateEntityInDownstream(request, lookupA.LookupId, lookupB.LookupId);
                        if (!createResp.IsSuccessStatusCode) throw new DownStreamApiFailureException(...);
                        else {
                            CreateEntityApiResDTO? apiResp = RestApiHelper.DeserializeJsonResponse<CreateEntityApiResDTO>(createResp.Content);
                            return new BaseResponseDTO(message: InfoConstants.CREATE_ENTITY_SUCCESS, data: EntityResDTO.Map(apiResp));
                        }
                    }
                }
            }
        }
    }
    
    private async Task<HttpResponseSnapshot> GetEntityByIdFromDownstream(CreateEntityReqDTO request) {
        GetEntityByIdHandlerReqDTO atomicRequest = new GetEntityByIdHandlerReqDTO { EntityId = request.EntityId };
        return await _getEntity.Handle(atomicRequest);
    }
    
    private async Task<HttpResponseSnapshot> GetLookupDataAFromDownstream(CreateEntityReqDTO request) {
        GetLookupDataAHandlerReqDTO atomicRequest = new GetLookupDataAHandlerReqDTO { Code = request.LookupCodeA };
        return await _getLookupA.Handle(atomicRequest);
    }
    
    private async Task<HttpResponseSnapshot> GetLookupDataBFromDownstream(CreateEntityReqDTO request) {
        GetLookupDataBHandlerReqDTO atomicRequest = new GetLookupDataBHandlerReqDTO { Code = request.LookupCodeB };
        return await _getLookupB.Handle(atomicRequest);
    }
    
    private async Task<HttpResponseSnapshot> CreateEntityInDownstream(CreateEntityReqDTO request, int lookupIdA, int lookupIdB) {
        CreateEntityHandlerReqDTO atomicRequest = new CreateEntityHandlerReqDTO { EntityId = request.EntityId, LookupIdA = lookupIdA, LookupIdB = lookupIdB };
        return await _createEntity.Handle(atomicRequest);
    }
}
```

### Example 3: ALLOWED (Same SOR, Simple Flag Check)
```csharp
public class CreateItemHandler : IBaseHandler<CreateItemReqDTO> {
    private readonly CreateItemAtomicHandler _createItem;
    private readonly LinkRelatedEntityAtomicHandler _linkRelated;
    
    public async Task<BaseResponseDTO> HandleAsync(CreateItemReqDTO request) {
        HttpResponseSnapshot itemResp = await CreateItemInDownstream(request);
        if (!itemResp.IsSuccessStatusCode) throw new DownStreamApiFailureException(...);
        else {
            ItemApiResDTO? item = RestApiHelper.DeserializeJsonResponse<ItemApiResDTO>(itemResp.Content);
            if (request.ShouldLinkRelated) {
                HttpResponseSnapshot linkResp = await LinkRelatedEntityInDownstream(item.ItemId);
                if (!linkResp.IsSuccessStatusCode) throw new DownStreamApiFailureException(...);
                else {
                    LinkRelatedEntityApiResDTO? linkResult = RestApiHelper.DeserializeJsonResponse<LinkRelatedEntityApiResDTO>(linkResp.Content);
                    if (linkResult == null || !linkResult.IsLinked) {
                        throw new BusinessCaseFailureException(ErrorConstants.LINK_FAILED, ["Failed to link related entity"], "CreateItemHandler.cs / HandleAsync");
                    }
                }
            } else {
                _logger.Info("Skipping related entity linking as per request flag");
            }
            return new BaseResponseDTO(message: InfoConstants.CREATE_ITEM_SUCCESS, data: ItemResDTO.Map(item));
        }
    }
    
    private async Task<HttpResponseSnapshot> CreateItemInDownstream(CreateItemReqDTO request) {
        CreateItemHandlerReqDTO atomicRequest = new CreateItemHandlerReqDTO { ItemData = request.ItemData };
        return await _createItem.Handle(atomicRequest);
    }
    
    private async Task<HttpResponseSnapshot> LinkRelatedEntityInDownstream(int itemId) {
        LinkRelatedEntityHandlerReqDTO atomicRequest = new LinkRelatedEntityHandlerReqDTO { ItemId = itemId };
        return await _linkRelated.Handle(atomicRequest);
    }
}
```

### Decision Matrix
| Operation Type | Process Layer Needs? | Azure Function? | Atomic Handler? | Orchestrated By | Simple If/Else Allowed? |
|----------------|---------------------|-----------------|-----------------|-----------------|------------------------|
| Main Operation (Process Layer calls) | ‚úÖ YES | ‚úÖ YES | ‚úÖ YES | Handler (same SL) | ‚úÖ YES (same SOR only) |
| Internal Operation (only for same-SOR) | ‚ùå NO | ‚ùå NO | ‚úÖ YES | Handler (same SL) | ‚úÖ YES (same SOR only) |
| Lookup (get IDs/codes, same SOR) | ‚ùå NO | ‚ùå NO | ‚úÖ YES | Handler (same SL) | ‚úÖ YES (same SOR only) |
| Check-Before-Create (same SOR) | ‚ùå NO | ‚ùå NO | ‚úÖ YES | Handler (same SL) | ‚úÖ YES (if exists skip, if not create) |
| Simple Flag Check (same SOR) | ‚ùå NO | ‚ùå NO | ‚úÖ YES | Handler (same SL) | ‚úÖ YES (if flag do X) |
| Cross-SOR Operation (different SL) | ‚úÖ YES | ‚úÖ YES | ‚úÖ YES | **Process Layer** | ‚ùå NO (PL orchestrates) |

### Examples
**Same SOR (1 Function):** CreateEntity needs TypeID+CategoryID (all SOR-1) ‚Üí Create: CreateEntityAPI (Function), CreateEntityHandler (orchestrates GetTypeAtomicHandler+GetCategoryAtomicHandler+CreateEntityAtomicHandler) ‚Üí DON'T Create: GetTypeAPI/GetCategoryAPI (internal)

**Same SOR with Check-Before-Create (1 Function):** CreateEntity checks existence first (all SOR-1) ‚Üí Create: CreateEntityAPI (Function), CreateEntityHandler (orchestrates GetEntityByIdAtomicHandler [check] + if not exists ‚Üí GetLookupDataAAtomicHandler + GetLookupDataBAtomicHandler + CreateEntityAtomicHandler) ‚Üí DON'T Create: GetEntityByIdAPI (internal check)

**Same SOR with Flag Check (1 Function):** CreateItem creates item + conditionally links related entity (all SOR-1) ‚Üí Create: CreateItemAPI (Function), CreateItemHandler (orchestrates CreateItemAtomicHandler + if flag=true ‚Üí LinkRelatedEntityAtomicHandler) ‚Üí DON'T Create: LinkRelatedEntityAPI (internal conditional)

**Different SORs (2 Functions):** CreateEntity (SOR-1) needs Category (SOR-2) ‚Üí Create in SOR-1: CreateEntityAPI+Handler+AtomicHandler | Create in SOR-2: GetCategoryAPI+Handler+AtomicHandler | Process Layer orchestrates both ‚Üí DON'T call SOR-2 from SOR-1 (FORBIDDEN)

## 5. FUNCTION EXPOSURE DECISION PROCESS (‚ö†Ô∏è MANDATORY - BLOCKING)

### ‚õî STEP 1: Create Decision Table (BLOCKING)
| Operation | Independent Invoke? | Decision Before/After? | Same SOR? | Internal Lookup? | Conclusion | Reasoning |
|-----------|---------------------|------------------------|-----------|------------------|------------|-----------|
| Login | NO | None | N/A | N/A | Atomic (MW) | Auth only |
| Op A | ? | ? | ? | ? | ? | ? |

### STEP 2: Answer 5 Questions (EACH Operation)
**Q1:** Can Process Layer invoke independently? NO ‚Üí **Atomic (internal)** | YES ‚Üí Q2
**Q2:** Decision/conditional logic present? YES ‚Üí Q2a | NO ‚Üí Q3
**Q2a:** Is decision same SOR (all operations in if/else same System Layer)? YES ‚Üí **Handler orchestrates internally (1 Function)** | NO (cross-SOR) ‚Üí **Separate Functions (PL orchestrates)**
**Q3:** Only field extraction/lookup for another operation? YES ‚Üí **Atomic (internal)** | NO ‚Üí Q4
**Q4:** Complete business operation Process Layer needs? YES ‚Üí **Azure Function** | NO ‚Üí **Atomic (internal)**

### Simple If/Else Rules
**üî¥ CRITICAL RULE 1:** Every `if` statement in Handlers MUST have an explicit `else` clause. No standalone `if` statements allowed.
- ‚úÖ **CORRECT:** `if (condition) { ... } else { ... }` (else block contains meaningful code)
- ‚ùå **WRONG:** `if (condition) { ... }` (missing else)
- ‚ùå **WRONG:** `if (condition) { ... } else { }` (empty else block - only allowed in very rare cases with explicit justification)

**üî¥ CRITICAL RULE 1a:** Empty else blocks are FORBIDDEN except in very rare cases where explicitly justified. The else block MUST contain meaningful code/logic, not just comments.
- ‚úÖ **CORRECT:** `if (condition) { doA(); } else { doB(); }` (both branches have logic)
- ‚ùå **WRONG:** `if (condition) { doA(); } else { // no action }` (empty else with only comment)
- ‚ö†Ô∏è **RARE EXCEPTION:** Empty else allowed only when explicitly documented why no action is needed AND alternative structure would be less readable

**üî¥ CRITICAL RULE 2:** Each call to downstream API via atomic handler MUST be separated into a private method that:
- Takes Handler DTO as input parameter
- Transforms Handler DTO to Atomic Handler DTO
- Returns `HttpResponseSnapshot`
- Resides in the Handler class

**Example Pattern:**
```csharp
private async Task<HttpResponseSnapshot> GetEntityFromDownstream(GetEntityReqDTO request) {
    // Transform Handler DTO to Atomic Handler DTO
    GetEntityHandlerReqDTO atomicRequest = new GetEntityHandlerReqDTO { 
        EntityId = request.EntityId 
    };
    return await _getEntityAtomicHandler.Handle(atomicRequest);
}
```

**Note:** This rule applies to all conditional logic in Handlers, including:
- Business logic conditionals (if exists ‚Üí return, else ‚Üí create)
- Flag checks (if flag ‚Üí do X, else ‚Üí skip)
- Status checks (if status=X ‚Üí do Y, else ‚Üí do Z)
- Guard clauses that throw exceptions should also follow this pattern when possible, or use early returns with explicit else blocks

**ALLOWED:** Check-before-create (if exists skip, if not create), simple flag checks (if X do Y), null/empty checks - Same SOR operations only
**FORBIDDEN:** Cross-SOR decisions (if SOR-1 exists, call SOR-2) - Process Layer orchestrates

### STEP 3: Verification (7 Questions - ALL YES or N/A)
1. ‚ùì Identified ALL decision points? | 2. ‚ùì WHERE each decision belongs? | 3. ‚ùì "if X exists, skip Y" checked? | 4. ‚ùì "if flag=X, do Y" checked? | 5. ‚ùì Can explain WHY each operation type? | 6. ‚ùì Avoided pattern-matching? | 7. ‚ùì If 1 Function, NO decision shapes?

### STEP 4: Summary (MANDATORY)
"I will create [NUMBER] Azure Functions for [SOR_NAME]: [Names]. Because [DECISION_POINTS]. Per Rule 1066, business decisions ‚Üí Process Layer when [WHY]. Functions: [PURPOSES]. Internal: [ATOMIC_LIST]. Auth: [METHOD]."

### Example Table 1: Cross-SOR Pattern (Process Layer Orchestrates)
| Operation | Independent? | Decision? | Same SOR? | Lookup? | Conclusion | Reasoning |
|-----------|--------------|-----------|-----------|---------|------------|-----------|
| QueryTaskExists (SOR-1) | YES | YES (AFTER) | N/A | NO | **Function** | PL decides skip/proceed (cross-SOR decision) |
| GetCategory (SOR-2) | YES | None | NO (SOR-2) | NO | **Function** | Different SOR (PL orchestrates) |
| CreateTask (SOR-1) | YES | YES (BEFORE) | N/A | NO | **Function** | PL calls conditionally |
**Analysis:** 3 Functions (Query, GetCategory, Create) | PL orchestrates: Query (SOR-1) ‚Üí GetCategory (SOR-2) ‚Üí (if not exists) ‚Üí Create (SOR-1)

### Example Table 2: Same SOR Pattern (Handler Orchestrates with Simple If/Else)
| Operation | Independent? | Decision? | Same SOR? | Lookup? | Conclusion | Reasoning |
|-----------|--------------|-----------|-----------|---------|------------|-----------|
| GetEntityById | NO | None | YES (SOR-1) | YES - check | Atomic | Internal check (same SOR) |
| GetLookupDataA | NO | None | YES (SOR-1) | YES - enrich | Atomic | Internal lookup (same SOR) |
| GetLookupDataB | NO | None | YES (SOR-1) | YES - enrich | Atomic | Internal lookup (same SOR) |
| CreateEntity | YES | YES (check-before-create) | YES (SOR-1) | NO | **Function** | Handler orchestrates: check ‚Üí if not exists ‚Üí enrich ‚Üí create (all same SOR) |
| LinkRelatedEntity | NO | YES (flag check) | YES (SOR-1) | NO | Atomic | Internal conditional (same SOR, if flag=true) |
**Analysis:** 1 Function (CreateEntity) | 4 Atomic (GetEntityById, GetLookupDataA, GetLookupDataB, LinkRelatedEntity) | Handler orchestrates internally with simple if/else (all same SOR)

### Common Patterns

**Check-Before-Create (Same SOR - Handler Orchestrates):**
- Ops: GetEntityById (check), GetLookupDataA (enrich), GetLookupDataB (enrich), CreateEntity (create), LinkRelatedEntity (conditional)
- Decision: "if exists skip, if not exists ‚Üí enrich ‚Üí create" + "if flag ‚Üí link"
- Functions: **1** (CreateEntity)
- Reasoning: All operations same SOR ‚Üí Handler orchestrates internally with simple if/else

**Field Chaining (Same SOR - Handler Orchestrates):**
- Ops: GetTypeId, GetCategoryId, Create
- Decision: None
- Functions: **1** (Create orchestrates internally)
- Reasoning: Pure field extraction, same SOR

**Conditional Flag (Same SOR - Handler Orchestrates):**
- Ops: CreateItem, LinkRelatedEntity
- Decision: "if flag, link"
- Functions: **1** (CreateItem orchestrates internally)
- Reasoning: Simple flag check, same SOR ‚Üí Handler handles internally

**Cross-SOR (Process Layer Orchestrates):**
- Ops: GetCategory(SOR-1), CreateEntity(SOR-2)
- Functions: **2** (one per SOR)
- Reasoning: Different SORs ‚Üí SL NEVER calls another SL ‚Üí PL orchestrates

**Complex Business Logic (Process Layer Orchestrates):**
- Ops: QueryExists (SOR-1), Validate (SOR-1), GetCategory (SOR-2), CreateEntity (SOR-1)
- Decision: Multi-step workflow with validations
- Functions: **3+**
- Reasoning: Complex logic or cross-SOR ‚Üí PL orchestrates

**Looping/Iteration Pattern (Process Layer Orchestrates):**
- Ops: For each item in list, call CreateEntity API (same SOR-1); For each entity, process and call UpdateEntity API (same SOR-1)
- Decision: Loop/iteration over collection, call multiple APIs
- Functions: **1 per operation** (CreateEntity, UpdateEntity) - Process Layer loops and calls each
- Reasoning: **Looping/iteration = Business logic** ‚Üí Process Layer orchestrates (even if all APIs same SOR - this is NOT simple sequential orchestration, it's business logic for processing collections/batches)

### Anti-Patterns (FORBIDDEN)
‚ùå **Function Explosion:** Creating GetTypeId+GetCategoryId+CreateTask as 3 Functions ‚Üí ‚úÖ CORRECT: CreateTask Function orchestrates GetTypeId+GetCategoryId Atomic Handlers internally (same SOR)

‚ùå **Separate Functions for Same-SOR Check:** Creating GetEntityById Function + CreateEntity Function when both same SOR ‚Üí ‚úÖ CORRECT: CreateEntity Function orchestrates GetEntityById Atomic Handler internally with if/else (same SOR)

‚ùå **Separate Functions for Same-SOR Flag Checks:** Creating CreateItem Function + LinkRelatedEntity Function when both same SOR ‚Üí ‚úÖ CORRECT: CreateItem Function orchestrates LinkRelatedEntity Atomic Handler internally with if flag (same SOR)

‚ùå **Auth Functions:** Login/Logout as Functions ‚Üí ‚úÖ CORRECT: Atomic Handlers for middleware

‚ùå **Cross-SOR in SL:** SalesforceHandler calls DynamicsSystemLayer ‚Üí ‚úÖ CORRECT: Process Layer calls both separately

‚ùå **Cross-SOR Decision in Handler:** Handler checks SOR-1, then calls SOR-2 based on result ‚Üí ‚úÖ CORRECT: Process Layer orchestrates both SORs separately

‚ùå **Looping/Iteration in Handler:** Handler loops over items and calls multiple APIs (for each item, call API; foreach entity, process) ‚Üí ‚úÖ CORRECT: Process Layer orchestrates looping (even if all APIs same SOR - this is business logic, not simple sequential orchestration)

## 6. ERROR HANDLING (MANDATORY)

### Exception Flow
**Flow:** AtomicHandler (returns HttpResponseSnapshot, NEVER throws) ‚Üí Handler (checks status, throws domain exceptions) ‚Üí Middleware (catches, normalizes to BaseResponseDTO) ‚Üí Client (receives BaseResponseDTO)
**Visual:** `await _httpClient.SendAsync() ‚Üí HttpResponseSnapshot(200/400/500)` ‚Üí `if (!IsSuccessStatusCode) throw DownStreamApiFailureException` ‚Üí `catch (ex) ‚Üí BaseResponseDTO` ‚Üí `Client receives error`

### Check Status
```csharp
HttpResponseSnapshot response = await _atomicHandler.Handle(request);
if (!response.IsSuccessStatusCode) { _logger.Error($"Failed: {response.StatusCode}"); throw new DownStreamApiFailureException(statusCode: (HttpStatusCode)response.StatusCode, error: ErrorConstants.OPERATION_FAILURE, errorDetails: [$"Status {response.StatusCode}. Response: {response.Content}"], stepName: "HandlerName.cs / HandleAsync"); }
```

### Handle Null
```csharp
GetEntityApiResDTO? apiResponse = RestApiHelper.DeserializeJsonResponse<GetEntityApiResDTO>(response.Content!);
if (apiResponse == null || apiResponse.Items.Count < 1) throw new NotFoundException(ErrorConstants.NO_ENTITY_FOUND, [$"No entity for ID: {request.EntityId}"], "HandlerName.cs / HandleAsync");
```

### Exception Types (Framework - NEVER Create Custom Exceptions)

**üî¥ CRITICAL:** ALL exceptions defined in `Core.Exceptions` and `Core.SystemLayer.Exceptions` | NEVER create project/vendor-specific exceptions

| Exception | When to Throw | HTTP Status | Constructor Params | Where Used |
|-----------|--------------|-------------|-------------------|------------|
| **RequestValidationFailureException** | Request validation fails (missing fields, invalid format, bad input) | 400 | `errorDetails: List<string>, stepName` (DTOs use Core Framework default error) OR `error: (code, msg), errorDetails: List<string>, stepName` (Handlers/Functions may use custom error) | Functions, Handlers, DTOs |
| **NoRequestBodyException** | Incoming request has no body (null/empty POST/PUT) | 400 | `errorDetails: List<string>, stepName` | Functions (after deserialization) |
| **NotFoundException** | Resource not found (record doesn't exist, query returns empty) | 404 | `error: (code, msg), errorDetails: List<string>, stepName` | Handlers (after query) |
| **BusinessCaseFailureException** | Business rule violated (duplicate record, state conflict, invalid operation) | 409/422 | `error: (code, msg), errorDetails: List<string>, stepName` | Handlers, Services |
| **NoResponseBodyException** | Downstream returns success but empty/no body | 500 | `errorDetails: List<string>, stepName` | Handlers (after API call) |
| **DownStreamApiFailureException** | External API call fails (non-2xx status, timeout, connection failure) | Varies (from API) | `statusCode: HttpStatusCode, error: (code, msg), errorDetails: List<string>, stepName` | Handlers (after AtomicHandler) |

### Decision Tree - Which Exception to Throw?

**Is it a request validation issue?** ‚Üí `RequestValidationFailureException`  
**Is the request body missing/null?** ‚Üí `NoRequestBodyException`  
**Is a resource/record not found?** ‚Üí `NotFoundException`  
**Is a business rule violated?** ‚Üí `BusinessCaseFailureException`  
**Did downstream API fail?** ‚Üí `DownStreamApiFailureException`  
**Did downstream return empty body?** ‚Üí `NoResponseBodyException`

### Complete Examples by Exception Type

**1. RequestValidationFailureException (400 - Validation Errors)**
```csharp
// Pattern 1: Simple (in ValidateAPIRequestParameters())
if (string.IsNullOrWhiteSpace(EntityId)) throw new RequestValidationFailureException(
    errorDetails: ["EntityId is required"],
    stepName: "GetEntityReqDTO.cs / Executing ValidateAPIRequestParameters"
);
// Pattern 2: Detailed (collect all errors)
List<string> errors = new List<string>(); if (string.IsNullOrWhiteSpace(EntityId)) errors.Add("EntityId required"); if (!Email.Contains("@")) errors.Add("Invalid email"); if (errors.Count > 0) throw new RequestValidationFailureException(
    errorDetails: errors,
    stepName: "GetEntityReqDTO.cs / Executing ValidateAPIRequestParameters"
);
```

**2. NoRequestBodyException (400 - Missing Request Body)**
```csharp
// In Function after deserialization
GetEntityReqDTO? request = await RestApiHelper.DeserializeHttpRequestAsync<GetEntityReqDTO>(req); if (request == null) throw new NoRequestBodyException(errorDetails: ["Request body is missing or empty"], stepName: "GetEntityAPI.cs / Run");
```

**3. NotFoundException (404 - Resource Not Found)**
```csharp
// After API call returns empty/null
GetEntityApiResDTO? apiResponse = RestApiHelper.DeserializeJsonResponse<GetEntityApiResDTO>(response.Content!); if (apiResponse == null || apiResponse.Items.Count < 1) throw new NotFoundException(error: ErrorConstants.NO_ENTITY_FOUND, errorDetails: [$"No entity for ID: {request.EntityId}"], stepName: "GetEntityHandler.cs / HandleAsync");
```

**4. BusinessCaseFailureException (409/422 - Business Rule Violation)**
```csharp
// Duplicate check, state validation
if (existingRecord != null) throw new BusinessCaseFailureException(error: ErrorConstants.DUPLICATE_RECORD, errorDetails: [$"Entity {request.EntityId} already exists"], stepName: "CreateEntityHandler.cs / HandleAsync");
```

**5. NoResponseBodyException (500 - Empty Downstream Response)**
```csharp
// API returns 200 but empty body
if (response.IsSuccessStatusCode && string.IsNullOrWhiteSpace(response.Content)) throw new NoResponseBodyException(errorDetails: [$"API {apiUrl} returned empty response"], stepName: "GetEntityHandler.cs / HandleAsync");
```

**6. DownStreamApiFailureException (Varies - Downstream API Failure)**
```csharp
// After Atomic Handler call
HttpResponseSnapshot response = await _atomicHandler.Handle(request); if (!response.IsSuccessStatusCode) { _logger.Error($"Failed: {response.StatusCode}"); throw new DownStreamApiFailureException(statusCode: (HttpStatusCode)response.StatusCode, error: ErrorConstants.OPERATION_FAILURE, errorDetails: [$"API failed. Status: {response.StatusCode}. Response: {response.Content}"], stepName: "GetEntityHandler.cs / HandleAsync"); }
```

### Exception Handling Rules
‚úÖ **DO:** Use framework exceptions | Include stepName (ClassName.cs / MethodName) | Collect all validation errors before throwing | Log before throwing (Handler level) | Let middleware catch exceptions  
‚ùå **DON'T:** Create custom exceptions | Catch and swallow | Throw generic Exception | Return exception details to client | Forget stepName parameter

## 7. RESPONSE TRANSFORMATION (MANDATORY)

### Deserialize + Map
```csharp
// ‚úÖ Deserialize external API response to ApiResDTO
GetEntityDetailApiResDTO? apiResponse = RestApiHelper.DeserializeJsonResponse<GetEntityDetailApiResDTO>(response.Content!);
// ‚úÖ Map ApiResDTO to ResDTO before returning
return new BaseResponseDTO(message: InfoConstants.GET_ENTITY_SUCCESS, data: GetEntityDetailResDTO.Map(apiResponse), errorCode: null);
```

### Rules
1. **NEVER return `ApiResDTO` directly in BaseResponseDTO.Data** | 2. **ALWAYS deserialize external responses into `ApiResDTO`** | 3. **ALWAYS map `ApiResDTO` to `ResDTO` before return** | 4. `ResDTO` MUST have static `Map()` method

## 8. HANDLER DTO REQUIREMENTS

### Request DTO (IRequestSysDTO)
```csharp
using Core.SystemLayer.DTOs;
public class GetEntityDetailReqDTO : IRequestSysDTO {
    public string EntityId { get; set; } = string.Empty; public bool IncludeDetails { get; set; }
    public void ValidateAPIRequestParameters() {
        if (string.IsNullOrWhiteSpace(EntityId))
            throw new RequestValidationFailureException(
                errorDetails: ["EntityId is required"],
                stepName: "GetEntityDetailReqDTO.cs / Executing ValidateAPIRequestParameters"
            );
    }
}
```
**Location:** `DTO/<Entity>DTO/`

### Response DTO (ResDTO with Map)
```csharp
public class GetEntityDetailResDTO {
    public string EntityId { get; set; } = string.Empty; public string EntityName { get; set; } = string.Empty; public string Status { get; set; } = string.Empty;
    public static GetEntityDetailResDTO Map(GetEntityDetailApiResDTO apiResponse) => new() { EntityId = apiResponse.Id ?? "", EntityName = apiResponse.Name ?? "", Status = apiResponse.StatusCode ?? "Unknown" };
}
```
**Location:** `DTO/<Entity>DTO/`

## 9. LOGGING (MANDATORY)

### Use Core.Extensions Only
```csharp
using Core.Extensions;  // ‚Üê REQUIRED
_logger.Info("[System Layer]-Initiating Get Entity"); _logger.Info($"EntityId: {request.EntityId}"); _logger.Error(ex, "Failed"); _logger.Warn("Retrying");
```

### Pattern
```csharp
public async Task<BaseResponseDTO> HandleAsync(GetEntityReqDTO request) {
    _logger.Info("[System Layer]-Initiating Get Entity"); // ‚úÖ Log start
    // ... logic ...
    _logger.Info("[System Layer]-Completed Get Entity"); // ‚úÖ Log completion
    return new BaseResponseDTO(...);
}
```

### Error Logging
```csharp
if (!response.IsSuccessStatusCode) { _logger.Error($"Failed: {response.StatusCode}"); throw new DownStreamApiFailureException(...); }
// ‚ùå NEVER use try-catch - exception handling managed at middleware level
```

### Forbidden
‚ùå DON'T use `_logger.LogInformation()` (use `_logger.Info()`) | ‚ùå DON'T use `_logger.LogError()` (use `_logger.Error()`) | ‚ùå DON'T use `Console.WriteLine()` | ‚ùå DON'T create custom wrappers

## 10. CACHING SUPPORT (OPTIONAL)

**Framework Reference:** Look at `Framework/Cache/Handlers/ICacheableHandler.cs` for implementation.

### When to Use Caching in Handlers
‚úÖ **Use Caching When:**
- Same data requested multiple times (repeated calls with same params)
- External API has high latency (slow downstream response)
- Data changes infrequently (static/semi-static master data)
- Read-only operations (GET requests only)
- Reference data or lookup operations (entity types, categories, LOVs)

‚ùå **DON'T Use Caching When:**
- Data must be real-time or near real-time (live transactional data)
- Write operations (POST, PUT, DELETE, PATCH - NEVER cache writes)
- Transactional data with strict consistency (financial, audit trails)
- Audit trail required for every access (security, compliance)
- Data changes frequently (high-frequency updates)

### ICacheableHandler<T> Pattern
```csharp
using Cache.DTO; using Cache.Handlers; using Cache.Key; using Core.DTOs; using Core.Extensions; using Core.SystemLayer.Handlers; using Core.SystemLayer.DTOs;
public class GetEntityDetailHandler : ICacheableHandler<GetEntityDetailReqDTO> { private readonly ILogger<GetEntityDetailHandler> _logger; private readonly GetEntityDetailAtomicHandler _atomicHandler;
    public GetEntityDetailHandler(ILogger<GetEntityDetailHandler> logger, GetEntityDetailAtomicHandler handler) { _logger = logger; _atomicHandler = handler; }
    public async Task<BaseResponseDTO> HandleAsync(GetEntityDetailReqDTO request) { _logger.Info("[System Layer]-Initiating Get Entity Detail"); GetEntityDetailHandlerReqDTO atomicRequest = new GetEntityDetailHandlerReqDTO { EntityId = request.EntityId }; HttpResponseSnapshot response = await _atomicHandler.Handle(atomicRequest); if (!response.IsSuccessStatusCode) throw new DownStreamApiFailureException(...); GetEntityDetailApiResDTO? apiResponse = RestApiHelper.DeserializeJsonResponse<GetEntityDetailApiResDTO>(response.Content!); _logger.Info("[System Layer]-Completed"); return new BaseResponseDTO(message: InfoConstants.GET_ENTITY_SUCCESS, data: GetEntityDetailResDTO.Map(apiResponse), errorCode: null); }
    // ICacheableHandler<T> provides HandleCacheAsync() default implementation (5min TTL)
}
```

### Usage in Function (Cached Call)
```csharp
[Function("GetEntityDetail")] public async Task<IActionResult> Run([HttpTrigger(AuthorizationLevel.Anonymous, "post")] HttpRequest req) { GetEntityDetailReqDTO? request = await RestApiHelper.DeserializeHttpRequestAsync<GetEntityDetailReqDTO>(req); request?.ValidateAPIRequestParameters(); BaseResponseDTO response = await ((ICacheableHandler<GetEntityDetailReqDTO>)_handler).HandleCacheAsync(request!); return new OkObjectResult(response); }
```

### Rules
1. Handler implements `ICacheableHandler<T>` where T : IRequestSysDTO, ICacheable | 2. *ReqDTO implements `ICacheable` (see DTO section) | 3. Handler-level cache TTL: 5 minutes (default) | 4. Call `HandleCacheAsync()` instead of `HandleAsync()` for cached | 5. DON'T cache write operations | 6. Atomic Handler caching preferred for granular control (see Atomic Handler section)

**Program.cs:** `builder.Services.AddRedisCacheLibrary(builder.Configuration);`  
**appsettings.json:** `"RedisCache": { "ConnectionString": "", "InstanceName": "ProjectName:" }`

## 11. DEPENDENCY INJECTION

### Lifetime Scopes
| Component | Scope | Rationale |
|-----------|-------|-----------|
| Handlers | `AddScoped` | Per-request (new instance per HTTP request, thread-safe) |
| Atomic Handlers | `AddScoped` | Per-request (prevents state sharing) |
| Services | `AddScoped` | Per-request (aligns with per-request model) |
| Configuration | `Configure<T>` | Singleton (loaded once) |
| HTTP Clients | Framework-managed | Core Framework |
| Helpers | `AddSingleton` or `AddScoped` | Depends on state |

### Constructor Injection Rules
‚úÖ ALWAYS constructor injection | ‚úÖ NEVER service locator in business code | ‚úÖ ALWAYS inject interfaces for Services | ‚úÖ Inject CONCRETE classes for Handlers/Atomic Handlers | ‚úÖ ALWAYS `private readonly` fields

### Registration Patterns

**Services: WITH INTERFACES** ‚úÖ
```csharp
builder.Services.AddScoped<IEntityMgmt, EntityMgmtService>(); builder.Services.AddScoped<ITaskMgmt, TaskMgmtService>(); // ‚ùå builder.Services.AddScoped<EntityMgmtService>();
```
**Why:** Abstraction boundary | Enable DI in Functions | Vendor-specific implementations

**Handlers: CONCRETE (NO interfaces)** ‚úÖ
```csharp
builder.Services.AddScoped<GetEntityDetailHandler>(); builder.Services.AddScoped<CreateEntityHandler>(); // ‚ùå builder.Services.AddScoped<IBaseHandler<GetEntityReqDTO>, GetEntityDetailHandler>();
```
**Why:** Vendor-specific | Services inject by concrete type | `IBaseHandler<T>` for typing NOT DI | Each handler unique

**Atomic Handlers: CONCRETE (NO interfaces)** ‚úÖ
```csharp
builder.Services.AddScoped<GetEntityDetailAtomicHandler>(); builder.Services.AddScoped<CreateEntityAtomicHandler>(); builder.Services.AddScoped<AuthenticateAtomicHandler>(); // ‚ùå builder.Services.AddScoped<IAtomicHandler<HttpResponseSnapshot>, GetEntityDetailAtomicHandler>();
```
**Why:** Operation-specific | Handlers inject by concrete type | `IAtomicHandler<T>` for typing NOT DI | Each unique

### Complete Registration Order
```csharp
FunctionsApplicationBuilder builder = FunctionsApplication.CreateBuilder(args);
// 0. Logging (FIRST)
builder.Services.AddApplicationInsightsTelemetryWorkerService().ConfigureFunctionsApplicationInsights(); builder.Logging.AddConsole(); builder.Logging.AddFilter<ApplicationInsightsLoggerProvider>("", LogLevel.Trace);
// 1. Configuration
builder.Services.Configure<AppConfigs>(builder.Configuration.GetSection(AppConfigs.SectionName)); builder.Services.Configure<KeyVaultConfigs>(builder.Configuration.GetSection(KeyVaultConfigs.SectionName));
// 2. Framework Libraries
builder.Services.AddRedisCacheLibrary(builder.Configuration);
// 3. HTTP Clients (auto-registered by Framework)
// 4. Singletons
builder.Services.AddSingleton<KeyVaultReader>();
// 5. Services (WITH INTERFACES)
builder.Services.AddScoped<IEntityMgmt, EntityMgmtService>(); builder.Services.AddScoped<ITaskMgmt, TaskMgmtService>();
// 6. Handlers (CONCRETE)
builder.Services.AddScoped<GetEntityDetailHandler>(); builder.Services.AddScoped<CreateTaskHandler>();
// 7. Atomic Handlers (CONCRETE)
builder.Services.AddScoped<GetEntityDetailAtomicHandler>(); builder.Services.AddScoped<CreateTaskAtomicHandler>(); builder.Services.AddScoped<AuthenticateAtomicHandler>(); builder.Services.AddScoped<LogoutAtomicHandler>();
// 8. Middleware (ORDER MATTERS)
builder.UseMiddleware<ExecutionTimingMiddleware>(); builder.UseMiddleware<ExceptionHandlerMiddleware>(); builder.UseMiddleware<CustomAuthenticationMiddleware>();
// 9. Service Locator (LAST)
ServiceLocator.ServiceProvider = builder.Services.BuildServiceProvider(); builder.Build().Run();
```

## 12. FOLDER STRUCTURE
```
Implementations/<VendorName>/
‚îú‚îÄ‚îÄ Handlers/                                        # FLAT (no subfolders)
‚îÇ   ‚îú‚îÄ‚îÄ GetEntityDetailHandler.cs
‚îÇ   ‚îú‚îÄ‚îÄ CreateEntityHandler.cs
‚îÇ   ‚îî‚îÄ‚îÄ UpdateEntityHandler.cs
‚îî‚îÄ‚îÄ AtomicHandlers/                                  # FLAT structure - NO subfolders
    ‚îú‚îÄ‚îÄ GetEntityDetailAtomicHandler.cs
    ‚îú‚îÄ‚îÄ CreateEntityAtomicHandler.cs
    ‚îî‚îÄ‚îÄ UpdateEntityAtomicHandler.cs
```

## 13. NAMING CONVENTIONS
| Component | Convention | Example |
|-----------|------------|---------|
| Handler File | `<Operation>Handler.cs` | `GetEntityDetailHandler.cs` |
| Handler Class | `<Operation>Handler` | `GetEntityDetailHandler` |
| Handler Method | `HandleAsync` | `HandleAsync(GetEntityDetailReqDTO request)` |
| Request DTO | `<Operation>ReqDTO` | `GetEntityDetailReqDTO` |
| Response DTO | `<Operation>ResDTO` | `GetEntityDetailResDTO` |
| API Response DTO | `<Operation>ApiResDTO` | `GetEntityDetailApiResDTO` |

## 14. DO'S & DON'TS

### ‚úÖ DO
**Function Exposure:** Complete decision table BEFORE Handlers | Answer all 4 questions for each operation | Document reasoning | Verify decision points | Write summary
**Implementation:** Implement `IBaseHandler<TRequest>` | Inject Atomic Handlers via constructor | Orchestrate multiple (same SOR, no logic) | Check `IsSuccessStatusCode` | Throw `DownStreamApiFailureException` for failures | Throw `NotFoundException` for missing data | Deserialize with `ApiResDTO` | Map `ApiResDTO` to `ResDTO` | Log start/completion/errors | Use `Core.Extensions` logging | Return `BaseResponseDTO` | Register `AddScoped<>` concrete | Place in `Implementations/<Vendor>/Handlers/` | Name method `HandleAsync` | Apply "Can PL invoke independently?" test | **üî¥ CRITICAL: Every `if` statement MUST have an explicit `else` clause** | **üî¥ CRITICAL: Else blocks MUST contain meaningful code/logic** (not just comments - empty else blocks forbidden except very rare cases) | **üî¥ CRITICAL: Each atomic handler call MUST be in a private method** (takes Handler DTO, transforms to Atomic Handler DTO, returns HttpResponseSnapshot) | **üî¥ NON-NEGOTIABLE: Leverage Core Framework extensions FIRST** - Check Core Framework extension methods before creating new conversion/helper functionality | **üî¥ NON-NEGOTIABLE: Use descriptive variable names** - Variable names must clearly reflect what they are or what they are doing | **üî¥ CRITICAL: DON'T read from RequestContext, KeyVault, or AppConfigs** - All reading from these sources MUST be done in Atomic Handlers, not in Handlers

### ‚ùå DON'T
**Function Exposure:** Skip decision table (MANDATORY) | Assume operations are Functions without verification | Pattern-match without table | Create Functions for internal lookups | Expose Login/Logout as Functions | Proceed without 7 verification questions
**Implementation:** Expose internal operations as Functions | Orchestrate different SORs (use PL) | Include business logic | Use if/else for business decisions (use PL) | Return `ApiResDTO` directly | Forget `IsSuccessStatusCode` check | Swallow exceptions | Use `_logger.LogInformation()` (use `.Info()`) | Use `_logger.LogError()` (use `.Error()`) | Create custom HttpClients | Register with interfaces (use concrete) | Forget to inject Atomic Handlers | Call another System Layer (FORBIDDEN) | Create Function Explosion | **üî¥ CRITICAL: Use standalone `if` statements without `else` clause** | **üî¥ CRITICAL: Use empty else blocks** (else blocks with only comments or no code - must contain meaningful logic) | **üî¥ CRITICAL: Call atomic handlers directly in `HandleAsync`** (must use private methods) | **üî¥ NON-NEGOTIABLE: Use ambiguous or unclear variable names** (variable names must clearly reflect what they are or what they are doing - avoid generic names like `data`, `result`, `item`, `temp`) | **üî¥ CRITICAL: Read from RequestContext, KeyVault, or AppConfigs in Handlers** (all reading from these sources MUST be done in Atomic Handlers only)

## 15. ARCHITECTURE INVARIANTS (NEVER VIOLATE)
1. **Function Exposure Decision Table MANDATORY** (BLOCKING gate) | 2. **Complete table BEFORE Handlers/Functions** (BLOCKING) | 3. **Answer 5 questions for EACH operation** (no exceptions) | 4. **SL NEVER calls another SL** (Cross-SL ‚Üí Process Layer) | 5. **Handler orchestration INTERNAL** (not Function-to-Function) | 6. **Only create Functions PL calls** (internal = Atomic Handlers) | 7. **Handlers orchestrate Atomic Handlers** (1 Function ‚Üí multiple Atomic Handlers) | 8. **Same SOR ONLY** (Handler orchestration allowed ONLY same SOR) | 9. **Simple Business Logic ALLOWED at Handler** (same SOR: check-before-create, simple if/else, flag checks) | 10. **Internal lookups = Atomic Handlers (NOT Functions)** (field extraction operations) | 11. **Same-SOR decisions = Handler orchestrates** (if all operations same SOR ‚Üí 1 Function with if/else in Handler) | 12. **Cross-SOR decisions = Process Layer** (if operations span SORs ‚Üí Multiple Functions, PL orchestrates) | 13. **Looping/Iteration = Process Layer** (any loop/foreach/iteration over multiple API calls ‚Üí Process Layer orchestrates, even if same SOR - this is business logic) | 14. **ALWAYS map ApiResDTO ‚Üí ResDTO** (NEVER return ApiResDTO directly) | 15. **ALWAYS check IsSuccessStatusCode** (throw DownStreamApiFailureException)

## 16. COMMON ERRORS & FIXES
| Error | Cause | Fix |
|-------|-------|-----|
| **Function Explosion** | Exposed internal lookups | Complete decision table - mark lookups as Atomic |
| **Login/Logout Functions** | Didn't follow auth rules | Login/Logout = Atomic for middleware, NOT Functions |
| **Business logic in Handler** | Didn't identify decision points | Move decisions to PL, create multiple Functions |
| **Missing decision table** | Skipped mandatory step | Complete table BEFORE coding |
| **Wrong operation type** | Pattern-matched | Answer 4 questions algorithmically |
| **Single Function with decisions** | Didn't separate | Create separate Functions for ops with decisions |
| `Handler not registered` | Missing DI | `builder.Services.AddScoped<YourHandler>()` |
| `Atomic Handler null` | Not injected | Add parameter to constructor |
| `ApiResDTO returned` | Forgot map | Call `ResDTO.Map(apiResponse)` |
| `Unhandled exception` | Not checking status | `if (!response.IsSuccessStatusCode) throw` |
| `NullReference on response` | No null check | `if (apiResponse == null) throw NotFoundException` |
| `LogInformation not found` | Using ILogger directly | Use `_logger.Info()` from Core.Extensions |
| `Doesn't implement interface` | Missing IBaseHandler<T> | Add `: IBaseHandler<YourReqDTO>` |
| `Method name mismatch` | Named incorrectly | MUST be `HandleAsync` |

## 17. VERIFICATION CHECKLIST

### Function Exposure Decision (MANDATORY)
- [ ] Decision table completed for ALL operations
- [ ] All 4 questions answered for EACH operation
- [ ] Reasoning documented for EACH decision
- [ ] All 7 verification questions YES or N/A
- [ ] Summary written (number of Functions + why)
- [ ] No internal lookups as Functions
- [ ] No Login/Logout as Functions
- [ ] Business decisions assigned to Process Layer

### Handler Implementation
- [ ] Name ends with `Handler` | [ ] Implements `IBaseHandler<TRequest>` | [ ] Method named `HandleAsync` | [ ] Returns `BaseResponseDTO` | [ ] Injects Atomic Handlers | [ ] Checks `IsSuccessStatusCode` after each call | [ ] Throws `DownStreamApiFailureException` for failures | [ ] Throws `NotFoundException` for missing | [ ] Deserializes with `ApiResDTO` | [ ] Maps `ApiResDTO` to `ResDTO` | [ ] Logs start/completion | [ ] Logs errors with details | [ ] Uses `Core.Extensions` logging | [ ] Registered `AddScoped<>` | [ ] Located `Implementations/<Vendor>/Handlers/` | [ ] NOT orchestrate different SORs | [ ] NOT include business logic | [ ] NOT expose internal ops as Functions | [ ] **üî¥ CRITICAL: Every `if` statement has an explicit `else` clause** | [ ] **üî¥ CRITICAL: Else blocks contain meaningful code/logic** (no empty else blocks with only comments) | [ ] **üî¥ CRITICAL: Each atomic handler call is in a private method** (takes Handler DTO, transforms to Atomic Handler DTO, returns HttpResponseSnapshot) | [ ] **üî¥ CRITICAL: Does NOT read from RequestContext, KeyVault, or AppConfigs** (all reading from these sources is done in Atomic Handlers only)

## 18. COMPLETE HANDLER TEMPLATE
```csharp
using Core.DTOs; using Core.Exceptions; using Core.Extensions; using Core.SystemLayer.Handlers; using Core.SystemLayer.Exceptions; using Core.Helpers; using Microsoft.Extensions.Logging; using System.Net;
namespace <Namespace>.Implementations.<Vendor>.Handlers {
    public class GetEntityDetailHandler : IBaseHandler<GetEntityDetailReqDTO> {
        private readonly ILogger<GetEntityDetailHandler> _logger; private readonly GetEntityDetailAtomicHandler _getEntityDetailAtomicHandler;
        public GetEntityDetailHandler(ILogger<GetEntityDetailHandler> logger, GetEntityDetailAtomicHandler handler) { _logger = logger; _getEntityDetailAtomicHandler = handler; }
        public async Task<BaseResponseDTO> HandleAsync(GetEntityDetailReqDTO request) {
            _logger.Info("[System Layer]-Initiating Get Entity Detail");
            GetEntityDetailHandlerReqDTO atomicRequest = new GetEntityDetailHandlerReqDTO { EntityId = request.EntityId, IncludeDetails = request.IncludeDetails };
            HttpResponseSnapshot response = await _getEntityDetailAtomicHandler.Handle(atomicRequest);
            if (!response.IsSuccessStatusCode) { _logger.Error($"Failed: {response.StatusCode}"); throw new DownStreamApiFailureException(statusCode: (HttpStatusCode)response.StatusCode, error: ErrorConstants.GET_ENTITY_FAILURE, errorDetails: [$"Response: {response.Content}"], stepName: "GetEntityDetailHandler.cs / HandleAsync"); }
            GetEntityDetailApiResDTO? apiResponse = RestApiHelper.DeserializeJsonResponse<GetEntityDetailApiResDTO>(response.Content!);
            if (apiResponse == null || apiResponse.Items.Count < 1) throw new NotFoundException(ErrorConstants.NO_ENTITY_FOUND, ["No details found"], "GetEntityDetailHandler.cs / HandleAsync");
            _logger.Info("[System Layer]-Completed"); return new BaseResponseDTO(message: InfoConstants.GET_ENTITY_SUCCESS, data: GetEntityDetailResDTO.Map(apiResponse), errorCode: null);
        }
    }
}
```

# Atomic Handler RULES
*ALL RULES CRITICAL & MANDATORY - NO EXCEPTIONS*

**üìö FRAMEWORK REFERENCE:** Review `Framework/Core` and `Framework/Cache` directories to understand framework-level implementation patterns, base classes, interfaces, and helper methods that these rules build upon.

**üö® BEFORE CREATING:** Read ALL rules in this section before creating AtomicHandlers. Verify FLAT folder structure (NO subfolders), IAtomicHandler<HttpResponseSnapshot> implementation, and EXACTLY ONE external call pattern.

## 1. DEFINITION & CORE RULES
**Atomic Handler:** Single-responsibility operation = EXACTLY ONE external call | **Key Principle:** One Atomic Handler = One External Call (Rule #4)

**13 MANDATORY Rules:**
1. Name ends with `AtomicHandler` | 2. Implement `IAtomicHandler<HttpResponseSnapshot>` | 3. Make EXACTLY ONE external operation | 4. Accept `IDownStreamRequestDTO` interface parameter | 5. Cast parameter to concrete type (first line) | 6. Call `ValidateDownStreamRequestParameters()` (second line) | 7. Return `HttpResponseSnapshot` (NEVER throw on HTTP error) | 8. Location: `Implementations/<Vendor>/AtomicHandlers/<Operation>AtomicHandler.cs` (FLAT, NO subfolders) | 9. Inject correct HTTP client: **CustomRestClient** (for REST/JSON APIs) OR **CustomSoapClient** (for SOAP/XML APIs) OR **CustomHTTPClient** (for low-level HTTP) | 10. Inject `IOptions<AppConfigs>` | 11. Inject `ILogger<TAtomicHandler>` | 12. **üî¥ CRITICAL: If mapping/transformation occurs, it MUST be in a separate private method** within the same Atomic Handler class | 13. **üî¥ CRITICAL: ALL reading from RequestContext, KeyVault, and AppConfigs MUST be done in Atomic Handlers** - Since SOR calling requires these values and Atomic Handlers make the SOR calls, all reads must occur here (NOT in Handlers or Functions)

## 2. INTERFACE & HANDLE() METHOD (CRITICAL)

**Interface:**
```csharp
namespace Core.SystemLayer.Handlers { public interface IAtomicHandler<T> { Task<T> Handle(IDownStreamRequestDTO downStreamRequestDTO); } }
```

**‚ùå WRONG (doesn't compile):** `public async Task<HttpResponseSnapshot> Handle(GetEntityReqDTO requestDTO)` // Concrete type parameter

**‚úÖ CORRECT:**
```csharp
public async Task<HttpResponseSnapshot> Handle(IDownStreamRequestDTO downStreamRequestDTO) { // ‚Üê Interface parameter (MANDATORY)
    GetEntityReqDTO requestDTO = downStreamRequestDTO as GetEntityReqDTO ?? throw new ArgumentException("Invalid DTO type"); // 1. Cast (MANDATORY)
    requestDTO.ValidateDownStreamRequestParameters(); // 2. Validate (MANDATORY)
    return await _restClient.ExecuteRestRequestAsync(...); // 3. ONE external call
}
```

## 3. DTO REQUIREMENTS (MANDATORY)

**Every AtomicHandler DTO MUST:** (1) Implement `IDownStreamRequestDTO` | (2) Have `ValidateDownStreamRequestParameters()` method | (3) Throw `RequestValidationFailureException` on errors | (4) Located in `DTO/AtomicHandlerDTOs/`

```csharp
using Core.Exceptions; using Core.SystemLayer.DTOs;
public class GetEntityReqDTO : IDownStreamRequestDTO {
    public string EntityId { get; set; } = string.Empty;
    public void ValidateDownStreamRequestParameters() {
        List<string> errors = new List<string>();
        if (string.IsNullOrWhiteSpace(EntityId)) errors.Add("EntityId is required");
        if (errors.Count > 0)
            throw new RequestValidationFailureException(
                errorDetails: errors,
                stepName: "GetEntityReqDTO.cs / Executing ValidateDownStreamRequestParameters"
            );
    }
}
```

## 4. MANDATORY USING STATEMENTS
```csharp
using Core.Exceptions;                      // Framework exceptions
using Core.Extensions;                      // LoggerExtensions (MANDATORY)
using Core.Middlewares;                     // CustomRestClient
using Core.SystemLayer.DTOs;                // IDownStreamRequestDTO (CRITICAL!)
using Core.SystemLayer.Handlers;            // IAtomicHandler
using Core.SystemLayer.Middlewares;         // HttpResponseSnapshot
using Core.SystemLayer.Exceptions;          // DownStreamApiFailureException
using Microsoft.Extensions.Logging;         // ILogger
using Microsoft.Extensions.Options;         // IOptions<T>
using <Namespace>.ConfigModels;             // AppConfigs
using <Namespace>.Constants;                // ErrorConstants, OperationNames (MANDATORY for operationName)
using <Namespace>.DTO.AtomicHandlerDTOs;   // DTOs
using System.Net;                           // HttpStatusCode
```

## 5. COMPLETE TEMPLATES

### REST API Template
```csharp
using Core.Exceptions; using Core.Extensions; using Core.Middlewares; using Core.SystemLayer.DTOs; using Core.SystemLayer.Handlers; using Core.SystemLayer.Middlewares; using Core.SystemLayer.Exceptions; using Microsoft.Extensions.Logging; using Microsoft.Extensions.Options; using <Namespace>.Constants;
namespace <Namespace>.Implementations.<Vendor>.AtomicHandlers { public class GetEntityAtomicHandler : IAtomicHandler<HttpResponseSnapshot> { private readonly CustomRestClient _restClient; private readonly AppConfigs _appConfigs; private readonly ILogger<GetEntityAtomicHandler> _logger;
    public GetEntityAtomicHandler(CustomRestClient restClient, IOptions<AppConfigs> options, ILogger<GetEntityAtomicHandler> logger) { _restClient = restClient; _appConfigs = options.Value; _logger = logger; }
    public async Task<HttpResponseSnapshot> Handle(IDownStreamRequestDTO downStreamRequestDTO) { GetEntityReqDTO requestDTO = downStreamRequestDTO as GetEntityReqDTO ?? throw new ArgumentException("Invalid DTO type"); _logger.Info($"Starting GetEntity for EntityId: {requestDTO.EntityId}"); requestDTO.ValidateDownStreamRequestParameters(); string fullUrl = $"{_appConfigs.BaseUrl}/api/entities/{requestDTO.EntityId}"; HttpResponseSnapshot response = await _restClient.ExecuteCustomRestRequestAsync(operationName: OperationNames.GET_ENTITY, apiUrl: fullUrl, httpMethod: HttpMethod.Get); _logger.Info($"GetEntity completed - Status: {response.StatusCode}"); return response; } } }
```

### SOAP Template
```csharp
using <Namespace>.Constants;
public class CreateTaskAtomicHandler : IAtomicHandler<HttpResponseSnapshot> { private readonly CustomSoapClient _soapClient; private readonly AppConfigs _appConfigs; private readonly ILogger<CreateTaskAtomicHandler> _logger;
    public async Task<HttpResponseSnapshot> Handle(IDownStreamRequestDTO downStreamRequestDTO) { CreateTaskReqDTO requestDTO = downStreamRequestDTO as CreateTaskReqDTO ?? throw new ArgumentException("Invalid DTO type"); requestDTO.ValidateDownStreamRequestParameters(); string resourceName = $"{_appConfigs.ProjectNamespace}.SoapEnvelopes.CreateTask.xml"; string template = SOAPHelper.LoadSoapEnvelopeTemplate(resourceName); string soapEnvelope = template.Replace("{{TaskNumber}}", requestDTO.TaskNumber).Replace("{{Description}}", requestDTO.Description); return await _soapClient.ExecuteCustomSoapRequestAsync(operationName: OperationNames.CREATE_TASK, apiUrl: _appConfigs.SoapEndpointUrl, soapEnvelope: soapEnvelope, soapActionUrl: "http://example.com/CreateTask", httpMethod: HttpMethod.Post); } }
```

### Authentication Handlers (Internal Only - NEVER Azure Functions)
```csharp
// AuthenticateAtomicHandler
public class AuthenticateAtomicHandler : IAtomicHandler<HttpResponseSnapshot> {
    private readonly CustomRestClient _restClient; private readonly AppConfigs _appConfigs;
    public AuthenticateAtomicHandler(CustomRestClient restClient, IOptions<AppConfigs> options) 
        { _restClient = restClient; _appConfigs = options.Value; }
    public async Task<HttpResponseSnapshot> Handle(IDownStreamRequestDTO request) {
        AuthenticationRequestDTO? dto = request as AuthenticationRequestDTO; dto.ValidateDownStreamRequestParameters();
        return await _restClient.ExecuteRestRequestAsync(url: _appConfigs.AuthUrl, httpMethod: HttpMethod.Post, 
            bodyContent: JsonSerializer.Serialize(new { username = dto.Username, password = dto.Password }));
    }
}

// LogoutAtomicHandler (similar pattern for logout)
```

## 6. DEPENDENCY INJECTION & REGISTRATION

**üî¥ MANDATORY - Inject Correct HTTP Client Based on Integration Type:**

| Integration Type | Inject in Constructor | Field Declaration | Usage |
|------------------|----------------------|-------------------|-------|
| **REST API** | `CustomRestClient restClient` | `private readonly CustomRestClient _restClient;` | JSON/REST operations |
| **SOAP API** | `CustomSoapClient soapClient` | `private readonly CustomSoapClient _soapClient;` | SOAP envelope operations |
| **Low-level HTTP** | `CustomHTTPClient httpClient` | `private readonly CustomHTTPClient _httpClient;` | Custom HTTP needs |

**Constructor Pattern (REST):**
```csharp
private readonly CustomRestClient _restClient; private readonly AppConfigs _appConfigs; private readonly ILogger<GetEntityAtomicHandler> _logger;
public GetEntityAtomicHandler(CustomRestClient restClient, IOptions<AppConfigs> options, ILogger<GetEntityAtomicHandler> logger) { _restClient = restClient; _appConfigs = options.Value; _logger = logger; }
```

**Constructor Pattern (SOAP):**
```csharp
private readonly CustomSoapClient _soapClient; private readonly AppConfigs _appConfigs; private readonly ILogger<CreateTaskAtomicHandler> _logger;
public CreateTaskAtomicHandler(CustomSoapClient soapClient, IOptions<AppConfigs> options, ILogger<CreateTaskAtomicHandler> logger) { _soapClient = soapClient; _appConfigs = options.Value; _logger = logger; }
```

**Common Dependencies:** 
- **CustomRestClient** (REST APIs - Framework: `Core.Middlewares`)
- **CustomSoapClient** (SOAP APIs - Project Helper: `<ProjectName>.Helper` - **YOU MUST CREATE THIS**)
- **CustomHTTPClient** (low-level HTTP - Framework: `Core.Middlewares`)
- **IOptions<AppConfigs>** (config - **üî¥ CRITICAL: All AppConfigs reading MUST be in Atomic Handlers**)
- **ILogger<T>** (logging)
- **KeyVaultReader** (secrets - if needed - **üî¥ CRITICAL: All KeyVault reading MUST be in Atomic Handlers**)

**üî¥ CRITICAL RULE - Configuration & Context Reading:**
- **ALL reading from RequestContext** (SessionId, Token, Username, Password, etc.) **MUST be done in Atomic Handlers**
- **ALL reading from KeyVault** (secrets, credentials) **MUST be done in Atomic Handlers**
- **ALL reading from AppConfigs** (URLs, timeouts, settings) **MUST be done in Atomic Handlers**
- **Rationale:** Atomic Handlers make the actual SOR calls and need these values for authentication, URLs, and configuration. Handlers should NOT read from these sources - they should pass data via DTOs to Atomic Handlers.

**‚ö†Ô∏è IMPORTANT:** `CustomSoapClient` is NOT in Framework. For SOAP integrations, you must create `CustomSoapClient.cs` in your project's `Helper/` folder. **MANDATORY:** Custom clients MUST implement timing tracking - see Section 5.1 for complete example with timing pattern.

**Program.cs Registration (CONCRETE class, NO interface):**
```csharp
builder.Services.AddScoped<GetEntityDetailAtomicHandler>(); builder.Services.AddScoped<CreateEntityAtomicHandler>();
builder.Services.AddScoped<AuthenticateAtomicHandler>(); builder.Services.AddScoped<LogoutAtomicHandler>();
```

## 7. CONFIGURATION & CONTEXT READING (üî¥ CRITICAL - MUST BE IN ATOMIC HANDLERS)

**üî¥ NON-NEGOTIABLE RULE:** ALL reading from RequestContext, KeyVault, and AppConfigs MUST be done in Atomic Handlers. Handlers should NOT read from these sources.

### Why This Rule Exists
- Atomic Handlers make the actual SOR calls and need these values for:
  - **Authentication:** SessionId, Token, Username, Password from RequestContext or KeyVault
  - **Configuration:** API URLs, timeouts, retry counts from AppConfigs
  - **Secrets:** API keys, passwords from KeyVault
- Handlers should only pass business data via DTOs to Atomic Handlers
- This ensures all SOR-related configuration is centralized in Atomic Handlers

### Examples

**Example 1: Reading from RequestContext in Atomic Handler**
```csharp
public class GetEntityAtomicHandler : IAtomicHandler<HttpResponseSnapshot> {
    private readonly CustomRestClient _restClient; private readonly AppConfigs _appConfigs; private readonly ILogger<GetEntityAtomicHandler> _logger;
    public async Task<HttpResponseSnapshot> Handle(IDownStreamRequestDTO downStreamRequestDTO) {
        GetEntityReqDTO requestDTO = downStreamRequestDTO as GetEntityReqDTO ?? throw new ArgumentException("Invalid DTO");
        requestDTO.ValidateDownStreamRequestParameters();
        // ‚úÖ CORRECT: Read from RequestContext in Atomic Handler
        string? sessionId = RequestContext.GetSessionId(); string? username = RequestContext.GetUsername(); string? password = RequestContext.GetPassword();
        // ‚úÖ CORRECT: Read from AppConfigs in Atomic Handler
        string apiUrl = $"{_appConfigs.BaseApiUrl}/api/entities/{requestDTO.EntityId}"; int timeoutSeconds = _appConfigs.TimeoutSeconds;
        HttpResponseSnapshot response = await _restClient.ExecuteCustomRestRequestAsync(operationName: OperationNames.GET_ENTITY, apiUrl: apiUrl, httpMethod: HttpMethod.Get, username: username, password: password);
        return response;
    }
}
```

**Example 2: Reading from KeyVault in Atomic Handler**
```csharp
public class CreateEntityAtomicHandler : IAtomicHandler<HttpResponseSnapshot> {
    private readonly CustomRestClient _restClient; private readonly AppConfigs _appConfigs; private readonly KeyVaultReader _keyVaultReader; private readonly ILogger<CreateEntityAtomicHandler> _logger;
    public CreateEntityAtomicHandler(CustomRestClient restClient, IOptions<AppConfigs> options, KeyVaultReader keyVaultReader, ILogger<CreateEntityAtomicHandler> logger) { _restClient = restClient; _appConfigs = options.Value; _keyVaultReader = keyVaultReader; _logger = logger; }
    public async Task<HttpResponseSnapshot> Handle(IDownStreamRequestDTO downStreamRequestDTO) {
        CreateEntityReqDTO requestDTO = downStreamRequestDTO as CreateEntityReqDTO ?? throw new ArgumentException("Invalid DTO");
        requestDTO.ValidateDownStreamRequestParameters();
        // ‚úÖ CORRECT: Read from KeyVault in Atomic Handler
        Dictionary<string, string> secrets = await _keyVaultReader.GetAuthSecretsAsync(); string apiKey = secrets["ApiKey"]; string password = secrets["Password"];
        // ‚úÖ CORRECT: Read from AppConfigs in Atomic Handler
        string apiUrl = $"{_appConfigs.BaseApiUrl}/api/entities";
        HttpResponseSnapshot response = await _restClient.ExecuteCustomRestRequestAsync(operationName: OperationNames.CREATE_ENTITY, apiUrl: apiUrl, httpMethod: HttpMethod.Post, customHeaders: new Dictionary<string, string> { { "X-API-Key", apiKey } });
        return response;
    }
}
```

**‚ùå WRONG: Reading in Handler**
```csharp
// ‚ùå WRONG: Handler reading from RequestContext
public class GetEntityHandler : IBaseHandler<GetEntityReqDTO> {
    public async Task<BaseResponseDTO> HandleAsync(GetEntityReqDTO request) {
        // ‚ùå DON'T read here - Atomic Handler should read
        string? sessionId = RequestContext.GetSessionId(); string apiUrl = _appConfigs.BaseApiUrl; // ‚ùå DON'T read AppConfigs here
        GetEntityHandlerReqDTO atomicRequest = new GetEntityHandlerReqDTO { EntityId = request.EntityId, SessionId = sessionId }; // ‚ùå DON'T pass values read in Handler
        // ...
    }
}
```

**‚úÖ CORRECT: Handler passes only business data**
```csharp
// ‚úÖ CORRECT: Handler passes only business data
public class GetEntityHandler : IBaseHandler<GetEntityReqDTO> {
    public async Task<BaseResponseDTO> HandleAsync(GetEntityReqDTO request) {
        // ‚úÖ CORRECT: Only pass business data - Atomic Handler reads from RequestContext/KeyVault/AppConfigs
        GetEntityHandlerReqDTO atomicRequest = new GetEntityHandlerReqDTO { EntityId = request.EntityId }; // Only business data
        HttpResponseSnapshot response = await _getEntityAtomicHandler.Handle(atomicRequest);
        // ...
    }
}
```

## 8. LOGGING (MANDATORY - Core.Extensions Only)
```csharp
using Core.Extensions; // ‚Üê REQUIRED
_logger.Info("Starting operation"); _logger.Info($"EntityId: {requestDTO.EntityId}"); _logger.Error(ex, "Operation failed"); _logger.Warn("Retry");
```
**Forbidden:** ‚ùå `_logger.LogInformation()` (use `_logger.Info()`) | ‚ùå `_logger.LogError()` (use `_logger.Error()`) | ‚ùå `Console.WriteLine()`

## 9. ERROR HANDLING
**Atomic Handler Rules:** DON'T throw for HTTP errors (return HttpResponseSnapshot) | DO throw for validation failures (RequestValidationFailureException) | DO throw for invalid DTO cast (ArgumentException) | Let Handler check response status

**Handler's Job (NOT Atomic Handler):**
```csharp
HttpResponseSnapshot response = await _atomicHandler.Handle(request);
if (!response.IsSuccessStatusCode) throw new DownStreamApiFailureException(
    statusCode: (HttpStatusCode)response.StatusCode, error: ErrorConstants.SYS_GET_0001, 
    errorDetails: [$"API failed: {response.Content}"], stepName: "GetEntityHandler.cs / HandleAsync");
```

## 10. CACHING SUPPORT (OPTIONAL)

**Framework Reference:** Look at `Framework/Cache/Handlers/ICacheableAtomicHandler.cs` for implementation.

### When to Use Caching in Atomic Handlers
‚úÖ **Use Caching When:**
- Master data/reference lookups (entity types, LOVs, categories, statuses)
- External API has high latency (slow downstream response)
- Data changes infrequently (static/semi-static)
- Read-only operations (GET requests)
- Same data requested multiple times in short period

‚ùå **DON'T Use Caching When:**
- Write operations (POST, PUT, DELETE, PATCH - NEVER cache writes)
- Data must be real-time (live transactional data)
- Data changes frequently (high-frequency updates)
- Transactional data with strict consistency (financial, audit)
- Security/compliance requires audit trail for every access

### ICacheableAtomicHandler<T> Pattern
```csharp
using Cache.Handlers; using Cache.Key; using Core.Extensions; using Core.Middlewares; using Core.SystemLayer.DTOs; using Core.SystemLayer.Handlers;
public class GetLOVAtomicHandler : ICacheableAtomicHandler<HttpResponseSnapshot> { private readonly ILogger<GetLOVAtomicHandler> _logger; private readonly CustomRestClient _restClient; private readonly AppConfigs _appConfigs;
    public GetLOVAtomicHandler(ILogger<GetLOVAtomicHandler> logger, CustomRestClient restClient, IOptions<AppConfigs> options) { _logger = logger; _restClient = restClient; _appConfigs = options.Value; }
    public async Task<HttpResponseSnapshot> Handle(IDownStreamRequestDTO request) { GetLOVHandlerReqDTO dto = request as GetLOVHandlerReqDTO ?? throw new ArgumentException("Invalid DTO"); dto.ValidateDownStreamRequestParameters(); _logger.Info("GetLOVAtomicHandler processing"); HttpResponseSnapshot response = await _restClient.ExecuteCustomRestRequestAsync(operationName: OperationNames.GET_LOV, apiUrl: _appConfigs.LOVApiUrl, httpMethod: HttpMethod.Get, contentFactory: null, username: dto.Username, password: dto.Password, queryParameters: null, customHeaders: null); return response; }
    // ICacheableAtomicHandler<T> provides HandleCacheAsync() default implementation (30-day TTL, cache-aside pattern)
}
```

### Usage in Handler (Cached Call)
```csharp
public class GetEntityHandler : IBaseHandler<GetEntityReqDTO> { 
    private readonly GetLOVAtomicHandler _lovAtomicHandler;
    public async Task<BaseResponseDTO> HandleAsync(GetEntityReqDTO request) {
        // ‚úÖ CORRECT: Pass only business data - Atomic Handler reads from RequestContext/KeyVault/AppConfigs
        GetLOVHandlerReqDTO lovRequest = new GetLOVHandlerReqDTO { LOVType = "EntityStatus" }; // Username and Password will be read by Atomic Handler from RequestContext/KeyVault
        CacheKeySettings cacheSettings = new CacheKeySettings { TimeToLive = TimeSpan.FromHours(24) };
        HttpResponseSnapshot response = await ((ICacheableAtomicHandler<HttpResponseSnapshot>)_lovAtomicHandler).HandleCacheAsync(lovRequest, cacheSettings);
        // ... process response ...
    }
}
```

**üî¥ CRITICAL:** Handlers should NOT read from RequestContext, KeyVault, or AppConfigs. These reads MUST happen in Atomic Handlers where the SOR calls are made.

### Rules
1. Atomic Handler implements `ICacheableAtomicHandler<HttpResponseSnapshot>` | 2. *HandlerReqDTO implements `ICacheable` (see DTO section) | 3. Default TTL: 30 days (override with CacheKeySettings) | 4. Call `HandleCacheAsync()` instead of `Handle()` for cached | 5. DON'T cache write operations | 6. Cache key generated from DTO properties via `ICacheable.GetCacheKey()`

**Program.cs:** `builder.Services.AddRedisCacheLibrary(builder.Configuration);`  
**appsettings.json:** `"RedisCache": { "ConnectionString": "", "InstanceName": "ProjectName:" }`

## 11. HTTP CLIENT PATTERNS

**üî¥ CRITICAL - Client Selection by Integration Type:**

| Integration Type | Client to Use | Inject in Constructor | Example Operation |
|------------------|--------------|----------------------|-------------------|
| **REST API (JSON)** | `CustomRestClient` | `private readonly CustomRestClient _restClient;` | GET, POST, PUT, DELETE with JSON |
| **SOAP/XML** | `CustomSoapClient` | `private readonly CustomSoapClient _soapClient;` | SOAP envelope operations |
| **Custom/Low-level** | `CustomHTTPClient` | `private readonly CustomHTTPClient _httpClient;` | Special HTTP needs |

**Use Framework Clients:** ‚úÖ CustomRestClient (REST) | ‚úÖ CustomSoapClient (SOAP) | ‚úÖ CustomHTTPClient (low-level) | ‚ùå DON'T create custom HttpClient

### A. REST API Calls (CustomRestClient - Framework)

```csharp
using Core.Extensions; using Core.Middlewares; using Core.SystemLayer.DTOs; using Core.SystemLayer.Handlers; using <ProjectName>.ConfigModels; using <ProjectName>.Constants; using <ProjectName>.DTO.AtomicHandlerDTOs; using Microsoft.Extensions.Logging; using Microsoft.Extensions.Options;
namespace <ProjectName>.Implementations.<Vendor>.AtomicHandlers { 
    public class CreateEntityAtomicHandler : IAtomicHandler<HttpResponseSnapshot> { 
        private readonly ILogger<CreateEntityAtomicHandler> _logger; private readonly CustomRestClient _customRestClient; private readonly AppConfigs _appConfigs;
        public CreateEntityAtomicHandler(ILogger<CreateEntityAtomicHandler> logger, CustomRestClient customRestClient, IOptions<AppConfigs> options) { _logger = logger; _customRestClient = customRestClient; _appConfigs = options.Value; }
        public async Task<HttpResponseSnapshot> Handle(IDownStreamRequestDTO downStreamRequestDTO) { 
            CreateEntityHandlerReqDTO? dto = downStreamRequestDTO as CreateEntityHandlerReqDTO; dto?.ValidateDownStreamRequestParameters(); 
            _logger.Info($"CreateEntityAtomicHandler processing for Entity: {dto.EntityId}"); 
            string apiUrl = RestApiHelper.BuildUrl(_appConfigs.BaseApiUrl, new List<string>() { "entities" }); 
            object requestBody = MapDtoToRequestBody(dto); 
            HttpResponseSnapshot response = await _customRestClient.ExecuteCustomRestRequestAsync(operationName: OperationNames.CREATE_ENTITY, apiUrl: apiUrl, httpMethod: HttpMethod.Post, contentFactory: () => CustomRestClient.CreateJsonContent(requestBody), username: dto.Username, password: dto.Password, queryParameters: null, customHeaders: null); 
            _logger.Info($"Received response: {response.StatusCode}"); return response; 
        }
        private object MapDtoToRequestBody(CreateEntityHandlerReqDTO dto) { return new { Id = dto.EntityId, Name = dto.Name }; }
    } 
}
```

**üî¥ CRITICAL:** If mapping/transformation occurs (DTO to request body, field transformations, etc.), it MUST be in a separate private method like `MapDtoToRequestBody()` shown above.

### B. SOAP API Calls (CustomSoapClient - Project Helper)

**üî¥ IMPORTANT:** `CustomSoapClient` is NOT in Framework - you must create it in `Helpers/CustomSoapClient.cs` of your project.

```csharp
using Core.Extensions; using Core.System.DTOs; using Core.System.Handlers; using Core.System.Middlewares; using <ProjectName>.ConfigModels; using <ProjectName>.Constants; using <ProjectName>.DTO.HandlerDTO.AtomicHandlerDTO; using <ProjectName>.Helper; using Microsoft.Extensions.Logging; using Microsoft.Extensions.Options;
namespace <ProjectName>.Implementations.<Vendor>.AtomicHandlers { 
    public class CreateTaskAtomicHandler : IAtomicHandler<HttpResponseSnapshot> { 
        private readonly ILogger<CreateTaskAtomicHandler> _logger; private readonly CustomSoapClient _customSOAPClient; private readonly AppConfigs _appConfigs;
        public CreateTaskAtomicHandler(ILogger<CreateTaskAtomicHandler> logger, CustomSoapClient soapClient, IOptions<AppConfigs> options) { _logger = logger; _customSOAPClient = soapClient; _appConfigs = options.Value; }
        public async Task<HttpResponseSnapshot> Handle(IDownStreamRequestDTO downStreamRequestDTO) { 
            _logger.Info("CreateTaskAtomicHandler processing started"); 
            CreateTaskHandlerReqDTO? dto = downStreamRequestDTO as CreateTaskHandlerReqDTO; if (dto is not CreateTaskHandlerReqDTO) throw new InvalidCastException("Expected CreateTaskHandlerReqDTO"); 
            dto.ValidateDownStreamRequestParameters(); 
            string soapEnvelope = MapDtoToSoapEnvelope(dto); 
            _logger.Debug("SOAP envelope created"); 
            HttpResponseSnapshot response = await _customSOAPClient.ExecuteCustomSoapRequestAsync(operationName: OperationNames.CREATE_TASK, soapEnvelope: soapEnvelope, apiUrl: _appConfigs.SoapEndpointUrl, soapActionUrl: _appConfigs.SoapActionUrl, httpMethod: HttpMethod.Post); 
            _logger.Info($"Processing completed: {response.StatusCode}"); return response; 
        }
        private string MapDtoToSoapEnvelope(CreateTaskHandlerReqDTO dto) { 
            string envelopeTemplate = SOAPHelper.LoadSoapEnvelopeTemplate("<ProjectName>.SoapEnvelopes.CreateTask.xml"); 
            return envelopeTemplate.Replace("{{SessionId}}", SOAPHelper.GetValueOrEmpty(dto.SessionId)).Replace("{{TaskIdElement}}", SOAPHelper.GetElementOrEmpty("ns:TaskId", dto.TaskId)).Replace("{{DescriptionElement}}", SOAPHelper.GetElementOrEmpty("ns:Description", dto.Description)); 
        }
    } 
}
```

**üî¥ CRITICAL:** The mapping from DTO to SOAP envelope is in a separate private method `MapDtoToSoapEnvelope()`. All mapping/transformation logic MUST be in separate private methods, NOT directly in the `Handle()` method.

**‚ö†Ô∏è CustomSoapClient Pattern:**
- **Location:** `Helpers/CustomSoapClient.cs` (YOU MUST CREATE - NOT in Framework)
- **Purpose:** HTTP client wrapper that executes SOAP requests + performance timing
- **MANDATORY:** Must implement timing tracking (Stopwatch + ResponseHeaders.DSTimeBreakDown) - see Section 5.1 for complete example
- **Methods:** `ExecuteCustomSoapRequestAsync()`, `CreateSoapContent()`
- **Registration:** `builder.Services.AddScoped<CustomSoapClient>();` in Program.cs
- **Usage:** Injected in Atomic Handlers to make SOAP HTTP calls

**‚ö†Ô∏è SOAPHelper Pattern (Static Utility):**
- **Location:** `Helpers/SOAPHelper.cs` (YOU MUST CREATE - NOT in Framework)
- **Purpose:** Static utility for SOAP envelope operations (loading templates, deserializing responses, helper methods)
- **Methods:** `LoadSoapEnvelopeTemplate()`, `DeserializeSoapResponse()`, `GetValueOrEmpty()`, `GetElementOrEmpty()`
- **Registration:** NO registration needed (static class)
- **Usage:** Called directly in Atomic Handlers for envelope manipulation

**üîë Key Distinction:**
- **CustomSoapClient:** Injected service ‚Üí Makes HTTP requests with SOAP envelopes ‚Üí Handles timing
- **SOAPHelper:** Static utility ‚Üí Loads templates, deserializes responses, helper methods ‚Üí NO HTTP calls
- **Workflow:** Atomic Handler uses `SOAPHelper.LoadSoapEnvelopeTemplate()` ‚Üí Builds envelope ‚Üí Calls `CustomSoapClient.ExecuteCustomSoapRequestAsync()`

## 12. FOLDER STRUCTURE & NAMING

**Folder:**
```
Implementations/<Vendor>/AtomicHandlers/<Feature>AtomicHandler.cs
DTO/AtomicHandlerDTOs/<Feature>AtomicHandlerReqDTO.cs
```

**Naming:** Class=`<Feature>AtomicHandler` | File=match class | RequestDTO=`<Feature>ReqDTO` or `<Feature>HandlerReqDTO` | Method=`Handle` (FIXED) | OperationName=descriptive (for logging/timing)

## 13. VALIDATION PATTERNS
```csharp
public void ValidateDownStreamRequestParameters() {
    List<string> errors = new List<string>();
    if (string.IsNullOrWhiteSpace(EntityId)) errors.Add("EntityId is required");
    if (!string.IsNullOrWhiteSpace(Email) && !Email.Contains("@")) errors.Add("Invalid email");
    if (Age < 0 || Age > 150) errors.Add("Age must be 0-150");
    if (Items == null || Items.Count == 0) errors.Add("Items cannot be empty");
    if (errors.Count > 0)
        throw new RequestValidationFailureException(
            errorDetails: errors,
            stepName: $"{GetType().Name}.cs / Executing ValidateDownStreamRequestParameters"
        );
}
```

**Null Checks:** Cast: `GetEntityReqDTO dto = request as GetEntityReqDTO ?? throw new ArgumentException("Invalid DTO")` | Collection: `if (request.Items == null || request.Items.Count == 0)` | String: `if (string.IsNullOrWhiteSpace(request.Desc))`

## 14. DO'S & DON'TS

### ‚úÖ DO
- Use `IDownStreamRequestDTO` interface parameter in Handle() | Cast to concrete type (first line) with null check | Call `ValidateDownStreamRequestParameters()` (second line)
- Return `HttpResponseSnapshot` | Make EXACTLY ONE external call | Inject **correct HTTP client based on integration type:** CustomRestClient (REST/JSON) OR CustomSoapClient (SOAP/XML) OR CustomHTTPClient (low-level)
- Inject IOptions<AppConfigs>, ILogger via constructor | Extract `.Value` from IOptions<AppConfigs> | Register concrete class in Program.cs: `AddScoped<ConcreteClass>()`
- Use Core.Extensions logging (`_logger.Info()`, `_logger.Error()`) | Create AuthenticateAtomicHandler+LogoutAtomicHandler for auth (if session-based)
- Log before and after external call | Include all required using statements (Core.SystemLayer.DTOs is CRITICAL) | **Use OperationNames.* constants for operationName parameter (NEVER string literals)**
- **üî¥ CRITICAL: If mapping/transformation occurs, use separate private method** - All mapping/transformation logic (DTO to SOAP envelope, DTO to request body, field transformations) MUST be in separate private methods within the same Atomic Handler class
- **üî¥ CRITICAL: ALL reading from RequestContext, KeyVault, and AppConfigs MUST be done in Atomic Handlers** - Handlers should NOT read from these sources, only pass business data via DTOs

### ‚ùå DON'T
- DON'T use concrete type in Handle() signature (won't compile) | DON'T forget cast or validation | DON'T throw for HTTP errors (return HttpResponseSnapshot)
- DON'T make multiple external calls | DON'T expose AuthenticateAtomicHandler/LogoutAtomicHandler as Azure Functions
- DON'T use `_logger.LogInformation()` (use `_logger.Info()`) | DON'T create custom HttpClient | DON'T forget Program.cs registration
- DON'T register with interface (use concrete) | DON'T forget `using Core.SystemLayer.DTOs;` | DON'T place DTO in wrong folder | **DON'T use string literals for operationName parameter (use OperationNames.* constants)**
- **üî¥ CRITICAL: DON'T perform mapping/transformation directly in Handle() method** - All mapping/transformation logic must be in separate private methods
- **üî¥ CRITICAL: DON'T read from RequestContext, KeyVault, or AppConfigs in Handlers** - All reading from these sources MUST be done in Atomic Handlers only

## 15. COMMON ERRORS & FIXES

| Error | Cause | Fix |
|-------|-------|-----|
| `CS0535: Doesn't implement interface` | Wrong Handle() signature | Use `IDownStreamRequestDTO` parameter |
| `Property doesn't exist on IDownStreamRequestDTO` | Forgot cast | Cast: `ConcreteDTO dto = request as ConcreteDTO` |
| `DTO validation never executed` | Forgot validation call | Call `dto.ValidateDownStreamRequestParameters()` |
| `Missing IDownStreamRequestDTO` | DTO doesn't implement interface | Add `: IDownStreamRequestDTO` |
| `Handler doesn't compile` | Missing using statements | Add `using Core.SystemLayer.DTOs;` |
| `Atomic handler not found at runtime` | Not registered | Add `builder.Services.AddScoped<YourAtomicHandler>()` |
| `_appConfigs is null` | Forgot extract Value | Use `_appConfigs = options.Value;` |
| **String literal for operationName** | **Hardcoded operation name** | **Use `OperationNames.CREATE_TASK` (NOT `"CREATE_TASK"`)** |

## 15. VERIFICATION CHECKLIST
- [ ] Handle() uses `IDownStreamRequestDTO` parameter (interface, NOT concrete)
- [ ] First line: cast to concrete type with null check
- [ ] Second line: call `ValidateDownStreamRequestParameters()`
- [ ] DTO implements `IDownStreamRequestDTO`
- [ ] DTO has `ValidateDownStreamRequestParameters()` method
- [ ] Using statements include `Core.SystemLayer.DTOs` + `Core.SystemLayer.Handlers` + `<Namespace>.Constants`
- [ ] Class implements `IAtomicHandler<HttpResponseSnapshot>`
- [ ] Returns `HttpResponseSnapshot` (not throwing on HTTP errors)
- [ ] Makes EXACTLY ONE external call
- [ ] Registered in Program.cs: `AddScoped<ConcreteClass>()`
- [ ] Constructor injects correct HTTP client: CustomRestClient (REST) OR CustomSoapClient (SOAP) OR CustomHTTPClient (low-level) + `IOptions<AppConfigs>` + `ILogger<T>`
- [ ] Constructor extracts `.Value` from IOptions
- [ ] Logging uses `_logger.Info()`, `_logger.Error()` (NOT `_logger.LogInformation()`)
- [ ] Located in correct folder: `Implementations/<Vendor>/AtomicHandlers/` (FLAT, NO subfolders)
- [ ] **operationName uses OperationNames.* constant (NOT string literal)**
- [ ] **üî¥ CRITICAL: If mapping/transformation occurs, it is in a separate private method** (mapping logic not directly in Handle() method)
- [ ] **üî¥ CRITICAL: All reading from RequestContext, KeyVault, and AppConfigs is done in Atomic Handler** (NOT in Handlers or Functions)

## 17. KEY INVARIANTS (NEVER VIOLATE)
1. **ONE CALL RULE:** Atomic Handler = EXACTLY ONE external call
2. **INTERFACE PARAMETER:** Handle() MUST use `IDownStreamRequestDTO` (NOT concrete type)
3. **CAST + VALIDATE:** ALWAYS cast (line 1) + validate (line 2)
4. **NO EXCEPTIONS FOR HTTP ERRORS:** Return HttpResponseSnapshot, let Handler decide
5. **CONCRETE REGISTRATION:** Register as concrete class, NOT interface
6. **INTERNAL AUTH HANDLERS:** AuthenticateAtomicHandler + LogoutAtomicHandler NEVER exposed as Functions
7. **FRAMEWORK CLIENTS ONLY:** Use CustomRestClient (REST/JSON APIs), CustomSoapClient (SOAP/XML APIs), CustomHTTPClient (low-level) - NEVER create custom HttpClient
8. **LOGGING EXTENSIONS:** Core.Extensions.LoggerExtensions ONLY
9. **DTO INTERFACE:** All atomic handler DTOs MUST implement IDownStreamRequestDTO
10. **VALIDATION METHOD:** All DTOs MUST have ValidateDownStreamRequestParameters()
11. **OPERATION NAMES:** ALWAYS use OperationNames.* constants for operationName parameter (NEVER string literals)
12. **MAPPING/TRANSFORMATION:** If mapping/transformation occurs, it MUST be in a separate private method within the same Atomic Handler class (NOT directly in Handle() method)
13. **CONFIGURATION & CONTEXT READING:** ALL reading from RequestContext, KeyVault, and AppConfigs MUST be done in Atomic Handlers (NOT in Handlers or Functions) - Atomic Handlers make SOR calls and need these values for authentication, URLs, and configuration
14. **üî¥ DON'T CHECK MIDDLEWARE-SET VALUES:** If CustomAuthenticationMiddleware sets SessionId in RequestContext, Atomic Handlers should NOT check if SessionId is null (middleware guarantees it's set). Trust middleware contract. Only check values that come from request parameters or business logic, NOT values guaranteed by framework/middleware.
15. **üî¥ USE FRAMEWORK EXCEPTIONS ONLY:** NEVER throw generic C# exceptions (InvalidOperationException, ArgumentException) in business logic. ONLY use framework exceptions (DownStreamApiFailureException, RequestValidationFailureException, NoRequestBodyException, NoResponseBodyException, NotFoundException, BusinessCaseFailureException). Exception: ArgumentException is acceptable ONLY for DTO type cast validation in Handle() first line.



# DTO RULES
*ALL RULES CRITICAL & MANDATORY - NO EXCEPTIONS*

**üìö FRAMEWORK REFERENCE:** Review `Framework/Core` and `Framework/Cache` directories to understand framework-level implementation patterns, base classes, interfaces, and helper methods that these rules build upon.

**üö® BEFORE CREATING:** Read ALL rules in this section before creating DTOs. Verify interface implementation (IRequestSysDTO for *ReqDTO, IDownStreamRequestDTO for *HandlerReqDTO), folder locations, and validation methods.

**üö® AGENT ALERT - COMMONLY MISSED:**
- ‚úÖ ALL *ReqDTO in entity DTO directories MUST implement `IRequestSysDTO`
- ‚úÖ ALL *HandlerReqDTO in AtomicHandlerDTOs/ MUST implement `IDownStreamRequestDTO`
- ‚ùå NEVER skip interface implementation - causes runtime failures

## 1. DTO TYPES & LOCATIONS

| Type | Purpose | Location | Interface (MANDATORY) | Validation Method | Example |
|------|---------|----------|----------------------|-------------------|---------|
| ReqDTO | API request | `<Entity>DTO/` (directly under DTO/) | ‚úÖ **IRequestSysDTO** | ValidateAPIRequestParameters() | GetEntityReqDTO |
| ResDTO | API response | `<Entity>DTO/` (directly under DTO/) | ‚ùå NONE | static Map(ApiResDTO) | GetEntityResDTO |
| HandlerReqDTO | Atomic input | `AtomicHandlerDTOs/` (FLAT) | ‚úÖ **IDownStreamRequestDTO** | ValidateDownStreamRequestParameters() | GetEntityHandlerReqDTO |
| ApiResDTO | External response | `DownstreamDTOs/` | ‚ùå NONE | - | GetEntityApiResDTO |

## 2. FOLDER STRUCTURE (MANDATORY)

```
DTO/
‚îú‚îÄ‚îÄ GetEntityDetailDTO/                    # Entity-related directory
‚îÇ   ‚îú‚îÄ‚îÄ GetEntityDetailReqDTO.cs
‚îÇ   ‚îî‚îÄ‚îÄ GetEntityDetailResDTO.cs
‚îú‚îÄ‚îÄ CreateRecordDTO/                       # Entity-related directory
‚îÇ   ‚îú‚îÄ‚îÄ CreateRecordReqDTO.cs
‚îÇ   ‚îî‚îÄ‚îÄ CreateRecordResDTO.cs
‚îú‚îÄ‚îÄ AtomicHandlerDTOs/                     # FLAT - *HandlerReqDTO.cs
‚îî‚îÄ‚îÄ DownstreamDTOs/                        # ALL *ApiResDTO.cs here (FLAT)
    ‚îî‚îÄ‚îÄ Common/                            # OPTIONAL: Only if shared nested objects across multiple ApiResDTO
```

**üî¥ CRITICAL:** Entity DTO directories directly under DTO/ (NO HandlerDTOs/ intermediate folder) | AtomicHandlerDTOs/ is FLAT (NO subfolders) | Common/ is OPTIONAL

## 3. INTERFACE IMPLEMENTATION (MANDATORY - AGENT COMMONLY MISSES THIS)

**üî¥ CRITICAL RULES:**

| DTO Location | MUST Implement Interface | Validation Method | Example |
|--------------|-------------------------|-------------------|---------|
| **Entity DTO Directories/** (*ReqDTO.cs) | `IRequestSysDTO` | `ValidateAPIRequestParameters()` | `public class GetEntityReqDTO : IRequestSysDTO` |
| **AtomicHandlerDTOs/** (*HandlerReqDTO.cs) | `IDownStreamRequestDTO` | `ValidateDownStreamRequestParameters()` | `public class GetEntityHandlerReqDTO : IDownStreamRequestDTO` |
| **Entity DTO Directories/** (*ResDTO.cs) | NONE | `static Map(ApiResDTO)` | `public class GetEntityResDTO` (no interface) |
| **DownstreamDTOs/** (*ApiResDTO.cs) | NONE | NONE | `public class GetEntityApiResDTO` (no interface) |

**‚ö†Ô∏è AGENT ALERT:** ALL *ReqDTO in entity DTO directories MUST implement `IRequestSysDTO` | ALL *HandlerReqDTO in AtomicHandlerDTOs/ MUST implement `IDownStreamRequestDTO`

**Why This Matters:**
- ‚úÖ Enables polymorphic handling in framework
- ‚úÖ Enforces validation contract
- ‚úÖ Functions/Handlers call `request.ValidateAPIRequestParameters()` before processing
- ‚úÖ AtomicHandlers call `request.ValidateDownStreamRequestParameters()` before external calls
- ‚ùå Missing interfaces = runtime failures, validation bypassed

## 4. ICACHEABLE INTERFACE (OPTIONAL - FOR CACHEABLE DTOs)

**Framework Reference:** Look at `Framework/Cache/DTO/ICacheable.cs` for interface definition.

### When DTOs Need ICacheable
‚úÖ **Implement ICacheable When:**
- DTO used by cacheable Handler (`ICacheableHandler<T>`) or Atomic Handler (`ICacheableAtomicHandler<T>`)
- Handler/Atomic Handler calls `HandleCacheAsync()` instead of `Handle()`/`HandleAsync()`
- Operation fetches master data, reference data, or LOVs (List of Values)

‚ùå **DON'T Implement ICacheable When:**
- Write operations (POST, PUT, DELETE DTOs)
- Real-time/transactional data
- NOT using caching for this operation

### Interface Definition (Framework)
```csharp
namespace Cache.DTO { public interface ICacheable { IDictionary<PropertyInfo, object> GetCacheKey(); } }
```

### Implementation Pattern
```csharp
using Cache.DTO; using Core.SystemLayer.DTOs; using System.Reflection;
public class GetEntityReqDTO : IRequestSysDTO, ICacheable { public string EntityId { get; set; } = string.Empty; public bool IncludeInactive { get; set; }
    public void ValidateAPIRequestParameters() {
        List<string> errors = new List<string>();
        if (string.IsNullOrWhiteSpace(EntityId)) errors.Add("EntityId required");
        if (errors.Count > 0)
            throw new RequestValidationFailureException(
                errorDetails: errors,
                stepName: "GetEntityReqDTO.cs / Executing ValidateAPIRequestParameters"
            );
    }
    public IDictionary<PropertyInfo, object> GetCacheKey() { return new Dictionary<PropertyInfo, object> { { GetType().GetProperty(nameof(EntityId))!, EntityId }, { GetType().GetProperty(nameof(IncludeInactive))!, IncludeInactive } }; }
}
```

### Atomic Handler DTO Example
```csharp
using Cache.DTO; using Core.SystemLayer.DTOs; using System.Reflection;
public class GetLOVHandlerReqDTO : IDownStreamRequestDTO, ICacheable { public string LOVType { get; set; } = string.Empty; public string Username { get; set; } = string.Empty; public string Password { get; set; } = string.Empty;
    public void ValidateDownStreamRequestParameters() {
        List<string> errors = new List<string>();
        if (string.IsNullOrWhiteSpace(LOVType)) errors.Add("LOVType required");
        if (errors.Count > 0)
            throw new RequestValidationFailureException(
                errorDetails: errors,
                stepName: "GetLOVHandlerReqDTO.cs / Executing ValidateDownStreamRequestParameters"
            );
    }
    public IDictionary<PropertyInfo, object> GetCacheKey() { return new Dictionary<PropertyInfo, object> { { GetType().GetProperty(nameof(LOVType))!, LOVType } }; } // Only LOVType affects cache
}
```

### Rules
1. DTO implements BOTH `IRequestSysDTO`/`IDownStreamRequestDTO` AND `ICacheable` (multiple interfaces) | 2. `GetCacheKey()` returns `IDictionary<PropertyInfo, object>` | 3. Include ALL properties that affect cache uniqueness | 4. Exclude transient/security properties (Username, Password, SessionId) from cache key | 5. Use `GetType().GetProperty(nameof(PropertyName))!` as key | 6. Framework uses this for Redis cache key generation

## 5. NAMING RULES

**Pattern:** `<Operation><Type>` where Type = ReqDTO | ResDTO | HandlerReqDTO | ApiResDTO  
**Examples:** GetEntityReqDTO, GetEntityResDTO, GetEntityHandlerReqDTO, GetEntityApiResDTO  
**Rule:** ApiResDTO suffix ONLY for files in DownstreamDTOs/ | NEVER use ApiResDTO in entity DTO directories or AtomicHandlerDTOs/

## 6. INTERFACE DEFINITIONS & EXAMPLES

### IRequestSysDTO (Core.SystemLayer.DTOs)
```csharp
public interface IRequestSysDTO { void ValidateAPIRequestParameters(); }
// Implementation: public class GetEntityReqDTO : IRequestSysDTO { public string EntityId {get;set;}=string.Empty; public void ValidateAPIRequestParameters() { List<string> errors=new List<string>(); if(string.IsNullOrWhiteSpace(EntityId)) errors.Add("EntityId required"); if(errors.Count>0) throw new RequestValidationFailureException(errorDetails:errors, stepName:"GetEntityReqDTO.cs / Executing ValidateAPIRequestParameters"); } }
```

### IDownStreamRequestDTO (Core.SystemLayer.DTOs)
```csharp
public interface IDownStreamRequestDTO { void ValidateDownStreamRequestParameters(); }
// Implementation: public class GetEntityHandlerReqDTO : IDownStreamRequestDTO { public string EntityId {get;set;}=string.Empty; public void ValidateDownStreamRequestParameters() { List<string> errors=new List<string>(); if(string.IsNullOrWhiteSpace(EntityId)) errors.Add("EntityId required"); if(errors.Count>0) throw new RequestValidationFailureException(errorDetails:errors,stepName:"GetEntityHandlerReqDTO.cs / Executing ValidateDownStreamRequestParameters"); } }
```

## 7. VALIDATION PATTERNS

**üî¥ CRITICAL - DTO Validation Exception Pattern:**
- **DTOs MUST use Core Framework default error** - Do NOT provide `error` parameter
- **Pattern:** `throw new RequestValidationFailureException(errorDetails: errors, stepName: "{ClassName}.cs / Executing {MethodName}");`
- **Why:** Exception defaults to `ErrorCodes.REQ_VALIDATION_FAILURE` from Core Framework
- **‚ùå WRONG:** `throw new RequestValidationFailureException(error: ("VAL_001", "Validation failed"), ...)` - Custom error constants NOT allowed in DTOs

**Required:** `if (string.IsNullOrWhiteSpace(Field)) errors.Add("msg");`  
**Format:** `if (!Email.Contains("@")) errors.Add("msg");` | `if (!DateTime.TryParse(Date, out _)) errors.Add("msg");`  
**Range:** `if (Age < 0 || Age > 150) errors.Add("msg");` | `if (Desc.Length > 500) errors.Add("msg");`  
**Collection:** `if (Items == null || Items.Count == 0) errors.Add("msg");` | `if (Items.Count > 100) errors.Add("msg");`  
**Throw:** `if (errors.Count > 0) throw new RequestValidationFailureException(errorDetails: errors, stepName: "{ClassName}.cs / Executing {MethodName}");`

## 8. PROPERTY INITIALIZATION

**String:** `public string Name { get; set; } = string.Empty;` (non-nullable) | `public string? OptName { get; set; }` (nullable)  
**Collection:** `public List<T> Items { get; set; } = new List<T>();` | `public List<string>? OptTags { get; set; }` (nullable)  
**Object:** `public required DataDTO Data { get; set; }` (required) | `public AddressDTO? OptAddr { get; set; }` (nullable) | `public ConfigDTO Config { get; set; } = new ConfigDTO();` (default)  
**Primitive:** `public int Count { get; set; } = 0;` | `public bool IsActive { get; set; } = true;` | `public int? OptCount { get; set; }` (nullable)

## 9. ResDTO MAP() METHOD (MANDATORY)

```csharp
using <NS>.DTO.DownstreamDTOs;
namespace <NS>.DTO.GetEntityDetailDTO { public class GetEntityDetailResDTO { public string EntityId { get; set; } = string.Empty; public string Name { get; set; } = string.Empty;
    public static GetEntityDetailResDTO Map(GetEntityDetailApiResDTO apiRes) { return new GetEntityDetailResDTO { EntityId = apiRes.Id ?? string.Empty, Name = apiRes.Name ?? string.Empty }; } } }
```

**Multiple Params:** `public static ResDTO Map(ApiResDTO api, string msg, DateTime ts) { ... }`  
**Nested:** Map collections using `.Select(x => new DTO { ... }).ToList()`  
**Usage in Handler:** `GetEntityDetailResDTO data = GetEntityDetailResDTO.Map(apiResponse);`

## 10. ApiResDTO RULES

**Location:** ONLY in `DTO/DownstreamDTOs/` | NEVER in entity DTO directories or AtomicHandlerDTOs/  
**Purpose:** Deserialize external API responses | Matches EXACT external API structure (their naming, their fields)  
**Nullable:** All properties nullable (external API may return null)  
**Template:**
```csharp
namespace <NS>.DTO.DownstreamDTOs {
    public class GetEntityDetailApiResDTO {
        public string? emp_id { get; set; }        // External naming (not our convention)
        public string? full_name { get; set; }
        public List<ExternalAddressDTO>? addr_list { get; set; }
    }
}
```
**‚ùå NEVER return ApiResDTO to client** | ‚úÖ ALWAYS map to ResDTO first

## 11. DTO FLOW

```
External API ‚Üí Deserialize ‚Üí [ApiResDTO] (DownstreamDTOs/) ‚Üí Map ‚Üí [ResDTO] (Entity DTO directories) ‚Üí Wrap in BaseResponseDTO ‚Üí Client
```

**Handler Pattern:**
```csharp
HttpResponseSnapshot response = await _atomicHandler.Handle(atomicReq);
if (!response.IsSuccessStatusCode) throw new DownStreamApiFailureException(...);
GetEntityApiResDTO? apiRes = RestApiHelper.DeserializeJsonResponse<GetEntityApiResDTO>(response.Content!);
if (apiRes == null) throw new NoResponseBodyException(...);
GetEntityResDTO data = GetEntityResDTO.Map(apiRes);  // Transform
return new BaseResponseDTO(message: InfoConstants.SUCCESS, data: data, errorCode: null);
```

**Multiple ApiResDTO in Handler:**
```csharp
// Get LOV data
GenericLovApiResDTO? lovData = RestApiHelper.DeserializeJsonResponse<GenericLovApiResDTO>(lovRes.Content!);
// Get Countries
GetCountriesLovApiResDTO? countriesData = RestApiHelper.DeserializeJsonResponse<GetCountriesLovApiResDTO>(countriesRes.Content!);
// Map all into single ResDTO
return new BaseResponseDTO(data: AddEmergencyContactResDTO.Map(addData, countriesData, lovData), ...);
```

## 12. COMMON/ FOLDER (OPTIONAL)

**Create When:** Multiple ApiResDTO files share same nested object (AddressInfo, PersonInfo) | Complex nested structures reused across multiple external APIs | Reduces code duplication  
**Skip When:** ApiResDTO files simple (no nested objects) | Nested objects unique to single ApiResDTO (keep in same file) | Only 1-2 ApiResDTO files (no reuse)  
**Location:** `DTO/DownstreamDTOs/Common/`

## 13. DESERIALIZATION

**REST/JSON:** `RestApiHelper.DeserializeJsonResponse<GetEntityApiResDTO>(response.Content!)`  
**SOAP/XML:** `SOAPHelper.DeserializeSoapResponse<CreateTaskApiResDTO>(response.Content!, "RootElementName")`

## 14. COMMON MISTAKES & FIXES

| Mistake | Fix |
|---------|-----|
| ‚ùå ApiResDTO in entity DTO directories | ‚úÖ Move to DownstreamDTOs/ |
| ‚ùå HandlerDTOs/ intermediate folder | ‚úÖ Remove - entity directories directly under DTO/ |
| ‚ùå Subfolders in AtomicHandlerDTOs/ | ‚úÖ FLAT structure only |
| ‚ùå Return ApiResDTO to client | ‚úÖ Map to ResDTO first |
| ‚ùå ReqDTO missing IRequestSysDTO | ‚úÖ Implement interface + ValidateAPIRequestParameters() |
| ‚ùå ResDTO missing Map() | ‚úÖ Add static Map(ApiResDTO) method |
| ‚ùå Throw on first error | ‚úÖ Collect all errors, then throw |
| ‚ùå Non-ApiResDTO in DownstreamDTOs/ | ‚úÖ ApiResDTO suffix mandatory |

## 15. VERIFICATION CHECKLIST

**ReqDTO:** [ ] IRequestSysDTO | [ ] ValidateAPIRequestParameters() | [ ] RequestValidationFailureException | [ ] <Entity>DTO/ directory (directly under DTO/) | [ ] *ReqDTO suffix | [ ] string.Empty init | [ ] ICacheable if cacheable  
**ResDTO:** [ ] static Map() method | [ ] Accepts ApiResDTO | [ ] <Entity>DTO/ directory (directly under DTO/) | [ ] *ResDTO suffix | [ ] string.Empty init  
**HandlerReqDTO:** [ ] IDownStreamRequestDTO | [ ] ValidateDownStreamRequestParameters() | [ ] RequestValidationFailureException | [ ] AtomicHandlerDTOs/ (FLAT) | [ ] *HandlerReqDTO suffix | [ ] ICacheable if cacheable  
**ApiResDTO:** [ ] DownstreamDTOs/ ONLY | [ ] *ApiResDTO suffix | [ ] Matches external API structure | [ ] NEVER returned directly | [ ] Properties nullable  
**Cacheable DTOs:** [ ] ICacheable implemented | [ ] GetCacheKey() returns IDictionary<PropertyInfo, object> | [ ] Cache key includes all relevant properties | [ ] Excludes security props (Username, Password, SessionId)

## 16. DO'S & DON'TS

**‚úÖ DO:** Implement IRequestSysDTO (ReqDTO) & IDownStreamRequestDTO (HandlerReqDTO) | Validate all required fields | Throw RequestValidationFailureException | Use ReqDTO/ResDTO/HandlerReqDTO/ApiResDTO suffixes | Place ReqDTO/ResDTO in <Entity>DTO/ directories (directly under DTO/) | Place HandlerReqDTO in AtomicHandlerDTOs/ (FLAT) | Place ApiResDTO in DownstreamDTOs/ | Create static Map() in ResDTO | Map ApiResDTO‚ÜíResDTO before returning | Return ResDTO in BaseResponseDTO | Init strings with string.Empty | Init collections with new List<>() | Use null-coalescing (??) in Map() | Collect all errors before throwing | Create Common/ only if shared nested objects | Implement ICacheable for cacheable operations  
**‚ùå DON'T:** Place ApiResDTO outside DownstreamDTOs/ | Create HandlerDTOs/ intermediate folder | Create subfolders in AtomicHandlerDTOs/ | Return ApiResDTO to client | Use ApiResDTO suffix for non-external DTOs | Forget IRequestSysDTO or IDownStreamRequestDTO | Forget ValidateAPIRequestParameters() or ValidateDownStreamRequestParameters() | Forget Map() in ResDTO | Throw on first error | Use ambiguous DTO names | Init nullable properties with non-null values | Include security props in cache key

## 17. KEY INVARIANTS (NEVER VIOLATE)

1. **ALL ReqDTO implement IRequestSysDTO**
2. **ALL HandlerReqDTO implement IDownStreamRequestDTO**
3. **ALL ApiResDTO in DownstreamDTOs/ ONLY**
4. **Entity DTO directories directly under DTO/** - NO HandlerDTOs/ intermediate folder
5. **AtomicHandlerDTOs/ is FLAT (NO subfolders)**
6. **ALL ResDTO have static Map() method**
7. **NEVER return ApiResDTO to client**
8. **Cacheable DTOs implement ICacheable (for HandleCacheAsync())**
9. **GetCacheKey() excludes security properties (Username, Password, SessionId)**
8. **ALWAYS map ApiResDTO‚ÜíResDTO**
9. **ALWAYS validate (throw RequestValidationFailureException)**
10. **ApiResDTO suffix ONLY for files in DownstreamDTOs/**
11. **Validation methods throw RequestValidationFailureException (NOT generic Exception)**
12. **Collect ALL errors before throwing**



# ConfigModels & Constants RULES
*ALL RULES CRITICAL & MANDATORY - NO EXCEPTIONS*

**üìö FRAMEWORK REFERENCE:** Review `Framework/Core` and `Framework/Cache` directories to understand framework-level implementation patterns, base classes, interfaces, and helper methods that these rules build upon.

**üö® BEFORE CREATING:** Read ALL rules in this section before creating ConfigModels/Constants. Verify IConfigValidator implementation, SectionName property, error code format, and appsettings.json structure.

## 1. OVERVIEW

| Folder | Purpose | Mandatory Files |
|--------|---------|-----------------|
| ConfigModels/ | Configuration classes (bind to appsettings.json) | AppConfigs.cs, KeyVaultConfigs.cs |
| Constants/ | Static constant classes | ErrorConstants.cs, InfoConstants.cs, OperationNames.cs |

---

## 2. AppConfigs.cs (MANDATORY)

**Purpose:** Application configuration (URLs, timeouts, credentials) | Implements IConfigValidator | Binds to "AppConfigs" or "AppVariables" section  
**Validation:** `validate()` automatically called when first accessed via `IOptions<AppConfigs>.Value` (NO explicit call in Program.cs)

**Template:**
```csharp
using Core.DTOs;
namespace <NS>.ConfigModels { public class AppConfigs : IConfigValidator { public static string SectionName = "AppConfigs"; public string ASPNETCORE_ENVIRONMENT {get;set;}=string.Empty; public string BaseApiUrl {get;set;}=string.Empty; public string AuthUrl {get;set;}=string.Empty; public string LogoutUrl {get;set;}=string.Empty; public string? Username {get;set;}; public string? Password {get;set;}; public int TimeoutSeconds {get;set;}=50; public int RetryCount {get;set;}=0;
    public void validate() { List<string> errors=new List<string>(); if(string.IsNullOrWhiteSpace(BaseApiUrl)) errors.Add("BaseApiUrl required"); else if(!Uri.TryCreate(BaseApiUrl,UriKind.Absolute,out _)) errors.Add("BaseApiUrl must be valid URL"); if(!string.IsNullOrWhiteSpace(AuthUrl)&&!Uri.TryCreate(AuthUrl,UriKind.Absolute,out _)) errors.Add("AuthUrl must be valid URL"); if(TimeoutSeconds<=0||TimeoutSeconds>300) errors.Add("TimeoutSeconds must be 1-300"); if(RetryCount<0||RetryCount>10) errors.Add("RetryCount must be 0-10"); if(errors.Any()) throw new InvalidOperationException($"AppConfigs validation failed:\n{string.Join("\n",errors)}"); } } }
```

**‚ö†Ô∏è DEFAULTS:** `TimeoutSeconds=50` (seconds), `RetryCount=0` (no retries). Override these values in appsettings.json if Boomi process specifies different timeout/retry configuration.

---

## 3. KeyVaultConfigs.cs (MANDATORY IF USING KEYVAULT)

**Template:**
```csharp
using Core.DTOs;
namespace <NS>.ConfigModels { public class KeyVaultConfigs : IConfigValidator { public static string SectionName = "KeyVault"; public string Url {get;set;}=string.Empty; public Dictionary<string,string>? Secrets {get;set;};
    public void validate() { List<string> errors=new List<string>(); if(string.IsNullOrWhiteSpace(Url)) errors.Add("KeyVault URL required"); else if(!Uri.TryCreate(Url,UriKind.Absolute,out _)) errors.Add("KeyVault URL must be valid"); if(errors.Any()) throw new InvalidOperationException($"KeyVaultConfigs validation failed:\n{string.Join("\n",errors)}"); } } }
```

---

## 4. PROGRAM.CS REGISTRATION

```csharp
using <NS>.ConfigModels; FunctionsApplicationBuilder builder = FunctionsApplication.CreateBuilder(args);
builder.Services.Configure<AppConfigs>(builder.Configuration.GetSection(AppConfigs.SectionName)); builder.Services.Configure<KeyVaultConfigs>(builder.Configuration.GetSection(KeyVaultConfigs.SectionName));
builder.Services.AddScoped<IEntityMgmt, EntityMgmtService>();
```

**Registration Order:** Configure<AppConfigs>() ‚Üí Configure<KeyVaultConfigs>() ‚Üí Register services ‚Üí Register middleware ‚Üí Build & Run  
**Note:** `validate()` called automatically when config first accessed via `IOptions<T>.Value` in any constructor

---

## 5. CONFIGURATION INJECTION

```csharp
using Microsoft.Extensions.Options; using <NS>.ConfigModels;
public class GetEntityDetailAtomicHandler : IAtomicHandler<HttpResponseSnapshot> { private readonly CustomRestClient _restClient; private readonly AppConfigs _appConfigs;
    public GetEntityDetailAtomicHandler(CustomRestClient restClient, IOptions<AppConfigs> options) { _restClient = restClient; _appConfigs = options.Value; }
    public async Task<HttpResponseSnapshot> Handle(IDownStreamRequestDTO request) { string fullUrl = $"{_appConfigs.BaseApiUrl}/api/entities/{requestDTO.EntityId}"; int timeout = _appConfigs.TimeoutSeconds; } }
```

**Injection Locations:** Atomic Handlers (‚úÖ Yes - API URLs, timeouts, credentials) | Handlers (‚ö†Ô∏è Rarely) | Services (‚ùå No) | Middleware (‚úÖ Yes if needed) | Functions (‚ùå No)

**üî¥ CRITICAL RULE: NO Hardcoded Values in Downstream Requests**

**MANDATORY:** ALL properties sent in downstream requests (SOAP or REST) MUST be configured in AppConfigs/appsettings.json - NEVER hardcode values in code. If a value is found hardcoded (e.g., ContractId = "1"), first check Boomi JSON files (operation/map/profile) to extract the actual value, then add it to AppConfigs with the extracted value. If value doesn't exist in Boomi files, add placeholder in AppConfigs (e.g., ContractId = "") for environment-specific configuration. This ensures environment-specific values can be configured without code changes.

---

## 6. appsettings.json STRUCTURE

**üî¥ CRITICAL PATTERN:**
- **appsettings.json** = Placeholder file (CI/CD pipeline replaces its content with environment-specific file)
- **appsettings.{env}.json** = Environment-specific files with SAME structure/keys, DIFFERENT values
- **ALL environment files MUST have identical structure** (same keys, different values only)
- **CI/CD pipeline** copies content from `appsettings.{env}.json` ‚Üí `appsettings.json` during deployment

### appsettings.json (Placeholder - Replaced by CI/CD)
```json
{
  "AppConfigs": {"BaseApiUrl": "", "AuthUrl": "", "LogoutUrl": "", "Username": "", "Password": "", "TimeoutSeconds": 50, "RetryCount": 0},
  "KeyVault": {"Url": "", "Secrets": {"Password": "", "ApiKey": ""}},
  "RedisCache": {"ConnectionString": "", "InstanceName": ""},
  "Logging": {
    "LogLevel": {
      "Default": "Debug"
    }
  }
}
```
**Note:** This is a placeholder. CI/CD pipeline replaces this file's content with the appropriate environment-specific file during deployment.

**‚úÖ Logging section - EXACT LINES ONLY (NO EXCEPTIONS):**
All appsettings files (base and environment-specific) MUST include ONLY these EXACT lines for logging:
```json
"Logging": {
  "LogLevel": {
    "Default": "Debug"
  }
}
```

**‚ùå ABSOLUTELY FORBIDDEN IN appsettings.json FILES:**
- ‚ùå Console provider configuration
- ‚ùå Application Insights configuration
- ‚ùå Serilog provider configuration
- ‚ùå File paths for log files
- ‚ùå Log level rules for specific namespaces (Microsoft.*, etc.)
- ‚ùå Custom logging providers
- ‚ùå EventSource configuration
- ‚ùå Any extra properties beyond the 3 exact lines above

**üî¥ CRITICAL ENFORCEMENT:**
- ONLY add the 3 exact lines shown above
- NEVER add any other logging configuration to appsettings.json
- NEVER add Console providers, Application Insights, Serilog, or custom providers in appsettings.json
- Logging providers and detailed configuration are EXCLUSIVELY defined in Program.cs
- Any logging configuration beyond the 3 exact lines = **VIOLATION**

### appsettings.dev.json (Development)
**üî¥ MANDATORY:** Same structure as base, only values differ
```json
{
  "AppConfigs": {"BaseApiUrl": "https://dev-vendor.example.com/api", "AuthUrl": "https://dev-vendor.example.com/api/authenticate", "LogoutUrl": "https://dev-vendor.example.com/api/logout", "Username": "dev_user", "Password": "", "TimeoutSeconds": 50, "RetryCount": 0},
  "KeyVault": {"Url": "https://dev-keyvault.vault.azure.net/", "Secrets": {"Password": "ExternalSystemPassword", "ApiKey": "ExternalSystemApiKey"}},
  "RedisCache": {"ConnectionString": "dev-redis-connection-string", "InstanceName": "ProjectName:"},
  "Logging": {
    "LogLevel": {
      "Default": "Debug"
    }
  }
}
```

### appsettings.qa.json (QA)
**üî¥ MANDATORY:** Same structure as dev, only values differ
```json
{
  "AppConfigs": {"BaseApiUrl": "https://qa-vendor.example.com/api", "AuthUrl": "https://qa-vendor.example.com/api/authenticate", "LogoutUrl": "https://qa-vendor.example.com/api/logout", "Username": "qa_user", "Password": "", "TimeoutSeconds": 50, "RetryCount": 0},
  "KeyVault": {"Url": "https://qa-keyvault.vault.azure.net/", "Secrets": {"Password": "ExternalSystemPassword", "ApiKey": "ExternalSystemApiKey"}},
  "RedisCache": {"ConnectionString": "qa-redis-connection-string", "InstanceName": "ProjectName:"},
  "Logging": {
    "LogLevel": {
      "Default": "Debug"
    }
  }
}
```

### appsettings.prod.json (Production)
**üî¥ MANDATORY:** Same structure as all other environments, only values differ
```json
{
  "AppConfigs": {"BaseApiUrl": "https://prod-vendor.example.com/api", "AuthUrl": "https://prod-vendor.example.com/api/authenticate", "LogoutUrl": "https://prod-vendor.example.com/api/logout", "Username": "prod_user", "Password": "", "TimeoutSeconds": 50, "RetryCount": 0},
  "KeyVault": {"Url": "https://prod-keyvault.vault.azure.net/", "Secrets": {"Password": "ExternalSystemPassword", "ApiKey": "ExternalSystemApiKey"}},
  "RedisCache": {"ConnectionString": "prod-redis-connection-string", "InstanceName": "ProjectName:"},
  "Logging": {
    "LogLevel": {
      "Default": "Debug"
    }
  }
}
```

### appsettings.stg.json (Staging - Optional)
**Same structure, staging-specific values**

### appsettings.dr.json (Disaster Recovery - Optional)
**Same structure, DR-specific values**

**Environment Files:** appsettings.json (placeholder, replaced by CI/CD) | appsettings.dev.json (dev) | appsettings.qa.json (qa) | appsettings.stg.json (staging, optional) | appsettings.prod.json (prod) | appsettings.dr.json (DR, optional)

**üî¥ CRITICAL RULES:**
1. **ALL environment files MUST have identical structure** (same keys, same nesting)
2. **ONLY values differ** between environments (URLs, connection strings, usernames)
3. **appsettings.json is a placeholder** - CI/CD replaces it with environment-specific file
4. **CI/CD pipeline** copies `appsettings.{env}.json` ‚Üí `appsettings.json` during deployment
5. **Never add environment-specific keys** to one file that don't exist in others

---

## 7. ErrorConstants.cs (MANDATORY)

### Error Code Format (SYSTEM LAYER)

**üî¥ CRITICAL:** System Layer error constants use THIS format. Process Layer uses different format.

```
Format: AAA_AAAAAA_DDDD
‚îú‚îÄ‚îÄ AAA: SOR abbreviation - 3 uppercase characters only (SOR identifier: SYS, VDA, VDB, VDC, or SOR-specific like EMAIL, etc.)
‚îú‚îÄ‚îÄ AAAAAA: Operation name abbreviation - 6 uppercase characters only (AUTHEN, TSKCRT, LOCGET, APTCRE)
‚îî‚îÄ‚îÄ DDDD: Error series number - 4 digits only (0001, 0002, 0003)
```

**‚ö†Ô∏è DIFFERENCE FROM PROCESS LAYER:**
- **System Layer:** `AAA_AAAAAA_DDDD` (AAA = 3 chars, AAAAAA = 6 chars, DDDD = 4 digits)
- **Process Layer:** `VENDOR_OPERAT_0001` (OPERAT = 6 chars, less abbreviated)
- **System Layer AAA:** Uses SOR identifier (3 uppercase characters representing the system)

### Operation Abbreviation Guide
| Full Operation | Abbreviated (6 chars) | Full Operation | Abbreviated (6 chars) | Full Operation | Abbreviated (6 chars) |
|----------------|----------------------|----------------|----------------------|----------------|----------------------|
| GetEntityDetail | ENTDTL | CreateRequest | REQCRT | GetTasks | TSKGET |
| GetLocation | LOCGET | GetSettings | SETGET | CreateTask | TSKCRT |
| Authenticate | AUTHEN | Logout | LOGOUT | GetCustomer | CUSTGET |
| CreateOrder | ORDCRT | UpdateInventory | INVUPD | DeleteRecord | RECDEL |
| CheckTaskExists | TSKCHK | GetInstruction | INSTGT | UpdateEntity | ENTUPD |

### ErrorConstants.cs Template
```csharp
namespace <NS>.Constants { 
    public class ErrorConstants { 
        // Format: AAA_AAAAAA_DDDD
        // AAA = SOR abbreviation (3 chars): SYS, VDA, VDB, VDC, EMAIL, etc.
        // AAAAAA = Operation abbreviation (6 chars): AUTHEN, TSKCRT, LOCGET, APTCRE, etc.
        // DDDD = Error series number (4 digits): 0001, 0002, 0003, etc.
        
        public static readonly (string ErrorCode, string Message) SYS_AUTHEN_0001 = ("SYS_AUTHEN_0001", "Authentication to external system failed."); 
        public static readonly (string ErrorCode, string Message) SYS_TSKCRT_0001 = ("SYS_TSKCRT_0001", "Failed to create task in external system."); 
        public static readonly (string ErrorCode, string Message) SYS_LOCGET_0001 = ("SYS_LOCGET_0001", "Failed to get location details from external system."); 
        public static readonly (string ErrorCode, string Message) SYS_RECUPD_0001 = ("SYS_RECUPD_0001", "Failed to update record in external system."); 
    } 
}
```

### Usage Examples
```csharp
// DownStreamApiFailureException
if (!response.IsSuccessStatusCode) throw new DownStreamApiFailureException(statusCode:(HttpStatusCode)response.StatusCode, error:ErrorConstants.SYS_AUTHEN_0001, errorDetails:[$"Login API returned {response.StatusCode}"], stepName:"AuthenticateAtomicHandler.cs/Handle");

// NoResponseBodyException
if (apiResponse==null) throw new NoResponseBodyException(error:ErrorConstants.SYS_AUTHEN_0002, errorDetails:["Expected SessionId but received null"], stepName:"AuthenticateAtomicHandler.cs/Handle");

// NotFoundException
if (entityData==null||entityData.EntityId==0) throw new NotFoundException(error:ErrorConstants.SYS_ENTGET_0002, errorDetails:[$"No entity found for Code: {request.EntityCode}"], stepName:"GetEntityHandler.cs/HandleAsync");
```

---

## 8. InfoConstants.cs (MANDATORY)

**Purpose:** Success/info messages | Used in `BaseResponseDTO.Message` | Session/context keys

**Template:**
```csharp
namespace <NS>.Constants { 
    public class InfoConstants { 
        public const string SUCCESS = "Operation completed successfully."; 
        public const string GET_ENTITY_SUCCESS = "Entity details retrieved successfully."; 
        public const string CREATE_TASK_SUCCESS = "Task created successfully."; 
        public const string SESSION_ID = "SessionId"; 
    } 
}
```

### Usage Examples
```csharp
// Success response
return new BaseResponseDTO(message:InfoConstants.GET_EMPLOYEE_SUCCESS, data:employeeData, errorCode:null);

// Generic success
return new BaseResponseDTO(message:InfoConstants.SUCCESS, data:result, errorCode:null);

// Session/Context key (using RequestContext - NEVER use FunctionContext.Items)
RequestContext.SetSessionId(sessionId);
string? sessionId = RequestContext.GetSessionId();
```

---

## 9. OPERATION NAMES CONSTANTS (OperationNames.cs - MANDATORY FOR HTTP CLIENT CALLS)

**Purpose:** Define constants for operation names used in HTTP client calls (`CustomRestClient`, `CustomSoapClient`, `CustomHTTPClient`) | Eliminates hardcoded strings | Improves maintainability & prevents typos

**üî¥ CRITICAL RULE:** NEVER use string literals for `operationName` parameter in HTTP client calls. ALWAYS use constants from `OperationNames.cs`.

**Template:**
```csharp
namespace <NS>.Constants { 
    public class OperationNames { 
        public const string AUTHENTICATE = "AUTHENTICATE"; 
        public const string CREATE_TASK = "CREATE_TASK"; 
        public const string GET_ENTITY_DETAIL = "GET_ENTITY_DETAIL"; 
        public const string GET_LOCATION = "GET_LOCATION"; 
    } 
}
```

### Naming Convention
**Format:** `<VERB>_<ENTITY>_<DETAIL>` (all uppercase with underscores)  
**Examples:** `CREATE_TASK` | `GET_ENTITY_DETAIL` | `UPDATE_RECORD` | `CHECK_TASK_EXISTS`  
**Rule:** Use present tense verbs | Keep concise but descriptive | Match operation intent

### Usage in Atomic Handlers

**‚ùå WRONG (hardcoded string):**
```csharp
HttpResponseSnapshot response = await _restClient.ExecuteCustomRestRequestAsync(operationName: "CREATE_TASK", apiUrl: fullUrl, httpMethod: HttpMethod.Post);
```

**‚úÖ CORRECT (using constant):**
```csharp
using <Namespace>.Constants;
public class CreateTaskAtomicHandler : IAtomicHandler<HttpResponseSnapshot> { public async Task<HttpResponseSnapshot> Handle(IDownStreamRequestDTO downStreamRequestDTO) { CreateTaskReqDTO requestDTO = downStreamRequestDTO as CreateTaskReqDTO ?? throw new ArgumentException("Invalid DTO type"); requestDTO.ValidateDownStreamRequestParameters(); HttpResponseSnapshot response = await _restClient.ExecuteCustomRestRequestAsync(operationName: OperationNames.CREATE_TASK, apiUrl: fullUrl, httpMethod: HttpMethod.Post, contentFactory: () => CustomRestClient.CreateJsonContent(requestBody)); return response; } }
```

**SOAP Example:**
```csharp
HttpResponseSnapshot response = await _soapClient.ExecuteCustomSoapRequestAsync(operationName: OperationNames.CREATE_TASK, soapEnvelope: soapEnvelope, apiUrl: _appConfigs.SoapEndpointUrl, soapActionUrl: "http://example.com/CreateTask", httpMethod: HttpMethod.Post);
```

### Why This Matters
- ‚úÖ **Prevents typos:** Compiler catches misspelled operation names
- ‚úÖ **Maintainability:** Change operation name once, affects all usages
- ‚úÖ **Consistency:** Ensures same operation uses same name everywhere
- ‚úÖ **Discoverability:** IDE autocomplete shows all available operations
- ‚úÖ **Performance tracking:** Consistent names in logs (`ResponseHeaders.DSTimeBreakDown`)
- ‚ùå **String literals:** Error-prone, hard to refactor, no compile-time safety

### Verification Checklist
- [ ] OperationNames.cs exists in Constants/ folder
- [ ] All operation names are `const string`
- [ ] All names follow `<VERB>_<ENTITY>` uppercase pattern
- [ ] All Atomic Handlers import `<Namespace>.Constants`
- [ ] NO string literals for `operationName` parameter
- [ ] ALL HTTP client calls use `OperationNames.*` constants

---

## 10. FRAMEWORK vs SYSTEM LAYER ERROR CODES

| Error Type | Location | Format | Example | Usage |
|------------|----------|--------|---------|-------|
| Framework | Core.Constants.ErrorCodes | COR_GENRIC_XXXX | COR_GENRIC_0002 | Generic errors (API failure, validation) |
| System Layer | <Project>.Constants.ErrorConstants | AAA_AAAAAA_DDDD | SYS_AUTHEN_0001 | SOR-specific errors |

**Framework Error Codes (DO NOT MODIFY - Reference Only):**
```
COR_GENRIC_0001 = "An unexpected error occurred."
COR_GENRIC_0002 = "A downstream API call failed while communicating with an external system."
COR_GENRIC_0003 = "The HTTP request body is missing, empty, or not provided by the client."
COR_GENRIC_0004 = "Invalid request received."
COR_GENRIC_0005 = "A business rule or condition was violated during request processing."
COR_GENRIC_0006 = "The HTTP response body is missing, empty, or not provided by the source."
COR_GENRIC_0007 = "The requested record or resource was not found in the system."
COR_GENRIC_0008 = "The API URL is missing or not configured properly."
```

**When to Use:**
```
Framework Error Code (Core.Constants.ErrorCodes):
‚îú‚îÄ‚ñ∫ Generic error (not SOR-specific)
‚îú‚îÄ‚ñ∫ Framework-level validation failure
‚îú‚îÄ‚ñ∫ Missing request body
‚îî‚îÄ‚ñ∫ Unhandled internal error

System Layer Error Code (Constants/ErrorConstants.cs):
‚îú‚îÄ‚ñ∫ SOR-specific operation failure (e.g., authentication failure)
‚îú‚îÄ‚ñ∫ SOR-specific business case (e.g., duplicate record)
‚îú‚îÄ‚ñ∫ SOR-specific not found (e.g., location not found)
‚îî‚îÄ‚ñ∫ SOR-specific timeout/connectivity
```

---

## 11. KEYVAULT INTEGRATION

**üö® MANDATORY RULE: ALL sensitive information MUST be stored in Azure KeyVault**
- **NEVER** store sensitive data in appsettings.json, appsettings.{environment}.json, or any configuration files
- **ALWAYS** use KeyVault for: passwords, API keys, client secrets, connection strings, encryption keys, and any other sensitive configuration
- **ALWAYS** leave sensitive fields empty in appsettings.json (add placeholders for keyvault secret keys)
- **ALWAYS** retrieve sensitive values from KeyVault at runtime using KeyVaultReader


**When to Use KeyVault:**
‚úÖ Passwords, API keys | ‚úÖ Client secrets, auth tokens | ‚úÖ Connection strings | ‚úÖ Encryption keys | ‚úÖ Any sensitive configuration  
‚ùå Non-sensitive config (URLs, timeouts) | ‚ùå Public information | ‚ùå Frequently changing settings


**appsettings.json (with KeyVault):**
```json
{
  "AppConfigs": {"BaseApiUrl": "https://api.example.com", "Password": "", "ApiKey": ""},
  "KeyVault": {"Url": "https://your-keyvault.vault.azure.net/", "Secrets": {"Password": "ExternalSystemPassword", "ApiKey": "ExternalSystemApiKey"}}
}
```
 
---

## 12. COMMON MISTAKES & FIXES

| Mistake | Fix |
|---------|-----|
| ‚ùå Not implementing IConfigValidator | ‚úÖ `public class AppConfigs : IConfigValidator { ... }` |
| ‚ùå Missing static SectionName | ‚úÖ `public static string SectionName = "AppConfigs";` |
| ‚ùå Empty validate() method | ‚úÖ Implement validation logic with error collection & throw |
| ‚ùå Injecting AppConfigs directly | ‚úÖ Inject `IOptions<AppConfigs>` then use `.Value` |
| ‚ùå Hardcoded error messages | ‚úÖ Use `ErrorConstants.SYS_XXX_XXXX` |
| ‚ùå Wrong error code format | ‚úÖ Follow `AAA_AAAAAA_DDDD` (3-6-4 format) |
| ‚ùå Lowercase error codes | ‚úÖ All uppercase (SYS_AUTHEN_0001) |
| ‚ùå Full operation names | ‚úÖ Abbreviate to exactly 6 chars (AUTHEN, TSKCRT) |
| ‚ùå Secrets in appsettings.json | ‚úÖ Empty in appsettings, retrieve from KeyVault |
| ‚ùå Config class without "Configs" suffix | ‚úÖ AppConfigs, KeyVaultConfigs |
| ‚ùå Explicitly calling validate() in Program.cs | ‚úÖ Automatic when accessed via IOptions<T>.Value |
| ‚ùå Vendor prefix not 3 chars | ‚úÖ Exactly 3 chars (SYS, VDA, VDB) |
| ‚ùå Number not 4 digits | ‚úÖ 4 digits (0001, 0002, 0003) |

---

## 13. VERIFICATION CHECKLIST

### ConfigModels
- [ ] ConfigModels/ folder at root | [ ] AppConfigs.cs implements IConfigValidator | [ ] Static SectionName property | [ ] validate() method with logic (not empty) | [ ] KeyVaultConfigs.cs (if using KeyVault) | [ ] Registered with Configure<T>() in Program.cs | [ ] IOptions<T> injected (NOT direct) | [ ] Properties initialized with defaults

### Constants
- [ ] Constants/ folder at root | [ ] ErrorConstants.cs exists | [ ] Error codes follow AAA_AAAAAA_DDDD format | [ ] SOR abbreviation (AAA) = 3 uppercase chars | [ ] Operation abbreviation (AAAAAA) = 6 uppercase chars (abbreviated) | [ ] Error series number (DDDD) = 4 digits (0001, 0002) | [ ] Error constants in all exception throws | [ ] InfoConstants.cs exists | [ ] Success messages as const string | [ ] Info constants in BaseResponseDTO | [ ] OperationNames.cs exists | [ ] All operation names are const string | [ ] All names follow <VERB>_<ENTITY> uppercase pattern | [ ] NO string literals for operationName in HTTP client calls

### appsettings.json
- [ ] appsettings.json (placeholder) | [ ] appsettings.dev.json | [ ] appsettings.qa.json | [ ] appsettings.prod.json | [ ] ALL environment files have identical structure (same keys) | [ ] Only values differ between environments | [ ] Secrets empty in placeholder (retrieve from KeyVault) | [ ] Section names match SectionName properties | [ ] Environment-specific values in correct files | [ ] Logging section identical across all files (3 exact lines only)

---

## 14. DO'S & DON'TS

**‚úÖ DO:** Create AppConfigs & KeyVaultConfigs | Implement IConfigValidator | Add static SectionName | Implement validate() with logic | Validate all required fields (URLs, timeouts, ranges) | Register with Configure<T>() | Inject with IOptions<T> | Initialize properties with defaults | Follow AAA_AAAAAA_DDDD format | Use 3-char uppercase SOR abbreviation (AAA) | Use 6-char abbreviated operation (AAAAAA) | Use 4-digit error series number (DDDD) | Define error constants as readonly (string,string) tuple | Define info constants as const string | Create OperationNames.cs with const string for all operation names | Use OperationNames.* constants in all HTTP client calls | Use constants in all exceptions & responses | Store secrets in KeyVault | Create environment-specific appsettings with IDENTICAL structure | Use consistent structure across ALL environments (same keys, different values) | Ensure CI/CD pipeline replaces appsettings.json with environment-specific file

**‚ùå DON'T:** Skip IConfigValidator | Forget static SectionName | Leave validate() empty | Inject AppConfigs directly | Hardcode error messages | Use string literals for operationName parameter | Use incorrect error code format | Store secrets in appsettings.json | Modify Core.Constants.ErrorCodes | Create config classes without "Configs" suffix | Explicitly call validate() in Program.cs | Use lowercase in error codes | Use full operation names | Use vendor prefix != 3 chars | Use number != 4 digits

---

## 15. KEY INVARIANTS (NEVER VIOLATE)

1. **ALL config classes implement IConfigValidator**
2. **ALL config classes have static SectionName property**
3. **ALL config classes implement validate() with logic (not empty)**
4. **validate() called automatically when accessed via IOptions<T>.Value**
5. **ALL configs registered with Configure<T>() in Program.cs**
6. **ALWAYS inject IOptions<T> (NEVER config class directly)**
7. **ALL error codes follow AAA_AAAAAA_DDDD format**
8. **SOR abbreviation (AAA) MUST be exactly 3 uppercase characters**
9. **Operation abbreviation (AAAAAA) MUST be exactly 6 uppercase characters (abbreviated)**
10. **Error series number (DDDD) MUST be exactly 4 digits (0001, 0002, 0003)**
11. **ALL secrets in KeyVault (NEVER in appsettings.json)**
12. **ALL error messages use ErrorConstants (NEVER hardcoded)**
13. **ALL success messages SHOULD use InfoConstants**
14. **ErrorConstants location: Constants/ErrorConstants.cs**
15. **InfoConstants location: Constants/InfoConstants.cs**
16. **OperationNames location: Constants/OperationNames.cs**
17. **NEVER use string literals for operationName in HTTP client calls (use OperationNames.* constants)**
18. **NEVER modify Core.Constants.ErrorCodes (framework-level)**
19. **NEVER explicitly call validate() in Program.cs (automatic)**
20. **ALL environment appsettings files MUST have identical structure (same keys, different values only)**
21. **appsettings.json is a placeholder - CI/CD replaces it with environment-specific file during deployment**

---

## 16. EXAMPLES SUMMARY

**Config Class:** Implements IConfigValidator | Has static SectionName | Has validate() method | Properties initialized  
**Program.cs:** `builder.Services.Configure<AppConfigs>(builder.Configuration.GetSection(AppConfigs.SectionName));` (NO explicit validate())  
**Injection:** `public MyHandler(IOptions<AppConfigs> options) { _appConfigs = options.Value; }` (validation automatic on first .Value access)  
**Error Code:** `public static readonly (string ErrorCode, string Message) SYS_AUTHEN_0001 = ("SYS_AUTHEN_0001", "Authentication to external system failed.");` (Format: AAA_AAAAAA_DDDD where AAA=SYS, AAAAAA=AUTHEN, DDDD=0001)  
**Info Constant:** `public const string GET_ENTITY_SUCCESS = "Entity details retrieved successfully.";`  
**Operation Name:** `public const string CREATE_TASK = "CREATE_TASK";`  
**Usage:** `throw new DownStreamApiFailureException(error: ErrorConstants.SYS_AUTHEN_0001, ...);` | `return new BaseResponseDTO(message: InfoConstants.SUCCESS, ...);` | `await _restClient.ExecuteCustomRestRequestAsync(operationName: OperationNames.CREATE_TASK, ...);`

# Enums, Extensions, Helpers & SoapEnvelopes RULES
*ALL RULES CRITICAL & MANDATORY - NO EXCEPTIONS*

**üìö FRAMEWORK REFERENCE:** Review `Framework/Core` and `Framework/Cache` directories to understand framework-level implementation patterns, base classes, interfaces, and helper methods that these rules build upon.

**üö® BEFORE CREATING:** Read ALL rules in this section before creating Enums/Extensions/Helpers/SoapEnvelopes. Verify correct folder (Extensions/ NOT Helpers/, SoapEnvelopes/ for XML), [StringValue] attribute for enums, and domain-specific vs framework patterns.

## 1. OVERVIEW

| Folder | Purpose | Mandatory | When |
|--------|---------|-----------|------|
| **Enums/** | Domain enumerations | ‚ö†Ô∏è OPTIONAL | Domain enums for business logic |
| **Extensions/** | .NET built-in type extensions | ‚ö†Ô∏è OPTIONAL | Extend string, Dictionary, DateTime, List |
| **Helper/** | Project-specific utilities | ‚ö†Ô∏è OPTIONAL | SOAP/REST/XML/KeyVault operations needed |
| **SoapEnvelopes/** | SOAP XML templates | ‚úÖ MANDATORY (if SOAP) | Project uses SOAP APIs |

---

## 2. ENUMS

### 2.1 Structure & Rules
```
<Project>/Enums/
‚îú‚îÄ‚îÄ EntityStatus.cs      // Status enums
‚îú‚îÄ‚îÄ TaskPriority.cs      // Priority enums
‚îî‚îÄ‚îÄ RequestStatus.cs     // With enum-specific extension
```

üî¥ **CRITICAL:** Use PascalCase | Start from 0 or 1 | File name = Enum name | Use `[StringValue("value")]` from Core.Attributes

### 2.2 Templates

**Simple Enum:**
```csharp
namespace <Namespace>.Enums { public enum EntityStatus { Unknown = 0, Active = 1, Inactive = 2, Pending = 3 } }
```

**With StringValue:**
```csharp
using Core.Attributes;
namespace <Namespace>.Enums { public enum TaskPriority { [StringValue("Low")] Low = 1, [StringValue("Medium")] Medium = 2, [StringValue("High")] High = 3, [StringValue("Critical")] Critical = 4 } }
```

**With Enum-Specific Extension (same file):**
```csharp
using Core.Attributes;
namespace <Namespace>.Enums { public enum RequestStatus { [StringValue("Completed")] Completed = 1, [StringValue("In Progress")] InProgress = 2, }
    public static class RequestStatusExtension { public static List<string> GetDownStreamStatusCodes(this RequestStatus status) { if (status == RequestStatus.Completed) return new List<string> { "API_COMPLETED", "API_CLOSED", "API_DONE" }; else if (status == RequestStatus.InProgress) return new List<string> { "API_INPROGRESS", "API_PENDING", "API_STARTED" }; throw new NotSupportedException(); } } }
```

**Complex Extension Logic:**
```csharp
public enum RequestCategory { [StringValue("General")] General = 1, [StringValue("Urgent")] Urgent = 2, }
public static class RequestCategoryExtensions { public static IList<RequestStatus> GetValidStatuses(this RequestCategory category) { if (category == RequestCategory.General) return new List<RequestStatus>() { RequestStatus.Pending, RequestStatus.InProgress }; if (category == RequestCategory.Urgent) return new List<RequestStatus>() { RequestStatus.InProgress, RequestStatus.Completed }; throw new NotSupportedException("Implementation not supported for " + category.ToString()); } }
```

### 2.3 Usage

**Basic:** `EntityStatus status = EntityStatus.Active; if (status == EntityStatus.Active) { }`

**StringValue:** `string val = balance.GetStringValue(); // "Overtime - Holiday"` | `if (balance.GetStringValue() == apiValue) { }`

**Enum Extension:** `List<string> codes = status.GetDownStreamStatusCodes(); if (codes.Contains(externalCode)) { }`

**In Handler:** Map internal enum to downstream codes ‚Üí Use in atomic request ‚Üí Process response

**In Mapping:** Group balances by category using enum extension ‚Üí Filter API response by category balances

### 2.4 Enum-Specific Extensions

**Rules:** ‚úÖ Define in SAME file as enum | ‚úÖ Naming: `<EnumName>Extension` or `<EnumName>Extensions` | ‚úÖ Only methods specific to that enum | ‚úÖ Use for: mapping to external values, grouping, categorization, validation | ‚ùå NOT in Extensions/ folder

**Use Cases:** Mapping enum ‚Üí external system values | Grouping/categorization | Validation logic | Conditional behavior

**vs Generic Extensions:** Enum-specific (Enums/ folder, same file) | Generic (Extensions/ folder, .NET types)

### 2.6 Enums vs Constants

| Use Case | Enums | Constants |
|----------|-------|-----------|
| Status Codes | ‚úÖ Better | ‚ö†Ô∏è Possible |
| Categories/Types | ‚úÖ Yes | ‚ùå No |
| Error Messages | ‚ùå No | ‚úÖ ErrorConstants |
| Success Messages | ‚ùå No | ‚úÖ InfoConstants |
| Mapping Logic | ‚úÖ Enum extensions | ‚ùå No |

---

## 3. EXTENSIONS

### 3.1 Structure & Rules
```
<Project>/Extensions/
‚îú‚îÄ‚îÄ StringExtensions.cs     // String operations
‚îú‚îÄ‚îÄ DateTimeExtensions.cs   // DateTime operations
‚îî‚îÄ‚îÄ DictionaryExtensions.cs // Dictionary operations
```

üî¥ **CRITICAL:** `public static class` | `public static` methods | First param uses `this` | ONLY .NET built-in types | NO vendor names (CAFMExtensions) | NO domain logic (WorkOrderExtensions) | Import `using Core.Extensions;` for GetStringValue()

**üî¥ NON-NEGOTIABLE RULE:** All simple conversion or helper functionality MUST first leverage existing Core Framework extension methods (`Core.Extensions`). Only create new extension methods if the Core Framework does not provide a suitable option. This ensures uniform and reusable code across all components (DTOs, Handlers, Atomic Handlers, Services, etc.). **BEFORE creating any extension method, verify Core Framework extensions first.**

### 3.2 Allowed Extensions

| Class | Purpose | Methods | Patterns |
|-------|---------|---------|----------|
| StringExtensions | String ops | IsNullOrWhiteSpace(), ToTitleCase(), IsOfRecordType<TEnum>() | Null-safe, enum comparison |
| DateTimeExtensions | DateTime ops | GetDefaultDateRange(), ValidateMinimumDate(), ValidateDateRange() | Tuple returns, validation |
| DictionaryExtensions | Dictionary ops | AddOrUpdate(), GetValueOrDefault() | Safe access |
| HttpRequestExtensions | HTTP helpers | ReadBodyAsync<T>(), GetHeaderValue() | Async |
| ListExtensions | Collection ops | IsNullOrEmpty(), AddRange() | Collection |

### 3.3 Templates

**StringExtensions:**
```csharp
using Core.Extensions;
namespace <Namespace>.Extensions { public static class StringExtensions { public static bool IsNullOrWhiteSpace(this string? value) => string.IsNullOrWhiteSpace(value); public static string ToUpperSafe(this string? value) => value?.ToUpper() ?? string.Empty; public static bool IsOfRecordType<TEnum>(this string recordType, TEnum enumValue) where TEnum : Enum { return string.Equals(recordType, enumValue.GetStringValue(), StringComparison.OrdinalIgnoreCase); } } }
```

**DateTimeExtensions:**
```csharp
namespace <Namespace>.Extensions { public static class DateTimeExtensions { public static (DateTime startDate, DateTime endDate) GetDefaultDateRange(this DateTime referenceDate) { DateTime threeMonthsAgo = referenceDate.AddMonths(-3); DateTime startDate = new DateTime(threeMonthsAgo.Year, threeMonthsAgo.Month, 1); DateTime prevMonth = referenceDate.AddMonths(-1); DateTime endDate = new DateTime(prevMonth.Year, prevMonth.Month, DateTime.DaysInMonth(prevMonth.Year, prevMonth.Month)); return (startDate, endDate); }
        public static void ValidateMinimumDate(this DateTime? date, string fieldName, DateTime minimumDate, List<string> errors) { if (date.HasValue && date < minimumDate) errors.Add($"{fieldName} cannot be earlier than {minimumDate:MMM d, yyyy}."); }
        public static void ValidateDateRange(this DateTime? startDate, DateTime? endDate, string startFieldName, string endFieldName, List<string> errors) { if (startDate.HasValue && endDate.HasValue && endDate < startDate) errors.Add($"{endFieldName} cannot be earlier than {startFieldName}."); }
        public static DateTime GetFirstDayOfMonth(this DateTime date) => new DateTime(date.Year, date.Month, 1); public static DateTime GetLastDayOfMonth(this DateTime date) => new DateTime(date.Year, date.Month, DateTime.DaysInMonth(date.Year, date.Month)); } }
```

**DictionaryExtensions:**
```csharp
namespace <Namespace>.Extensions { public static class DictionaryExtensions { public static TValue GetValueOrDefault<TKey, TValue>(this Dictionary<TKey, TValue> dictionary, TKey key, TValue defaultValue = default) { return dictionary.ContainsKey(key) ? dictionary[key] : defaultValue; }
        public static void AddOrUpdate<TKey, TValue>(this Dictionary<TKey, TValue> dictionary, TKey key, TValue value) { if (dictionary.ContainsKey(key)) dictionary[key] = value; else dictionary.Add(key, value); } } }
```

### 3.4 Common Patterns

**Pattern 1 - Tuple Return:** Use for multiple related values | `(Type1 name1, Type2 name2)` | Example: `var (start, end) = DateTime.Now.GetDefaultDateRange();`

**Pattern 2 - Validation:** Void return | Accepts `List<string> errors` | Adds messages to list | Example: `StartDate.ValidateMinimumDate("Start Date", minDate, errors);`

**Pattern 3 - Generic Enum Comparison:** `<TEnum> where TEnum : Enum` | Uses `enumValue.GetStringValue()` | Case-insensitive | Example: `if (apiValue.IsOfRecordType(TaskPriority.High)) { }`

**Pattern 4 - Safe Ops:** Return default/empty on null | Naming: "Safe" suffix or "OrDefault" | Example: `value?.ToUpper() ?? string.Empty`

### 3.5 Usage Examples

**Tuple Return:** `var (defaultStart, defaultEnd) = DateTime.Now.GetDefaultDateRange(); StartDate ??= defaultStart; EndDate ??= defaultEnd;`

**Validation:** `List<string> errors = new(); StartDate.ValidateMinimumDate("Start Date", minDate, errors); StartDate.ValidateDateRange(EndDate, "Start Date", "End Date", errors); if (errors.Any()) throw new RequestValidationFailureException(...);`

**Enum Comparison:** `if (apiTaskPriority.IsOfRecordType(TaskPriority.High)) { // Match! }`

### 3.6 Extensions vs Helpers Decision

| Question | Answer | Action |
|----------|--------|--------|
| Extending .NET built-in type? | YES | ‚úÖ Extensions/ folder |
| Project-specific utility? | YES | ‚úÖ Helper/ folder |
| SOAP operations? | YES | ‚úÖ SOAPHelper.cs |
| REST operations? | YES | ‚úÖ RestApiHelper.cs (optional) |
| XML to JSON? | YES | ‚úÖ XMLHelper.cs |
| KeyVault? | YES | ‚úÖ KeyVaultReader.cs |

---

## 4. HELPERS

### 4.1 Structure & Rules
```
<Project>/Helper/  // ‚Üê Singular, NOT Helpers/
‚îú‚îÄ‚îÄ SOAPHelper.cs        // MANDATORY if SOAP
‚îú‚îÄ‚îÄ KeyVaultReader.cs    // MANDATORY if KeyVault
‚îú‚îÄ‚îÄ RestApiHelper.cs     // OPTIONAL (Core provides)
‚îî‚îÄ‚îÄ XMLHelper.cs         // OPTIONAL (XML to JSON)
```

üî¥ **CRITICAL:** Folder is `Helper/` (singular) | `public static class` | `public static` methods | Use ServiceLocator for ILogger | Import Core.Extensions.LoggerExtensions | Specific names (NOT Utils, Common)

| Helper | Mandatory | When | Methods |
|--------|-----------|------|---------|
| **CustomSoapClient** | ‚úÖ If SOAP | Uses SOAP APIs | ExecuteCustomSoapRequestAsync(), CreateSoapContent() - **YOU MUST CREATE** (NOT in Framework) |
| **SOAPHelper** | ‚úÖ If SOAP | Uses SOAP APIs | LoadSoapEnvelopeTemplate(), GetSoapElement(), MapSOAPRespone(), DeserializeSoapResponse() |
| **KeyVaultReader** | ‚úÖ If KeyVault | Needs KeyVault secrets | GetSecretAsync(), GetSecretsAsync() (with caching) |
| **RestApiHelper** | ‚ö†Ô∏è Optional | Uses REST (Core provides) | DeserializeJsonResponse(), BuildUrl(), HandleFileResponse() |
| **XMLHelper** | ‚ö†Ô∏è Optional | XML to JSON | ConvertXmlToJson() |

### 4.2 SOAPHelper (MANDATORY if SOAP)

**Location:** `<Project>/Helpers/SOAPHelper.cs` (static class, NO registration)

**Works With:** `CustomSoapClient` (also in Helpers/) - **SOAPHelper** loads/builds envelopes (static utility), **CustomSoapClient** executes SOAP HTTP calls (injected service)

**Pattern 1 - LoadSoapEnvelopeTemplate():**
```csharp
using Core.Extensions; using Core.DI; using Microsoft.Extensions.Logging;
public static class SOAPHelper { public static string LoadSoapEnvelopeTemplate(string resourceName) { ILogger<SOAPHelper> logger = ServiceLocator.GetRequiredService<ILogger<SOAPHelper>>(); logger.Info($"Loading SOAP envelope: {resourceName}"); System.Reflection.Assembly assembly = typeof(SOAPHelper).Assembly; using System.IO.Stream? stream = assembly.GetManifestResourceStream(resourceName); if (stream == null) throw new FileNotFoundException($"SOAP template not found: {resourceName}"); using System.IO.StreamReader reader = new StreamReader(stream); return reader.ReadToEnd(); } }
```

**Pattern 2 - GetSoapElement():**
```csharp
public static string GetSoapElement(string elementName, string? value)
{
    return string.IsNullOrWhiteSpace(value) ? string.Empty : $"<{elementName}>{value}</{elementName}>";
}
```

**Pattern 3 - MapSOAPRespone() (CSV data):**
```csharp
public static List<T> MapSOAPRespone<T>(string csvData) where T : new()
{
    ILogger<SOAPHelper> logger = ServiceLocator.GetRequiredService<ILogger<SOAPHelper>>();
    logger.Info("Mapping SOAP CSV response");
    // Parse CSV ‚Üí List<T>
    return csvDataList;
}
```

**Pattern 4 - DeserializeSoapResponse():**
```csharp
public static TResponse? DeserializeSoapResponse<TResponse>(string xmlContent, JsonSerializerOptions? jsonOptions = null)
{
    string json = XMLHelper.ConvertXmlToJson(xmlContent);
    return JsonSerializer.Deserialize<TResponse>(json, jsonOptions);
}
```

**Usage:** `string template = SOAPHelper.LoadSoapEnvelopeTemplate($"{_appConfigs.ProjectNamespace}.SoapEnvelopes.CreateTask.xml"); string envelope = template.Replace("{{TaskNumber}}", dto.TaskNumber); string element = SOAPHelper.GetSoapElement("Priority", dto.Priority); CreateTaskApiResDTO? response = SOAPHelper.DeserializeSoapResponse<CreateTaskApiResDTO>(xmlContent);`

### 4.3 RestApiHelper (OPTIONAL)

**Note:** Core Framework provides RestApiHelper. Create ONLY if custom logic needed.

**Pattern 1 - DeserializeJsonResponse():**
```csharp
public static class RestApiHelper { public static T DeserializeJsonResponse<T>(string jsonContent) { ILogger<RestApiHelper> logger = ServiceLocator.GetRequiredService<ILogger<RestApiHelper>>(); logger.Info($"Deserializing JSON to {typeof(T).Name}"); return JsonSerializer.Deserialize<T>(jsonContent, new JsonSerializerOptions { PropertyNameCaseInsensitive = true }); } }
```

**Pattern 2 - BuildUrl():** `public static string BuildUrl(string baseUrl, Dictionary<string, string> queryParams) { string query = string.Join("&", queryParams.Select(kv => $"{kv.Key}={Uri.EscapeDataString(kv.Value)}")); return $"{baseUrl}?{query}"; }`

**Pattern 3 - HandleFileResponse():** For file downloads

### 4.4 XMLHelper (OPTIONAL)

**Purpose:** XML to JSON conversion for SOAP responses

```csharp
using Newtonsoft.Json; using System.Xml;
public static class XMLHelper { public static string ConvertXmlToJson(string xmlContent) { ILogger<XMLHelper> logger = ServiceLocator.GetRequiredService<ILogger<XMLHelper>>(); logger.Info("Converting XML to JSON"); XmlDocument doc = new XmlDocument(); doc.LoadXml(xmlContent); return JsonConvert.SerializeXmlNode(doc); } }
```

**Usage:** `string json = XMLHelper.ConvertXmlToJson(soapResponse); ApiResDTO? dto = JsonSerializer.Deserialize<ApiResDTO>(json);`

### 4.5 KeyVaultReader (MANDATORY if KeyVault)

**Location:** `<Project>/Helper/KeyVaultReader.cs`

**Pattern 1 - GetSecretAsync():**
```csharp
using Azure.Identity; using Azure.Security.KeyVault.Secrets;
public class KeyVaultReader { private readonly SecretClient _secretClient; private readonly ILogger<KeyVaultReader> _logger;
    public KeyVaultReader(IOptions<KeyVaultConfigs> options, ILogger<KeyVaultReader> logger) { _logger = logger; Uri keyVaultUrl = new Uri(options.Value.KeyVaultUrl); _secretClient = new SecretClient(keyVaultUrl, new DefaultAzureCredential()); }
    public async Task<string> GetSecretAsync(string secretName) { _logger.Info($"Fetching secret: {secretName}"); KeyVaultSecret secret = await _secretClient.GetSecretAsync(secretName); return secret.Value; } }
```

**Pattern 2 - GetSecretsAsync() (with caching):**
```csharp
private static readonly Dictionary<string, string> _secretCache = new(); private static readonly SemaphoreSlim _cacheLock = new SemaphoreSlim(1, 1);
public async Task<Dictionary<string, string>> GetSecretsAsync(List<string> secretNames) { await _cacheLock.WaitAsync(); try { Dictionary<string, string> result = new Dictionary<string, string>(); foreach (string secretName in secretNames) { if (!_secretCache.ContainsKey(secretName)) { _logger.Info($"Caching secret: {secretName}"); _secretCache[secretName] = await GetSecretAsync(secretName); } result[secretName] = _secretCache[secretName]; } return result; } finally { _cacheLock.Release(); } }
```

**Usage:** `string secret = await _keyVaultReader.GetSecretAsync("MySecret"); Dictionary<string, string> secrets = await _keyVaultReader.GetSecretsAsync(new List<string> { "Secret1", "Secret2" });`

**Program.cs Registration:** `builder.Services.AddSingleton<KeyVaultReader>();`

---

## 5. SOAPENVELOPES

### 5.1 Structure & Rules
```
<Project>/SoapEnvelopes/  // MANDATORY if SOAP
‚îú‚îÄ‚îÄ CreateTask.xml
‚îú‚îÄ‚îÄ UpdateTask.xml
‚îú‚îÄ‚îÄ Authenticate.xml
‚îî‚îÄ‚îÄ GetTaskDetails.xml
```

üî¥ **CRITICAL:** Store ALL SOAP XML in SoapEnvelopes/ | Register as embedded resources in .csproj | Use `{{PlaceholderName}}` convention | NEVER hardcode SOAP XML in code | Use CustomSoapClient | Load via SOAPHelper.LoadSoapEnvelopeTemplate()

### 5.2 SOAP Template Example

**CreateTask.xml:**
```xml
<!-- SoapEnvelopes/CreateTask.xml -->
<soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/" xmlns:web="http://example.com/webservices"><soap:Header><web:Authentication><web:Username>{{Username}}</web:Username><web:Password>{{Password}}</web:Password><web:SessionId>{{SessionId}}</web:SessionId></web:Authentication></soap:Header><soap:Body><web:CreateTask><web:TaskNumber>{{TaskNumber}}</web:TaskNumber><web:Description>{{Description}}</web:Description><web:Priority>{{Priority}}</web:Priority><web:DueDate>{{DueDate}}</web:DueDate></web:CreateTask></soap:Body></soap:Envelope>
```

**Placeholder Convention:** `{{ParameterName}}` | Use PascalCase | Replace with `.Replace("{{Name}}", value)`

### 5.3 Register as Embedded Resources

**In .csproj:**
```xml
<ItemGroup>
  <EmbeddedResource Include="SoapEnvelopes\*.xml" />
</ItemGroup>
```

**Or individually:** `<EmbeddedResource Include="SoapEnvelopes\CreateTask.xml" />`

**Verify:** Right-click XML ‚Üí Properties ‚Üí Build Action ‚Üí Embedded Resource

### 5.4 Usage in Atomic Handler

```csharp
public class CreateTaskAtomicHandler : IAtomicHandler<HttpResponseSnapshot> { private readonly CustomSoapClient _soapClient; private readonly AppConfigs _appConfigs;
    public CreateTaskAtomicHandler(CustomSoapClient soapClient, IOptions<AppConfigs> options) { _soapClient = soapClient; _appConfigs = options.Value; }
    public async Task<HttpResponseSnapshot> Handle(IDownStreamRequestDTO request) { CreateTaskHandlerReqDTO dto = request as CreateTaskHandlerReqDTO; dto?.ValidateDownStreamRequestParameters(); string resourceName = $"{_appConfigs.ProjectNamespace}.SoapEnvelopes.CreateTask.xml"; string template = SOAPHelper.LoadSoapEnvelopeTemplate(resourceName); string soapEnvelope = template.Replace("{{Username}}", dto.Username).Replace("{{Password}}", dto.Password).Replace("{{SessionId}}", dto.SessionId ?? string.Empty).Replace("{{TaskNumber}}", dto.TaskNumber).Replace("{{Description}}", dto.Description).Replace("{{Priority}}", dto.Priority).Replace("{{DueDate}}", dto.DueDate?.ToString("yyyy-MM-dd") ?? string.Empty); return await _soapClient.ExecuteSoapRequestAsync(operationName: "CreateTask", apiUrl: _appConfigs.SoapEndpointUrl, soapEnvelope: soapEnvelope, soapActionUrl: "http://example.com/webservices/CreateTask"); } }
```

**Resource Name Format:** `<Namespace>.SoapEnvelopes.<FileName>.xml`

### 5.5 Optional Elements

**Approach 1 - Conditional:** `soapEnvelope = soapEnvelope.Replace("{{Priority}}", dto.Priority ?? string.Empty);`

**Approach 2 - GetSoapElement():** `string priorityElement = SOAPHelper.GetSoapElement("web:Priority", dto.Priority); // Returns "" if null or "<web:Priority>High</web:Priority>" if not`

### 5.6 CustomSoapClient (Project-Specific Helper - YOU MUST CREATE)

**üî¥ IMPORTANT:** `CustomSoapClient` is NOT in Framework. You must create it in `Helpers/CustomSoapClient.cs` for SOAP integrations.

**Location:** `<ProjectName>/Helper/CustomSoapClient.cs`

**Purpose:** Wraps `CustomHTTPClient` for SOAP operations + includes performance timing

**Complete Implementation Reference:** See Section "# Atomic Handler RULES" ‚Üí "10. HTTP CLIENT PATTERNS" ‚Üí "B. SOAP API Calls" for real example from Facilities Management repo.

**Key Methods:**
- `ExecuteCustomSoapRequestAsync(operationName, soapEnvelope, apiUrl, soapActionUrl, httpMethod)` - Returns `HttpResponseSnapshot`
- `CreateSoapContent(soapEnvelope, soapActionUrl)` - Returns `StringContent` with SOAPAction header

**Registration (Program.cs):** `builder.Services.AddScoped<CustomSoapClient>();`

**Usage in Atomic Handler:**
```csharp
HttpResponseSnapshot response = await _soapClient.ExecuteCustomSoapRequestAsync(operationName: "CREATE_WORK_ORDER", soapEnvelope: soapEnvelope, apiUrl: _appConfigs.SoapEndpointUrl, soapActionUrl: _appConfigs.SoapActionUrl, httpMethod: HttpMethod.Post);
```

### 5.7 Deserialize SOAP Response (in Handler)

```csharp
public async Task<BaseResponseDTO> HandleAsync(CreateTaskReqDTO request) { HttpResponseSnapshot response = await _createTaskAtomicHandler.Handle(atomicRequest); if (!response.IsSuccessStatusCode) throw new DownStreamApiFailureException(statusCode: (HttpStatusCode)response.StatusCode, error: ErrorConstants.SYS_CREATE_0001, errorDetails: [$"SOAP failed. Response: {response.Content}"], stepName: "CreateTaskHandler / HandleAsync"); CreateTaskApiResDTO? apiResponse = SOAPHelper.DeserializeSoapResponse<CreateTaskApiResDTO>(response.Content!); if (apiResponse == null) throw new NoResponseBodyException(error: ErrorConstants.SYS_CREATE_0002, errorDetails: ["Failed to deserialize SOAP response"], stepName: "CreateTaskHandler / HandleAsync"); return new BaseResponseDTO(message: InfoConstants.CREATE_TASK_SUCCESS, errorCode: null, data: CreateTaskResDTO.Map(apiResponse)); }
```

### 5.8 Troubleshooting

**"Resource not found":** Check .csproj has `<EmbeddedResource>` | Verify resource name: `<Namespace>.SoapEnvelopes.<FileName>.xml` | Build Action = Embedded Resource | Rebuild

**Deserialization fails:** Verify XML structure matches DTO | Check namespaces | Use JsonSerializerOptions for case-insensitive | Test XML to JSON separately

**SOAPAction not sent:** Ensure `soapActionUrl` provided | Check API requirements | Verify CustomSoapClient.CreateSoapContent() adds header

**Placeholder not replaced:** Check format: `{{Name}}` (double braces) | Case-sensitive match | Call .Replace() for all placeholders

---

## 6. COMMON MISTAKES

**‚ùå Vendor names in Extensions:** Extensions/CAFMExtensions.cs ‚Üí ‚úÖ Helper/CAFMHelper.cs

**‚ùå Domain logic in Extensions:** Extensions/WorkOrderExtensions.cs ‚Üí ‚úÖ Helper/WorkOrderHelper.cs OR enum-specific extension in Enums/

**‚ùå Instance-based helper:** `public class SOAPHelper` ‚Üí ‚úÖ `public static class SOAPHelper`

**‚ùå Missing Enums folder when needed:** No Enums/ but using magic strings ‚Üí ‚úÖ Create Enums/ with proper enums

**‚ùå Not using ServiceLocator:** Direct ILogger injection in static ‚Üí ‚úÖ `ServiceLocator.GetRequiredService<ILogger<T>>()`

**‚ùå Wrong extension signature:** `public static string Reverse(string value)` ‚Üí ‚úÖ `public static string Reverse(this string value)`

**‚ùå Creating empty Enums/:** Empty folder ‚Üí ‚úÖ Only create if have enums

**‚ùå Not registering KeyVaultReader:** Not in DI ‚Üí ‚úÖ `builder.Services.AddSingleton<KeyVaultReader>();`

**‚ùå Enum extension in wrong location:** Extensions/RequestStatusExtensions.cs ‚Üí ‚úÖ In same file as enum in Enums/

**‚ùå Not using tuple returns:** Separate methods for related values ‚Üí ‚úÖ `(DateTime start, DateTime end) GetDefaultDateRange()`

**‚ùå Wrong validation pattern:** Returns bool, caller creates error ‚Üí ‚úÖ Void return + `List<string> errors` parameter

**‚ùå Not using Core.Extensions:** Manual enum.ToString() ‚Üí ‚úÖ Import Core.Extensions | Use `enumValue.GetStringValue()`

**‚ùå Hardcoding SOAP XML:** XML in code ‚Üí ‚úÖ SoapEnvelopes/ folder + embedded resource

**‚ùå Not registering SOAP templates:** Missing .csproj entry ‚Üí ‚úÖ `<EmbeddedResource Include="SoapEnvelopes\*.xml" />`

---

## 7. VERIFICATION CHECKLIST

### Enums
- [ ] Enums/ created only if needed | PascalCase names | Start 0/1 | `[StringValue]` from Core.Attributes | Enum-specific extensions in same file | Extension naming: `<EnumName>Extension(s)`

### Extensions
- [ ] Extensions/ created only if needed | Named `<TypeName>Extensions.cs` | NO vendor/domain names | `public static class` | `this` keyword | Only .NET types | Import `using Core.Extensions;` | Tuple returns for multiple values | Validation: void + `List<string> errors` | Generic methods: `<TEnum> where TEnum : Enum` | Null-safe ops | **üî¥ NON-NEGOTIABLE: Checked Core Framework extensions FIRST** - Only created new extension if Core Framework does not provide suitable option

### Helpers
- [ ] Helper/ (singular) | SOAPHelper if SOAP | KeyVaultReader if KeyVault | `public static class` | ServiceLocator for ILogger | Core.Extensions.LoggerExtensions | Specific names (NOT Utils)

### SoapEnvelopes
- [ ] SoapEnvelopes/ if SOAP | SOAP XML in folder | `{{PlaceholderName}}` | Embedded resources in .csproj | Build Action = Embedded Resource | CustomSoapClient | SOAPHelper.LoadSoapEnvelopeTemplate() | Resource format: `<Namespace>.SoapEnvelopes.<File>.xml`

---

## 8. DO'S & DON'TS

### ‚úÖ DO
- **Enums:** Create only if needed | PascalCase | Start 0/1 | [StringValue] attribute | Enum-specific extensions in same file | Use GetStringValue() | Map to external values
- **Extensions:** Only .NET types | `<TypeName>Extensions.cs` | `public static class` | `this` keyword | Tuple returns | Validation pattern (void + errors) | Generic enum methods | Import Core.Extensions | **üî¥ NON-NEGOTIABLE: Check Core Framework extensions FIRST** - Only create new extensions if Core Framework does not provide suitable option
- **Helpers:** SOAPHelper if SOAP | KeyVaultReader if KeyVault | `public static class` | ServiceLocator for ILogger | Core.Extensions logging | Specific names | **üî¥ NON-NEGOTIABLE: Check Core Framework helpers FIRST** - Leverage existing Core Framework functionality before creating new helpers
- **SoapEnvelopes:** Store all SOAP XML | `{{PlaceholderName}}` | Embedded resources | CustomSoapClient | SOAPHelper to load | Replace placeholders | Handle optional | Log operations

### ‚ùå DON'T
- **Enums:** Empty folder | Magic strings when enum appropriate | Put enum extensions in Extensions/
- **Extensions:** Vendor names | Domain logic | WorkOrderExtensions | Instance classes | Forget `this` | UtilsExtensions | Return bool for validation | Use enum.ToString() | **üî¥ NON-NEGOTIABLE: Create new extensions without checking Core Framework FIRST** - Always verify Core Framework extensions before creating new ones
- **Helpers:** Mix concerns | Instance classes | Generic names | Direct ILogger injection | Forget Core.Extensions import | **üî¥ NON-NEGOTIABLE: Create new helpers without checking Core Framework FIRST** - Always leverage Core Framework functionality before creating new helpers
- **SoapEnvelopes:** Hardcode SOAP XML | Skip embedded resource | Other placeholder formats | Log sensitive data | Custom HTTP clients | Throw in Atomic Handler

---

## 9. KEY INVARIANTS (NEVER VIOLATE)

### Enums
1. Enums/ OPTIONAL (only if domain enums needed) | 2. PascalCase, singular | 3. File name = enum name | 4. [StringValue] from Core.Attributes | 5. Enum-specific extensions in SAME file | 6. Extension naming: `<EnumName>Extension(s)`

### Extensions
7. Extensions/ OPTIONAL (only .NET types) | 8. Named `<TypeName>Extensions.cs` | 9. NEVER vendor names | 10. NEVER domain logic | 11. `public static class` | 12. `this` keyword | 13. Import Core.Extensions | 14. Tuple returns for multiple values | 15. Validation: void + List<string> errors | 16. Generic: `<TEnum> where TEnum : Enum` | 17. **üî¥ NON-NEGOTIABLE: Check Core Framework extensions FIRST** - Only create new extensions if Core Framework does not provide suitable option

### Helpers
17. Helper/ (singular) | 18. SOAPHelper MANDATORY if SOAP | 19. KeyVaultReader MANDATORY if KeyVault | 20. `public static class` | 21. ServiceLocator for ILogger | 22. Core.Extensions.LoggerExtensions | 23. Specific names (NOT Utils)

### SoapEnvelopes
24. SoapEnvelopes/ MANDATORY if SOAP | 25. All SOAP XML in folder | 26. Embedded resources in .csproj | 27. `{{PlaceholderName}}` convention | 28. NEVER hardcode SOAP XML | 29. CustomSoapClient for requests | 30. SOAPHelper.LoadSoapEnvelopeTemplate() | 31. Resource: `<Namespace>.SoapEnvelopes.<File>.xml` | 32. Deserialize in Handler (NOT Atomic Handler) | 33. NEVER log sensitive data


# Program.cs RULES
*ALL RULES CRITICAL & MANDATORY - NO EXCEPTIONS*

**üìö FRAMEWORK REFERENCE:** Review `Framework/Core` and `Framework/Cache` directories to understand framework-level implementation patterns, base classes, interfaces, and helper methods that these rules build upon.

**üö® BEFORE CREATING:** Read ALL rules in this section before creating/modifying Program.cs. Verify NON-NEGOTIABLE registration order, middleware sequence, and all mandatory configurations.

## COMPLETE TEMPLATE (Copy Exactly)

```csharp
// Using Statements
using Cache.Extensions; using Core.DI; using Core.Middlewares; using Core.SystemLayer.Middlewares;
using <ProjectName>.Abstractions; using <ProjectName>.ConfigModels; using <ProjectName>.Helper;
using <ProjectName>.Implementations.<Vendor>.AtomicHandlers.*; using <ProjectName>.Implementations.<Vendor>.Handlers;
using <ProjectName>.Implementations.<Vendor>.Services; using <ProjectName>.Middleware;
using Microsoft.Azure.Functions.Worker; using Microsoft.Azure.Functions.Worker.Builder;
using Microsoft.Extensions.Configuration; using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting; using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Logging.ApplicationInsights; using Microsoft.Extensions.Options;
using Polly; using System.Text.Json; using System.Text.Json.Serialization;

FunctionsApplicationBuilder builder = FunctionsApplication.CreateBuilder(args);
string environment = Environment.GetEnvironmentVariable("ENVIRONMENT") ?? Environment.GetEnvironmentVariable("ASPNETCORE_ENVIRONMENT") ?? "dev";
builder.Configuration.AddJsonFile("appsettings.json", optional: true, reloadOnChange: true).AddJsonFile($"appsettings.{environment}.json", optional: true, reloadOnChange: true).AddEnvironmentVariables();
builder.Services.AddApplicationInsightsTelemetryWorkerService().ConfigureFunctionsApplicationInsights();
builder.Logging.AddConsole(); builder.Logging.AddFilter<ApplicationInsightsLoggerProvider>("", LogLevel.Information);
builder.Services.Configure<AppConfigs>(builder.Configuration.GetSection(AppConfigs.SectionName)); builder.Services.Configure<KeyVaultConfig>(builder.Configuration.GetSection(KeyVaultConfig.SectionName)); builder.Services.Configure<CacheKeySettings>(builder.Configuration.GetSection(AppConfigs.CacheSectionName));
builder.ConfigureFunctionsWebApplication(); builder.Services.AddHttpClient<CustomHTTPClient>();
builder.Services.Configure<JsonSerializerOptions>(options => { options.Converters.Add(new JsonStringEnumConverter()); options.PropertyNameCaseInsensitive = true; });
builder.Services.AddScoped<IYourDomainMgmt, YourDomainService>(); builder.Services.AddScoped<IAnotherDomainMgmt, AnotherDomainService>();
builder.Services.AddScoped<CustomRestClient>(); builder.Services.AddScoped<CustomHTTPClient>(); builder.Services.AddScoped<CustomSoapClient>(); builder.Services.AddScoped<CustomSmtpClient>();
builder.Services.AddSingleton<KeyVaultReader>(); builder.Services.AddTransient<YourHelperClass>();
builder.Services.AddScoped<YourOperationHandler>(); builder.Services.AddScoped<AnotherOperationHandler>();
builder.Services.AddScoped<YourOperationAtomicHandler>(); builder.Services.AddScoped<AnotherOperationAtomicHandler>(); builder.Services.AddScoped<AuthenticateAtomicHandler>(); builder.Services.AddScoped<LogoutAtomicHandler>();
builder.Services.AddRedisCacheLibrary(builder.Configuration);
builder.Services.AddSingleton<IAsyncPolicy<HttpResponseMessage>>(sp => { IConfiguration config = sp.GetRequiredService<IConfiguration>(); IAsyncPolicy<HttpResponseMessage> retryPolicy = Policy.Handle<HttpRequestException>().OrResult<HttpResponseMessage>(r => (int)r.StatusCode >= 500).WaitAndRetryAsync(retryCount: config.GetValue<int>("HttpClientPolicy:RetryCount", 0), sleepDurationProvider: retryAttempt => TimeSpan.FromSeconds(retryAttempt * 5)); IAsyncPolicy<HttpResponseMessage> timeoutPolicy = Policy.TimeoutAsync<HttpResponseMessage>(config.GetValue<int>("HttpClientPolicy:TimeoutSeconds", 60)); return Policy.WrapAsync(retryPolicy, timeoutPolicy); });
builder.UseMiddleware<ExecutionTimingMiddleware>(); builder.UseMiddleware<ExceptionHandlerMiddleware>(); builder.UseMiddleware<CustomAuthenticationMiddleware>();
ServiceLocator.ServiceProvider = builder.Services.BuildServiceProvider();
builder.Build().Run();
```

---

## REGISTRATION ORDER (NON-NEGOTIABLE)

| # | Section | Required | Purpose |
|---|---------|----------|---------|
| 1 | Builder Creation | ‚úÖ | Create function app |
| 2 | Environment Detection | ‚úÖ | ENVIRONMENT ‚Üí ASPNETCORE_ENVIRONMENT ‚Üí "dev" |
| 3 | Configuration Loading | ‚úÖ | appsettings.json ‚Üí appsettings.{env}.json ‚Üí Environment vars |
| 4 | Application Insights | ‚úÖ | FIRST service registration |
| 5 | Logging | ‚úÖ | Console + App Insights filter |
| 6 | Configuration Models | ‚úÖ | Bind AppConfigs, KeyVaultConfig, CacheKeySettings |
| 7 | Functions Web App | ‚úÖ | ConfigureFunctionsWebApplication + AddHttpClient |
| 8 | JSON Options | ‚ö†Ô∏è | JsonStringEnumConverter (if enums) |
| 9 | Services | ‚úÖ | WITH interfaces: AddScoped<IInterface, Implementation>() |
| 10 | HTTP/SOAP Clients | ‚úÖ | CustomRestClient, CustomHTTPClient, CustomSoapClient, CustomSmtpClient |
| 11 | Singletons/Helpers | ‚ö†Ô∏è | KeyVaultReader, domain helpers |
| 12 | Handlers | ‚úÖ | CONCRETE only: AddScoped<ConcreteHandler>() |
| 13 | Atomic Handlers | ‚úÖ | CONCRETE only + auth handlers |
| 14 | Cache Library | ‚ö†Ô∏è | AddRedisCacheLibrary (if Redis) |
| 15 | Polly Policy | ‚úÖ | Retry + timeout |
| 16 | Middleware | ‚úÖ | ExecutionTiming ‚Üí Exception ‚Üí CustomAuth |
| 17 | Service Locator | ‚ö†Ô∏è | BuildServiceProvider (if static helpers) |
| 18 | Build & Run | ‚úÖ | LAST line |

**üî¥ CRITICAL:** Cannot reorder. Cannot skip mandatory sections.

---

## CRITICAL RULES

### Environment Detection
```csharp
string environment = Environment.GetEnvironmentVariable("ENVIRONMENT") ?? Environment.GetEnvironmentVariable("ASPNETCORE_ENVIRONMENT") ?? "dev";
```
**Fallback:** ENVIRONMENT ‚Üí ASPNETCORE_ENVIRONMENT ‚Üí "dev" | **Values:** "dev", "qa", "stg", "prod", "dr"

### Configuration Models
```csharp
builder.Services.Configure<T>(builder.Configuration.GetSection(T.SectionName));
```
**Rules:** Use `SectionName` static property | Config class implements `IConfigValidator` | Do NOT call `validate()` (automatic on first access)

### Services Registration (WITH Interfaces)
```csharp
builder.Services.AddScoped<IInterface, Implementation>(); // ‚úÖ CORRECT
builder.Services.AddScoped<Implementation>();              // ‚ùå WRONG
```
**Why interfaces:** DI in Functions | Vendor-specific implementations | Testing with mocks

### Handlers/Atomic Handlers (CONCRETE, NO Interfaces)
```csharp
builder.Services.AddScoped<YourHandler>();              // ‚úÖ CORRECT
builder.Services.AddScoped<IBaseHandler<T>, Handler>(); // ‚ùå WRONG
```
**Why concrete:** Operation-specific | Services inject by concrete type | `IBaseHandler<T>`/`IAtomicHandler<T>` for typing NOT DI

### Middleware Order (NON-NEGOTIABLE)
```csharp
builder.UseMiddleware<ExecutionTimingMiddleware>();   // 1. Measures total time
builder.UseMiddleware<ExceptionHandlerMiddleware>();  // 2. Catches all exceptions
builder.UseMiddleware<CustomAuthenticationMiddleware>(); // 3. Auth lifecycle (optional)
```
**Flow:** Request ‚Üí Timing(start) ‚Üí Exception(try) ‚Üí Auth(login) ‚Üí Function ‚Üí Auth(logout-finally) ‚Üí Exception(catch) ‚Üí Timing(log) ‚Üí Response  
**When CustomAuth:** Session-based auth ‚úÖ | Token-based auth ‚úÖ | Credentials-per-request ‚ùå

### Polly Policy (MANDATORY)
```csharp
builder.Services.AddSingleton<IAsyncPolicy<HttpResponseMessage>>(sp => {
    IConfiguration config = sp.GetRequiredService<IConfiguration>();
    IAsyncPolicy<HttpResponseMessage> retryPolicy = Policy.Handle<HttpRequestException>().OrResult<HttpResponseMessage>(r => (int)r.StatusCode >= 500)
        .WaitAndRetryAsync(config.GetValue<int>("HttpClientPolicy:RetryCount", 0), retryAttempt => TimeSpan.FromSeconds(retryAttempt * 5));
    IAsyncPolicy<HttpResponseMessage> timeoutPolicy = Policy.TimeoutAsync<HttpResponseMessage>(config.GetValue<int>("HttpClientPolicy:TimeoutSeconds", 60));
    return Policy.WrapAsync(retryPolicy, timeoutPolicy);
});
```
**appsettings.json:** `"HttpClientPolicy": { "RetryCount": 0, "TimeoutSeconds": 60 }`

**üî¥ CRITICAL RULE:** `HttpClientPolicy.RetryCount` MUST always be set to `0` unless explicitly requested otherwise. This aligns with `AppConfigs.RetryCount` which defaults to `0` (no retries). Only set a non-zero value if the Boomi process or business requirements explicitly specify retry behavior.

### Cache Library (OPTIONAL)
```csharp
builder.Services.AddRedisCacheLibrary(builder.Configuration);
```
**When:** Project uses Redis | Handlers implement `ICacheableAtomicHandler<T>` | DTOs implement `ICacheable`  
**appsettings.json:** `"RedisCache": { "ConnectionString": "", "InstanceName": "ProjectName:" }`

### Service Locator (OPTIONAL)
```csharp
ServiceLocator.ServiceProvider = builder.Services.BuildServiceProvider();
```
**When:** Static helpers (SOAPHelper, XMLHelper) need ILogger | **MUST:** After all registrations, before Build().Run()

### JSON Options (OPTIONAL)
```csharp
builder.Services.Configure<JsonSerializerOptions>(options => {
    options.Converters.Add(new JsonStringEnumConverter());
    options.PropertyNameCaseInsensitive = true;
});
```
**When:** Enums in DTOs | Need string values not integers: `{ "Status": "Active" }` vs `{ "Status": 1 }`

---

## COMMON MISTAKES & FIXES

| Mistake | Fix |
|---------|-----|
| Services without interfaces | `AddScoped<IInterface, Implementation>()` |
| Handlers with interfaces | `AddScoped<ConcreteHandler>()` |
| Wrong middleware order | ExecutionTiming‚ÜíException‚ÜíAuth |
| No environment fallback | `?? "dev"` |
| Config after services | Load config BEFORE services |
| ServiceLocator before services | AFTER all registrations |
| Forgot auth atomic handlers | Register AuthenticateAtomicHandler + LogoutAtomicHandler |
| CustomAuth for credentials-per-request | Remove middleware, use headers |
| Hardcoded environment | Use Environment.GetEnvironmentVariable |

---

## VERIFICATION CHECKLIST

**Config:** [ ] Environment fallback | [ ] Config loads: json ‚Üí {env}.json ‚Üí env vars | [ ] All Configure<T>() use SectionName | [ ] App Insights FIRST  
**Services:** [ ] Services WITH interfaces | [ ] Handlers CONCRETE | [ ] Atomic Handlers CONCRETE | [ ] ALL atomic handlers (incl. auth) | [ ] HTTP clients registered  
**Middleware:** [ ] Order: ExecutionTiming‚ÜíException‚ÜíCustomAuth | [ ] CustomAuth only if session/token | [ ] NO middleware for credentials-per-request  
**Polly/Cache:** [ ] Polly registered | [ ] Redis if caching | [ ] ServiceLocator if static helpers  
**Build:** [ ] ConfigureFunctionsWebApplication() called | [ ] Build().Run() LAST

---

## KEY INVARIANTS (NEVER VIOLATE)

1. **Registration order FIXED** - Cannot change
2. **Environment MUST have fallback** - `?? "dev"`
3. **Config loads BEFORE services** - Non-negotiable
4. **App Insights FIRST** - Before all services
5. **Services WITH interfaces** - `AddScoped<I, Impl>()`
6. **Handlers/Atomic CONCRETE** - NO interfaces in DI
7. **Middleware order FIXED** - ExecutionTiming‚ÜíException‚ÜíAuth
8. **ServiceLocator LAST** - After all registrations
9. **Polly MANDATORY** - All projects need retry/timeout
10. **Build().Run() LAST** - Final line

# CUSTOM ATTRIBUTES RULES
*ALL RULES CRITICAL & MANDATORY - NO EXCEPTIONS*

## 1. FOLDER STRUCTURE
```
<ProjectName>/
‚îú‚îÄ‚îÄ Attributes/  ‚Üê ALL custom attributes (one per file, file=class name)
‚îú‚îÄ‚îÄ Functions/  ‚Üê USE | Middlewares/  ‚Üê DETECT
```
**Rules:** ‚úÖ ALL in `Attributes/` | ‚úÖ One per file | ‚úÖ File = class name | ‚ùå NEVER in Functions/Middlewares/Handlers/Services

## 2. HOW TO CREATE
**File:** `Attributes/CustomAuthenticationAttribute.cs`

**Template:**
```csharp
namespace <ProjectName>.Attributes
{
    /// <summary>Marks Azure Functions requiring session-based auth. CustomAuthenticationMiddleware handles login/logout.</summary>
    [AttributeUsage(AttributeTargets.Method, AllowMultiple = false)]
    public class CustomAuthenticationAttribute : Attribute { }
}
```
**Required:** Namespace `<ProjectName>.Attributes` | XML docs | `[AttributeUsage(AttributeTargets.Method, AllowMultiple = false)]` | Name ends "Attribute" | Inherit `: Attribute`

## 3. DEFINITION PATTERNS

**A. Simple (No Properties):**
```csharp
namespace <ProjectName>.Attributes { [AttributeUsage(AttributeTargets.Method, AllowMultiple = false)] public class CustomAuthenticationAttribute : Attribute { } }
```

**B. Optional Property:**
```csharp
namespace <ProjectName>.Attributes { [AttributeUsage(AttributeTargets.Method, AllowMultiple = false)] public class CacheableServiceAttribute : Attribute { public string? Namespace { get; set; } public CacheableServiceAttribute() { } } }
// Usage: [CacheableService(Namespace = "Entities")]
```

**C. Required Property:**
```csharp
namespace <ProjectName>.Attributes {
    [AttributeUsage(AttributeTargets.Method, AllowMultiple = false)]
    public class RequiresRoleAttribute : Attribute {
        public string RoleName { get; }
        public RequiresRoleAttribute(string roleName) { RoleName = roleName; }
    }
}
// Usage: [RequiresRole("Admin")]  ‚Üê MUST provide
```

## 4. HOW TO USE

**Import:** `using <ProjectName>.Attributes;`

**Order (MANDATORY):**
```csharp
[CustomAuthenticationAttribute]  // 1. FIRST - Custom
[Function("FunctionName")]       // 2. SECOND - [Function]
public async Task<BaseResponseDTO> Run([HttpTrigger(...)] HttpRequest req, FunctionContext context) { }  // 3. [HttpTrigger] on param, FunctionContext for framework
```

**Complete Example:**
```csharp
using <ProjectName>.Attributes; using Core.DTOs; using Microsoft.AspNetCore.Http; using Microsoft.Azure.Functions.Worker; using Microsoft.Extensions.Logging;

namespace <ProjectName>.Functions;
public class CreateEntityAPI { private readonly ILogger<CreateEntityAPI> _logger; private readonly IEntityMgmtService _service;
    public CreateEntityAPI(ILogger<CreateEntityAPI> logger, IEntityMgmtService service) { _logger = logger; _service = service; }
    [CustomAuthenticationAttribute] [Function("CreateEntity")] public async Task<BaseResponseDTO> Run([HttpTrigger(AuthorizationLevel.Anonymous, "post")] HttpRequest req, FunctionContext context) { CreateEntityReqDTO? request = await req.ReadBodyAsync<CreateEntityReqDTO>(); if (request == null) throw new NoRequestBodyException(ErrorConstants.INVALID_REQ_PAYLOAD); request.ValidateAPIRequestParameters(); return await _service.CreateEntityAsync(request, context); } }
```

## 5. MIDDLEWARE DETECTION

```csharp
// File: Middlewares/CustomAuthenticationMiddleware.cs
using <ProjectName>.Attributes; using Microsoft.Azure.Functions.Worker; using Microsoft.Azure.Functions.Worker.Middleware; using System.Reflection;

namespace <ProjectName>.Middlewares { public class CustomAuthenticationMiddleware : IFunctionsWorkerMiddleware { public async Task Invoke(FunctionContext context, FunctionExecutionDelegate next) { System.Reflection.MethodInfo? method = GetTargetFunctionMethod(context); bool hasAuthAttribute = method?.GetCustomAttribute<CustomAuthenticationAttribute>() != null; if (hasAuthAttribute) await HandleAuthentication(context); await next(context); if (hasAuthAttribute) await HandleLogout(context); }
        private MethodInfo? GetTargetFunctionMethod(FunctionContext context) { string entryPoint = context.FunctionDefinition.EntryPoint; string typeName = entryPoint.Substring(0, entryPoint.LastIndexOf('.')); string methodName = entryPoint.Substring(entryPoint.LastIndexOf('.') + 1); return Type.GetType(typeName)?.GetMethod(methodName); }
        private async Task HandleAuthentication(FunctionContext context) { /* Login */ } private async Task HandleLogout(FunctionContext context) { /* Logout */ } } }
```

## 6. HOW IT HELPS

**A. Cleaner Code:**
```csharp
// ‚ùå WITHOUT: await _loginHandler.Handle(loginRequest); BaseResponseDTO result = await _service.CreateEntity(request); await _logoutHandler.Handle(logoutRequest);
// ‚úÖ WITH: [CustomAuthenticationAttribute] [Function("CreateEntity")] public async Task<BaseResponseDTO> Run(...) { return await _service.CreateEntity(request); }
```

**B. Benefits:** ‚úÖ Auth logic in ONE place (middleware) | ‚úÖ Easy to update (change middleware only) | ‚úÖ No duplicate code | ‚úÖ Clear intent | ‚úÖ Consistent behavior | ‚úÖ Guaranteed login/logout

## 7. PROGRAM.CS REGISTRATION
```csharp
builder.UseMiddleware<ExecutionTimingMiddleware>();      // 1. FIRST
builder.UseMiddleware<ExceptionHandlerMiddleware>();     // 2. SECOND
builder.UseMiddleware<CustomAuthenticationMiddleware>(); // 3. THIRD
builder.Build().Run();
```
**‚ö†Ô∏è CRITICAL:** Custom auth middleware MUST be THIRD. Order cannot change.

## 8. CHECKLIST

**Creating:** [ ] `Attributes/` folder | [ ] File: `Attributes/YourCustomAttribute.cs` | [ ] Namespace `<ProjectName>.Attributes` | [ ] XML docs | [ ] `[AttributeUsage(AttributeTargets.Method, AllowMultiple = false)]` | [ ] Name ends "Attribute" | [ ] Inherit `: Attribute`

**Using:** [ ] Import `using <ProjectName>.Attributes;` | [ ] Apply BEFORE `[Function]` | [ ] Register middleware in `Program.cs` (correct order)

**Middleware:** [ ] Import attribute namespace | [ ] Use reflection to get method | [ ] Check: `method?.GetCustomAttribute<T>() != null` | [ ] Execute logic if present

## 9. COMMON MISTAKES

| Mistake | Fix |
|---------|-----|
| Attribute in middleware file | `Attributes/` folder, separate file |
| No `[AttributeUsage]` | ALWAYS add `[AttributeUsage(AttributeTargets.Method)]` |
| No `: Attribute` | Inherit from `Attribute` |
| Custom after `[Function]` | Custom BEFORE `[Function]` |
| Not importing | `using <ProjectName>.Attributes;` |
| File ‚â† class name | File name = class name |

## COMPLETE EXAMPLE

**1. Create:** `Attributes/CustomAuthenticationAttribute.cs`
```csharp
namespace <ProjectName>.Attributes { [AttributeUsage(AttributeTargets.Method, AllowMultiple = false)] public class CustomAuthenticationAttribute : Attribute { } }
```

**2. Use:** `Functions/CreateEntityAPI.cs`
```csharp
using <ProjectName>.Attributes;
[CustomAuthenticationAttribute] [Function("CreateEntity")]
public async Task<BaseResponseDTO> Run([HttpTrigger(AuthorizationLevel.Anonymous, "post")] HttpRequest req) { }
```

**3. Detect:** `Middlewares/CustomAuthenticationMiddleware.cs`
```csharp
System.Reflection.MethodInfo? method = GetTargetFunctionMethod(context);
bool hasAuth = method?.GetCustomAttribute<CustomAuthenticationAttribute>() != null;
if (hasAuth) { /* authenticate */ }
```

**4. Register:** `Program.cs`
```csharp
builder.UseMiddleware<CustomAuthenticationMiddleware>(); // THIRD
```

---

# host.json RULES
*ALL RULES CRITICAL & MANDATORY - NO EXCEPTIONS*

## 1. OVERVIEW

**Purpose:** Azure Functions host runtime configuration | **Location:** `<ProjectRoot>/host.json` (same level as Program.cs) | **Version:** Always `"version": "2.0"` | **Environment:** Same file for ALL environments (NOT env-specific)

## 1.1 üõë PRE-CREATION VALIDATION (MANDATORY - STOP IF NOT COMPLETE)

**üö® YOU CANNOT CREATE host.json UNTIL:**

1. ‚úÖ **STOP AND VERIFY:** Am I creating System Layer host.json?
2. ‚úÖ **STOP AND VERIFY:** Have I read this section completely?
3. ‚úÖ **STOP AND VERIFY:** Do I know this is System Layer (NOT Process Layer)?

**üõë IF ANY MISSING ‚Üí STOP ‚Üí Complete verification ‚Üí Then create host.json**

---

## 2. STANDARD TEMPLATE (MANDATORY - COPY EXACTLY)

**üî¥ CRITICAL:** Copy this EXACT template. NO modifications. NO additions. NO deletions.

```json
{
  "version": "2.0",
  "logging": {
    "fileLoggingMode": "always",
    "applicationInsights": {
      "enableLiveMetricsFilters": true
    }
  }
}
```

**üî¥ COPY THIS EXACTLY - Character by character match required**

## 2.1 üõë POST-CREATION VALIDATION (MANDATORY - VERIFY BEFORE PROCEEDING)

**üö® AFTER creating host.json, you MUST verify:**

1. ‚úÖ **STOP AND VERIFY:** `"version": "2.0"` exists (exactly this)
2. ‚úÖ **STOP AND VERIFY:** `"fileLoggingMode": "always"` exists (exactly this)
3. ‚úÖ **STOP AND VERIFY:** `"enableLiveMetricsFilters": true` exists (exactly this)
4. ‚úÖ **STOP AND VERIFY:** NO `"extensionBundle"` section
5. ‚úÖ **STOP AND VERIFY:** NO `"samplingSettings"` section
6. ‚úÖ **STOP AND VERIFY:** NO `"maxTelemetryItemsPerSecond"` property
7. ‚úÖ **STOP AND VERIFY:** File is at project root (same level as Program.cs)
8. ‚úÖ **STOP AND VERIFY:** .csproj has `<None Update="host.json"><CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory></None>`

**üõë IF ANY VIOLATION ‚Üí STOP ‚Üí Fix host.json ‚Üí Then proceed**

**VALIDATION CHECKLIST:**
```json
// ‚úÖ CORRECT (System Layer):
{
  "version": "2.0",
  "logging": {
    "fileLoggingMode": "always",
    "applicationInsights": {
      "enableLiveMetricsFilters": true
    }
  }
}

// ‚ùå WRONG (NEVER USE):
// Missing "fileLoggingMode": "always"
// Has "extensionBundle" section
// Has "samplingSettings.maxTelemetryItemsPerSecond"
// Different structure
```

## 3. CONFIGURATION BREAKDOWN

**version:** `"2.0"` = .NET 8 Isolated Worker Model (MANDATORY)  
**fileLoggingMode:** `"always"` = Log to file system (debugging)  
**enableLiveMetricsFilters:** `true` = Real-time metrics in Azure Portal

## 4. KEY RULES (üî¥ CRITICAL ENFORCEMENT - NO EXCEPTIONS)

**MANDATORY RULES:**
- ‚úÖ Same host.json for dev/qa/prod (NOT environment-specific)
- ‚úÖ Enable live metrics filters (real-time monitoring)
- ‚úÖ File must be Content + Copy to Output Directory
- ‚úÖ Use EXACT template - NO modifications, NO extra properties

**üî¥ ABSOLUTELY FORBIDDEN (NEVER ADD):**
- ‚ùå **NO app configs** (BaseUrl, API keys, credentials) - use appsettings.json ONLY
- ‚ùå **NO environment-specific values** - same file for all environments
- ‚ùå **NO retry policies** - use Polly in Program.cs instead
- ‚ùå **NO timeout settings** - configure in appsettings.json + Polly
- ‚ùå **NO custom extensions** - use defaults only
- ‚ùå **NO database configs** - use appsettings.json
- ‚ùå **NO authentication settings** - use Program.cs
- ‚ùå **NO logging configurations** - use default logging setup
- ‚ùå **NO environment-specific files** (host.dev.json, host.prod.json, host.qa.json) - SINGLE file only
- ‚ùå **NO extra properties or comments** - strict structure only
- ‚ùå **NO modifications to version** - ALWAYS "2.0"
- ‚ùå **NO disabling live metrics** - ALWAYS enabled

**RULE:** host.json is for **Azure Functions runtime ONLY** | Any application-specific settings belong in appsettings.json | Violation = architecture break

## 5. FILE LOCATION

**Location:**
```
<ProjectRoot>/
‚îú‚îÄ‚îÄ Program.cs         ‚Üê Same level
‚îú‚îÄ‚îÄ host.json         ‚Üê MANDATORY
‚îú‚îÄ‚îÄ appsettings.json  ‚Üê Same level
```

**Verify in .csproj:**
```xml
<ItemGroup><None Update="host.json"><CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory></None></ItemGroup>
```

## 6. COMMON MISTAKES

| Mistake | Fix |
|---------|-----|
| ‚ùå Missing host.json | Add at project root |
| ‚ùå `"version": "1.0"` | Change to `"version": "2.0"` |
| ‚ùå App configs in host.json | Move to appsettings.json |
| ‚ùå Environment-specific values | Use appsettings.{env}.json |
| ‚ùå Live metrics not enabled | Set `"enableLiveMetricsFilters": true` |
| ‚ùå File not copied to output | Set Content + Copy if newer |

## 7. INTEGRATION

**host.json vs appsettings.json:**
- **host.json:** Runtime config (logging, timeouts, extensions) - Same for all environments
- **appsettings.json:** App config (URLs, credentials) - Different per environment

**Application Insights:**
- **Connection:** Azure App Settings or local.settings.json (`APPLICATIONINSIGHTS_CONNECTION_STRING`)
- **Behavior:** host.json (live metrics, logging)
- **Registration:** Program.cs (`AddApplicationInsightsTelemetryWorkerService()`)

## 8. VERIFICATION CHECKLIST

- [ ] host.json exists at project root
- [ ] `"version": "2.0"` specified
- [ ] `"fileLoggingMode": "always"` present
- [ ] `"applicationInsights"` section present
- [ ] `"enableLiveMetricsFilters": true` present
- [ ] File marked as Content in .csproj
- [ ] CopyToOutputDirectory: PreserveNewest
- [ ] NO app-specific configs
- [ ] NO environment-specific values
- [ ] Valid JSON syntax

## 9. KEY INVARIANTS (NEVER VIOLATE)

1. **host.json MUST exist at project root**
2. **ALWAYS use "version": "2.0" for .NET 8**
3. **NEVER add application configs**
4. **NEVER create environment-specific host.json**
5. **ALWAYS enable live metrics filters**
6. **ALWAYS set fileLoggingMode to "always"**
7. **Same host.json for ALL environments**

---

**END OF DOCUMENT - ALL RULES COMPLETE**
