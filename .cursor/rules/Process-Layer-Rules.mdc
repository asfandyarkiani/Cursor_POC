---
description: Always apply. Non-negotiable rules for Process Layer boundaries in this repo.
alwaysApply: false
---
# Process Layer ‚Äì Architecture & Coding Guidelines

---



# Process Layer ‚Äì Architecture & Coding Guidelines

---

## üö® CRITICAL - READ THIS FIRST üö®

## üõë MANDATORY CODE GENERATION WORKFLOW (STOP IF NOT COMPLETE)

**üö® WHEN GENERATING CODE FOR A NEW OPERATION, YOU MUST FOLLOW THIS WORKFLOW:**

**STEP 1: Pre-Generation Validation**
- [ ] **STOP AND VERIFY:** Am I in Phase 2 (Code Generation)?
- [ ] **STOP AND VERIFY:** Have I completed Phase 1 (Extraction)?
- [ ] **STOP AND VERIFY:** Do I have Phase 1 document with Operations Inventory, DTOs, and Sequence Diagram?
- [ ] **STOP AND VERIFY:** Have I identified the System Layer project?
- [ ] **STOP AND VERIFY:** Is the repository path correct?
- [ ] **IF ANY NO ‚Üí STOP ‚Üí Complete missing step ‚Üí Then proceed**

**STEP 2: Generate Domain**
- [ ] Create Domain class: `Domains/<Entity>.cs` (or `Domains/<BusinessDomain>/<Entity>.cs`)
- [ ] Verify generic entity name (NOT operation name)
- [ ] Verify folder structure (single domain = no subfolder, multiple domains = subfolder required)
- [ ] **üî¥ MANDATORY WORKFLOW STEP 5:** See Section 3 (Domain Rules) for complete details

**STEP 3: Generate DTOs**
- [ ] Create Request DTO: `DTOs/<Operation>/<Operation>ReqDTO.cs`
- [ ] Create Response DTO: `DTOs/<Operation>/<Operation>ResDTO.cs`
- [ ] Verify structure matches Phase 1 Section 14 (Input Structure Analysis) and Section 15 (Response Structure Analysis)
- [ ] Verify Request DTO implements `IRequestPopulatorDTO<<Entity>Domain>` if Domain exists
- [ ] **üî¥ MANDATORY WORKFLOW STEP 4:** See Section 7 (DTO Rules) for complete details

**STEP 4: Generate System Abstraction**
- [ ] Create System Abstraction: `SystemAbstractions/<Module>Mgmt/<Entity>MgmtSys.cs`
- [ ] Verify property names match System Layer DTO property names EXACTLY
- [ ] Verify all required fields from System Layer DTO validation are included
- [ ] **üî¥ MANDATORY WORKFLOW STEP 6:** See Section 5 (System Abstractions Rules) for complete details

**STEP 5: Generate Service**
- [ ] Create Service: `Services/<Entity>Service.cs`
- [ ] Verify orchestration logic (NOT business logic implementation)
- [ ] Verify Service does NOT extract/validate headers or query parameters
- [ ] Verify Service does NOT orchestrate error notifications
- [ ] See Section 8 (Services Rules) for complete details

**STEP 6: Generate Function**
- [ ] Create Function: `Functions/<Entity>Functions/<Operation>Function.cs`
- [ ] Verify error handling orchestration (Function responsibility, NOT Service)
- [ ] Verify Domain creation and `dto.Populate(domain)` call INLINE
- [ ] **üî¥ MANDATORY WORKFLOW STEP 9:** See Section 2 (Azure Functions Rules) for complete details

**STEP 7: Update AppConfigs.cs**
- [ ] Add new properties to `ConfigModels/AppConfigs.cs`
- [ ] Verify properties match Phase 1 Section 2 (Process Properties Analysis)
- [ ] Verify NOT adding SOR base URLs or resource paths (only System Layer Function URLs)
- [ ] See Section 13 (Config Models Rules) for complete details

**STEP 8: Update ALL appsettings files (üî¥ BLOCKING)**
- [ ] **MANDATORY:** Read AppConfigs.cs ‚Üí List ALL new properties added
- [ ] **MANDATORY:** For EACH new property in AppConfigs.cs:
  - [ ] Update `appsettings.dev.json` ‚Üí Add property with value/placeholder
  - [ ] Update `appsettings.qa.json` ‚Üí Add property with value/placeholder
  - [ ] Update `appsettings.stg.json` ‚Üí Add property with value/placeholder
  - [ ] Update `appsettings.prod.json` ‚Üí Add property with value/placeholder
  - [ ] Update `appsettings.dr.json` ‚Üí Add property with value/placeholder
- [ ] **MANDATORY:** Verify ALL appsettings files have ALL properties from AppConfigs.cs
- [ ] **üî¥ CRITICAL - BLOCKING:** Verify ALL appsettings VALUES against Boomi JSON files (source of truth):
  - [ ] **BLOCKING:** For EACH property in appsettings that has a known value (not TODO placeholder):
    - Identify which Boomi process/operation this property belongs to
    - Read Phase 1 document Section 2 (Process Properties Analysis) OR Section 22 (Process-Level Configuration) to find source
    - Read Boomi component JSON file (component_*.json) ‚Üí Locate `DefinedProcessProperties/definedProcessProperty[]/defaultValue/_` field
    - Compare appsettings value with Boomi component JSON defaultValue EXACTLY (case-sensitive, character-by-character)
    - If values don't match ‚Üí **VIOLATION** ‚Üí Fix appsettings value to match Boomi JSON ‚Üí Re-verify
  - [ ] **BLOCKING:** For error email configuration properties (File_Name prefix, HasAttachment):
    - File_Name prefix: Verify against Phase 1 Section 2 (defined parameter value) OR Boomi component JSON `defaultValue/_` field
    - **üî¥ CRITICAL - HasAttachment Value Verification:**
      - **MANDATORY:** Read Phase 1 Section 2 (Process Properties Analysis) ‚Üí Find `process.DPP_HasAttachment` property
      - **MANDATORY:** Check the "Source" column for `process.DPP_HasAttachment`:
        - If Source is "Defined parameter: PP_<Name>.Has_Attachment" ‚Üí Use component JSON `defaultValue/_` field
        - If Source is "Static value" or "Concatenation" ‚Üí **DO NOT use component JSON defaultValue** ‚Üí Use the actual value from Phase 1 Section 2
      - **MANDATORY:** Verify the actual value used in the process (from Phase 1 Section 2) matches appsettings value
      - **‚ö†Ô∏è WARNING:** Component JSON `defaultValue/_` may NOT be the actual value used if the process writes a static value or transforms the value
      - **BLOCKING:** If Phase 1 Section 2 shows a different source (static/concatenation) than defined parameter ‚Üí Use Phase 1 value, NOT component JSON defaultValue
    - If File_Name is constructed (Process Name + Date pattern): Verify prefix matches Phase 1 documented pattern
  - [ ] **BLOCKING:** Document verification results: For EACH property, document:
    - Boomi component JSON file path
    - Phase 1 document section reference
    - Expected value from Boomi JSON
    - Actual value in appsettings
    - Match status (‚úÖ MATCH / ‚ùå MISMATCH)
- [ ] **BLOCKING:** Code generation is INCOMPLETE until ALL appsettings files are updated AND all values verified against Boomi JSON
- [ ] See Section 13 (Config Models Rules) for complete details

**STEP 9: Update Program.cs**
- [ ] Register Domain: `builder.Services.AddTransient<<Entity>>();`
- [ ] Register System Abstraction: `builder.Services.AddScoped<<Entity>MgmtSys>();`
- [ ] Register Service: `builder.Services.AddScoped<<Entity>Service>();`
- [ ] Verify AppConfigs registration exists: `builder.Services.Configure<AppConfigs>(...)`
- [ ] See Section 21 (Program.cs Rules) for complete details

**STEP 10: Update Constants**
- [ ] Add error constants to `Constants/ErrorConstants.cs` (if needed)
- [ ] Add success message to `Constants/InfoConstants.cs`: `public const string <OPERATION>_SUCCESS = "...";`
- [ ] Add process name to `Constants/InfoConstants.cs`: `public const string PROCESS_NAME_<OPERATION> = "...";`
- [ ] Verify constants are used in Function (not hardcoded strings)
- [ ] See Section 22 (Constants Update Rules) for complete details

**STEP 11: Update ResponseDTOHelper**
- [ ] Add `Populate<Operation>Res` method (if needed)
- [ ] Verify Dictionary pattern used (NOT private classes)
- [ ] Verify System Layer DTO property names used as dictionary keys
- [ ] See Section 12 (Response DTO Helper Rules) for complete details

**üõë IF ANY CHECKPOINT FAILS ‚Üí STOP ALL CODE GENERATION ‚Üí Complete missing step ‚Üí Then proceed**

---

## üìã MASTER CHECKLIST - FILES TO UPDATE FOR NEW OPERATION

**üö® WHEN ADDING A NEW OPERATION, YOU MUST UPDATE/CREATE THESE FILES:**

**Code Files:**
- [ ] Domain: `Domains/<Entity>.cs` (or `Domains/<BusinessDomain>/<Entity>.cs`)
- [ ] Request DTO: `DTOs/<Operation>/<Operation>ReqDTO.cs`
- [ ] Response DTO: `DTOs/<Operation>/<Operation>ResDTO.cs`
- [ ] System Abstraction: `SystemAbstractions/<Module>Mgmt/<Entity>MgmtSys.cs`
- [ ] Service: `Services/<Entity>Service.cs`
- [ ] Function: `Functions/<Entity>Functions/<Operation>Function.cs`

**Configuration Files:**
- [ ] AppConfigs.cs: `ConfigModels/AppConfigs.cs`
- [ ] appsettings.dev.json
- [ ] appsettings.qa.json
- [ ] appsettings.stg.json
- [ ] appsettings.prod.json
- [ ] appsettings.dr.json
- [ ] appsettings.json (keep empty, verify structure only)

**Registration Files:**
- [ ] Program.cs (register Domain, System Abstraction, Service)

**Constants Files:**
- [ ] ErrorConstants.cs (if new error constants needed)
- [ ] InfoConstants.cs (add success message, process name)

**Helper Files:**
- [ ] ResponseDTOHelper.cs (if new response mapping needed)

**üõë VERIFY ALL FILES UPDATED BEFORE DECLARING CODE GENERATION COMPLETE**

---

## üî¥ **ALL RULES IN THIS DOCUMENT ARE CRITICAL AND MANDATORY** üî¥

---

## 1. Folder Structure Rules

**üö® BEFORE CREATING ANY CODE:** Verify EVERY folder location against this structure.

### 1.1 Complete Structure (Standard Process Layer)

```
<ProjectName>/
‚îú‚îÄ‚îÄ ConfigModels/                      # AppConfigs.cs, nested configs
‚îú‚îÄ‚îÄ Constants/                         # ErrorConstants.cs, InfoConstants.cs
‚îú‚îÄ‚îÄ Domains/                           # Business objects with IDomain<T>
‚îÇ   ‚îú‚îÄ‚îÄ <EntityName>.cs               # Single domain entity (if only ONE domain exists) - **üî¥ CRITICAL: NO subfolder if only one domain**
‚îÇ   ‚îî‚îÄ‚îÄ <BusinessDomain>/              # Business domain subfolder (ONLY if MULTIPLE domains exist) (e.g., Leave, Maintenance, Properties, etc.)
‚îÇ       ‚îî‚îÄ‚îÄ <EntityName>.cs           # Domain entity with business logic (e.g., Leave.cs, WorkOrder.cs, Lead.cs) - **üî¥ CRITICAL: Use entity name, NOT operation name**
‚îú‚îÄ‚îÄ DTOs/                              # ALL request/response DTOs
‚îÇ   ‚îú‚îÄ‚îÄ <OperationName>/              # Per-operation folder (<Operation>Request, Get<Entity>, etc.) - **‚ùå NEVER include SOR name**
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ <Feature>ReqDTO.cs       # Request DTO
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ <Feature>ResDTO.cs       # Response DTO
‚îú‚îÄ‚îÄ Enums/                             # Enums with [StringValue]
‚îú‚îÄ‚îÄ Extensions/                        # Project-specific extensions (optional)
‚îú‚îÄ‚îÄ EmailTemplate/                     # Optional - Embedded HTML templates
‚îÇ   ‚îî‚îÄ‚îÄ <TemplateName>.html           # Email templates as embedded resources
‚îú‚îÄ‚îÄ Functions/                         # Azure Functions (HTTP entry points)
‚îÇ   ‚îî‚îÄ‚îÄ <Feature>Functions/           # üî¥ MANDATORY: Subfolder with plural name
‚îÇ       ‚îî‚îÄ‚îÄ <Feature>Function.cs      # Function file inside subfolder
‚îú‚îÄ‚îÄ Helper/                            # ResponseDTOHelper (mandatory)
‚îú‚îÄ‚îÄ ProcessAbstractions/               # Process‚ÜíProcess Layer calls (optional)
‚îÇ   ‚îî‚îÄ‚îÄ <ModuleName>/
‚îÇ       ‚îî‚îÄ‚îÄ <Feature>Proc.cs
‚îÇ   ‚îî‚îÄ‚îÄ Interfaces/ (optional)
‚îÇ       ‚îî‚îÄ‚îÄ I<Feature>Proc.cs
‚îú‚îÄ‚îÄ Services/                          # Orchestration & business logic
‚îÇ   ‚îî‚îÄ‚îÄ <Feature>Service.cs
‚îÇ   ‚îî‚îÄ‚îÄ Interface/
‚îÇ       ‚îî‚îÄ‚îÄ I<Feature>Service.cs
‚îú‚îÄ‚îÄ SystemAbstractions/                # Process‚ÜíSystem Layer calls
‚îÇ   ‚îî‚îÄ‚îÄ <ModuleName>Mgmt/
‚îÇ       ‚îî‚îÄ‚îÄ <Feature>MgmtSys.cs
‚îÇ   ‚îî‚îÄ‚îÄ Interfaces/ (optional)
‚îÇ       ‚îî‚îÄ‚îÄ I<Feature>Mgmt.cs
‚îú‚îÄ‚îÄ Program.cs
‚îú‚îÄ‚îÄ host.json
‚îú‚îÄ‚îÄ appsettings.json
‚îú‚îÄ‚îÄ appsettings.dev.json
‚îú‚îÄ‚îÄ appsettings.qa.json
‚îú‚îÄ‚îÄ appsettings.stg.json
‚îú‚îÄ‚îÄ appsettings.prod.json
‚îú‚îÄ‚îÄ appsettings.dr.json
‚îî‚îÄ‚îÄ <ProjectName>.csproj, <ProjectName>.sln
```

### 1.2 Critical Folder Rules

| Rule | Requirement | Impact |
|------|-------------|--------|
| **Domains/** | Business objects with `IDomain<T>` interface (Standard Process Layer) or Simple POCOs (Central Data Layer) | Architecture pattern |
| **DTOs/** | Request/response data transfer objects | Naming consistency |
| **ProcessAbstractions/** | Process‚ÜíProcess calls (optional, not all projects) | Inter-process communication |
| **SystemAbstractions/** | Process‚ÜíSystem Layer calls (mandatory) | External communication |
| **Services/** | Orchestration logic (optional, not all projects) | Business logic layer |
| **NO Middleware/** | Except ExecutionTiming, ExceptionHandler from Framework | No custom auth |
| **NO Attributes/** | No custom attributes in Process Layer | System Layer concept |
| **NO SoapEnvelopes/** | Process Layer doesn't build SOAP | System Layer handles |
| **Repositories/** | Only in Central Data Layer (Shared Services) - NOT in standard Process Layer | Database access pattern |
| **Models/** | Only in Central Data Layer (EF Core entities) - NOT in standard Process Layer | Database access pattern |

### 1.3 Domain Folder Structure Rules

**üî¥ CRITICAL: Domain Folder Structure Rules**

- **‚úÖ CORRECT: Single Domain (No Subfolder):** If only ONE domain exists for a business domain ‚Üí `Domains/<EntityName>.cs`
  - ‚úÖ **CORRECT:** `Domains/<Entity>.cs` with class `<Entity>` (if only one domain exists)
  - ‚úÖ **CORRECT:** `Domains/<Entity>.cs` with class `<Entity>` (if only one domain exists)
- **‚úÖ CORRECT: Multiple Domains (Subfolder Required):** If MULTIPLE domains exist for a business domain ‚Üí `Domains/<BusinessDomain>/<EntityName>.cs`
  - ‚úÖ **CORRECT:** `Domains/<BusinessDomain>/<Entity>.cs` and `Domains/<BusinessDomain>/<Entity>Attachment.cs` (multiple related domains)
  - ‚úÖ **CORRECT:** `Domains/<BusinessDomain>/<Entity>.cs`, `Domains/<BusinessDomain>/<Entity>Details.cs`, etc. (multiple related domains)
- **‚úÖ CORRECT Domain Class Name:** Use the business entity name, NOT the operation name
  - ‚úÖ **CORRECT:** Class `<Entity>` (for `<Operation>` operation)
  - ‚ùå **WRONG:** Class `<Operation>Request` (operation name, not entity name)
  - ‚ùå **WRONG:** Class `<Operation>` (operation name, not entity name)
  - ‚ùå **WRONG:** Class `<Adjective><Operation>` (e.g., `LateLogin`, `CreateLeave`, `GetEmployee`)
- **Rule:** Domain represents the business entity, not the operation. Operations are in Functions/DTOs, entities are in Domains.
- **üî¥ CRITICAL - Domain Naming Rules:**
  - **‚úÖ CORRECT:** Generic business entity names (e.g., `Leave`, `Attendance`, `Employee`, `Record`)
  - **‚ùå WRONG:** Operation-specific names (e.g., `LateLogin`, `CreateLeave`, `GetEmployeeDetails`)
  - **‚ùå WRONG:** Names with adjectives/qualifiers from operation (e.g., `LateLogin` should be `Attendance`, `CreateLeave` should be `Leave`)
  - **Why:** Domain names must be reusable across multiple operations. If you have "LateLogin" operation, the domain should be generic like "Attendance" (can be used for late, on-time, early check-ins)
  - **üî¥ CRITICAL:** When creating a domain, ask: "What is the generic business entity this represents?" NOT "What operation is this for?"
- **üî¥ CRITICAL:** Only create a subfolder if MULTIPLE domains exist in that business domain. If only one domain exists, put it directly in `Domains/` without a subfolder.

**Examples of Business Domains:**
- Properties
- Facilities
- Automotive
- Food
- HumanResource
- KABITaxi
- And many more business domains as needed

**Note:** `<BusinessDomain>` represents the business domain name (e.g., `Properties`, `Facilities`, `Automotive`) that groups related domain entities.

### 1.4 DTO Folder Structure Rules

**üî¥ CRITICAL: DTO Folder Naming Rules**

- **‚úÖ CORRECT: Operation-Based Naming:** DTO folder names MUST be based on the operation, NEVER include SOR name
  - ‚úÖ **CORRECT:** `DTOs/<Operation>Request/` (e.g., `DTOs/CreateEntityRequest/`, `DTOs/GetEntity/`)
  - ‚úÖ **CORRECT:** `DTOs/Get<Entity>/` (e.g., `DTOs/GetEmployee/`, `DTOs/GetLeave/`)
- **‚ùå WRONG: SOR-Based Naming:** DTO folder names MUST NOT include SOR (System of Record) name
  - ‚ùå **WRONG:** `DTOs/<Operation><SOR>/` (e.g., `DTOs/CreateEntityD365/`, `DTOs/GetEntityOracle/`)
  - ‚ùå **WRONG:** `DTOs/<Operation><SOR>Request/` (e.g., `DTOs/CreateEntitySAPRequest/`)
- **Why:** SOR is determined by System Abstraction being called, not by folder name. Folder names describe WHAT operation is performed, not WHERE it's performed.

**DTO Folder Location:**
- **Standard Pattern:** `DTOs/<OperationName>/<Feature>ReqDTO.cs` and `DTOs/<OperationName>/<Feature>ResDTO.cs`
- **Example:** `DTOs/Create<Entity>/Create<Entity>ReqDTO.cs` and `DTOs/Create<Entity>/Create<Entity>ResDTO.cs`

### 1.5 Functions Folder Structure Rules

**üî¥ CRITICAL: Function Folder Structure**

**WRONG:**
```
Functions/
‚îî‚îÄ‚îÄ <Feature>Function.cs  // ‚ùå Missing subfolder
```

**CORRECT:**
```
Functions/
‚îî‚îÄ‚îÄ <Entity>Functions/  // ‚úÖ Plural subfolder matching generic domain name
    ‚îî‚îÄ‚îÄ <Operation>Function.cs  // ‚úÖ Function class is operation-specific
```

**Why:** Process Layer Functions MUST be in subfolders with plural names.

**üî¥ CRITICAL - Function Folder Naming Rules:**
- **‚úÖ CORRECT:** Function folder name MUST match the generic domain name (e.g., `<Entity>Functions` for `<Entity>` domain)
- **‚ùå WRONG:** Operation-specific folder names (e.g., `<Operation>Functions` should be `<Entity>Functions`)
- **Why:** Function folders group operations for the same business entity. If domain is `<Entity>`, the folder should be `<Entity>Functions` (can contain multiple `<Operation>Function` classes)
- **Real-world example:** If domain is `Attendance`, the folder should be `AttendanceFunctions` (can contain `LateLoginFunction`, `EarlyLoginFunction`, etc.)
- **Rule:** Function folder represents the business entity, not the operation. Function class and attribute remain operation-specific.
- **Examples:**
  - Domain: `<Entity>` ‚Üí Folder: `<Entity>Functions` (not `<Operation>Functions`)
  - **Real-world example:** Domain: `Attendance` ‚Üí Folder: `AttendanceFunctions` (not `LateLoginFunctions`)

**Folder Location:** `Functions/<Entity>Functions/<Operation>Function.cs`

**Namespace Pattern:** `<NS>.Functions.<Entity>Functions`

**Naming Breakdown:**
- **Folder:** `<Entity>Functions` (matches generic domain name)
- **Class:** `<Operation>Function` (operation-specific)
- **Attribute:** `[Function("<Operation>")]` (operation-specific)

### 1.6 Namespace Conventions

| Folder | Namespace Pattern |
|--------|-------------------|
| ConfigModels | `<NS>.ConfigModels` |
| Constants | `<NS>.Constants` |
| Domains | `<NS>.Domains.<BusinessDomain>` | Business domain examples: Properties, Facilities, Automotive, Food, HumanResource, KABITaxi, etc. |
| DTOs | `<NS>.DTOs.<FeatureName>` |
| Enums | `<NS>.Enums` |
| Extensions | `<NS>.Extensions` |
| Functions | `<NS>.Functions.<ModuleName>Functions` |
| Helper | `<NS>.Helper` |
| ProcessAbstractions | `<NS>.ProcessAbstractions.<ModuleName>` |
| Services | `<NS>.Services` |
| SystemAbstractions | `<NS>.SystemAbstractions.<ModuleName>Mgmt` |

### 1.7 Verification Checklist

**üõë BEFORE creating any code, verify folder structure:**

- [ ] Domains/ exists and is populated (MANDATORY for standard Process Layer)
- [ ] DTOs/ folder for all request/response DTOs
- [ ] SystemAbstractions/ exists
- [ ] ProcessAbstractions/ only if calling other Process Layers
- [ ] Services/ only if orchestration logic exists
- [ ] Functions/ with plural subfolders (e.g., `<Feature>Functions/`)
- [ ] Helper/ folder exists (for ResponseDTOHelper)
- [ ] NO CustomAuthenticationMiddleware
- [ ] NO Attributes/ folder
- [ ] NO SoapEnvelopes/ folder
- [ ] Repositories/ only in Central Data Layer (Shared Services)
- [ ] Models/ only in Central Data Layer (EF Core entities)
- [ ] Domain folder structure follows rules (single domain = no subfolder, multiple domains = subfolder required)
- [ ] DTO folder names are operation-based (NO SOR names)

**üõë IF ANY CHECKPOINT FAILS ‚Üí STOP ‚Üí Fix folder structure ‚Üí Then proceed**

---

## 2. WHEN PROCESS LAYER IS REQUIRED (CRITICAL DECISION)

**üî¥ CRITICAL RULE - Process Layer vs System Layer Entry Point:**

**Process Layer IS Required When:**
- ‚úÖ **Multiple SORs:** Process orchestrates multiple System Layer Functions (cross-SOR orchestration)
- ‚úÖ **Business Logic Orchestration:** Complex business logic, multi-step workflows, cross-SOR decisions
- ‚úÖ **Error Handling Orchestration:** Multiple error handling System Layer calls (email operations in error handling are not implemented per "Email Operations in Error Handling/Observability" rule - System-Layer-Rules.md, Section 11)
- ‚úÖ **Looping/Iteration:** Business logic that requires looping/iteration over multiple API calls
- ‚úÖ **Request/Response Transformation with Business Logic:** Complex transformations that require business rules, validations, or multi-step processing

**System Layer CAN Be Entry Point When:**
- ‚úÖ **Single SOR:** Only one System Layer operation (no cross-SOR orchestration)
- ‚úÖ **No Orchestration:** No multiple System Layer calls, no business logic decisions across SORs
- ‚úÖ **Simple Request/Response Transformation:** System Layer handles client request/response transformation using System Layer rules (DTOs, Handlers, mapping)
- ‚úÖ **Direct Client Access:** External clients call System Layer Function directly (no Process Layer in between)

**Decision Rule:**
- **No orchestration needed** ‚Üí System Layer can be entry point (clients call System Layer directly)
- **Orchestration needed** ‚Üí Process Layer required (clients call Process Layer, which orchestrates System Layer)

**Key Point:** Process Layer is NOT automatically required just because it's an entry point. If there's no orchestration (single SOR, no business logic), System Layer can be the entry point and handle request/response transformation using System Layer rules.

**üî¥ CRITICAL: Simple vs Complex Transformation**

**Simple Request/Response Transformation (System Layer CAN handle):**
- ‚úÖ **Header extraction:** `req.Headers.TryGetValue("header-name")` - Reading HTTP headers and storing in DTO
- ‚úÖ **Query parameter extraction:** `req.Query.TryGetValue("param-name")` - Reading query parameters and storing in DTO
- ‚úÖ **Simple conditional logic:** If empty/null, use default value (e.g., if dateTime is empty, use current date)
- ‚úÖ **Date/time formatting:** Convert to ISO 8601, apply format mask, parse date strings
- ‚úÖ **Field mapping:** Direct field-to-field mapping (no business rules, just data transformation)
- ‚úÖ **Data type conversion:** String to int, date parsing, boolean conversion, etc.
- ‚úÖ **Array/collection operations:** Filter, map, transform elements (simple operations, not business logic)
- ‚úÖ **String operations:** Trim, uppercase, lowercase, substring, concatenation
- ‚úÖ **Simple validation:** Null/empty checks, required field validation (NOT complex business rules)

**Complex Request/Response Transformation (Process Layer REQUIRED):**
- ‚ùå **Multi-step business rules:** Multiple conditions with business logic (if status=X and role=Y then Z, else W)
- ‚ùå **Cross-SOR data enrichment:** Fetch data from multiple SORs to enrich request before calling target SOR
- ‚ùå **Business validation rules:** Complex validation logic beyond simple null/empty checks (e.g., validate business rules, check permissions, validate against business policies)
- ‚ùå **Decision-based transformations:** Transform based on business decisions (if status=X then transform to Y format, else transform to Z format)
- ‚ùå **Aggregation logic:** Sum, count, group by with business rules (not just simple math)
- ‚ùå **Workflow orchestration:** Multi-step processing with dependencies between steps
- ‚ùå **Business rule evaluation:** Evaluate business conditions and apply different transformations based on results

**Simple Transformation Checklist (ALL must be YES for System Layer):**
- [ ] Single-step operation (no multi-step processing)
- [ ] No business rules (just data transformation)
- [ ] No cross-SOR dependencies (no need to fetch data from other SORs)
- [ ] No decision-based routing (no if-then-else business logic)
- [ ] Can be implemented in Handler/Atomic Handler (not requiring Service orchestration)
- [ ] No business validation beyond simple null/empty checks

**Example - System Layer as Entry Point (WITH Transformations):**
- **Boomi process:** Entry point (WSS/HTTP) ‚Üí Extract companyCode from header ‚Üí Transform dateTime (if empty, use current date) ‚Üí Single SOR operation (D365) ‚Üí Response
- **Analysis:** 
  - ‚úÖ Single SOR (D365 only)
  - ‚úÖ Simple transformations:
    - Header extraction: `req.Headers.TryGetValue("company-code")` ‚Üí Simple data extraction
    - DateTime transformation: If empty, use current date ‚Üí Simple conditional (not complex business logic)
  - ‚úÖ No orchestration (no multiple System Layer calls)
- **Decision:** ‚úÖ System Layer is entry point (clients call System Layer Function directly)
- **Implementation:** 
  - System Layer Function extracts header (`req.Headers.TryGetValue("company-code")`)
  - System Layer Handler/Atomic Handler transforms dateTime (if empty, use current date)
  - System Layer calls D365, transforms response

**Example - System Layer as Entry Point (NO Transformations):**
- **Boomi process:** Entry point (WSS/HTTP) ‚Üí Single SOR operation ‚Üí Response
- **Analysis:** Single SOR, no multiple System Layer calls, no orchestration needed
- **Decision:** System Layer is entry point (clients call System Layer Function directly)
- **Implementation:** System Layer Function handles request transformation, calls SOR, transforms response

**Example - Process Layer Required:**
- **Boomi process:** Entry point (WSS/HTTP) ‚Üí Validate business rules ‚Üí Decision (if status=X) ‚Üí SOR-1 operation ‚Üí If SOR-1 success, call SOR-2 ‚Üí Aggregate results ‚Üí Response
- **Analysis:**
  - ‚ùå Multiple SORs (SOR-1 and SOR-2)
  - ‚ùå Complex business logic (decision-based routing, aggregation)
  - ‚ùå Orchestration required (multiple System Layer calls with dependencies)
- **Decision:** ‚ùå Process Layer required
- **Implementation:** Process Layer Function orchestrates System Layer Functions for SOR-1 and SOR-2

**Entry Point Decision Flowchart:**

```
Start: Entry Point Operation
  ‚Üì
Is there orchestration? (Multiple SORs, multiple System Layer calls)
  ‚îú‚îÄ YES ‚Üí Process Layer Required
  ‚îî‚îÄ NO ‚Üí Continue
    ‚Üì
Are transformations needed?
  ‚îú‚îÄ NO ‚Üí System Layer Entry Point
  ‚îî‚îÄ YES ‚Üí Continue
    ‚Üì
Are transformations SIMPLE? (Header extraction, simple conditionals, date formatting)
  ‚îú‚îÄ YES ‚Üí System Layer Entry Point
  ‚îî‚îÄ NO ‚Üí Continue
    ‚Üì
Are transformations COMPLEX? (Multi-step business rules, cross-SOR enrichment, decision-based)
  ‚îú‚îÄ YES ‚Üí Process Layer Required
  ‚îî‚îÄ NO ‚Üí System Layer Entry Point (default - when in doubt, System Layer can handle it)
```

## 2. Azure Functions Rules

**üö® CRITICAL:** Functions are thin HTTP orchestrators.

### Azure Functions - Pre-Creation Validation

**üõë PRE-CREATION VALIDATION (MANDATORY - STOP IF NOT COMPLETE)**

**üö® YOU CANNOT CREATE ANY FUNCTION UNTIL:**

1. ‚úÖ **STOP AND VERIFY:** Have I created Domain class?
2. ‚úÖ **STOP AND VERIFY:** Have I created Service class?
3. ‚úÖ **STOP AND VERIFY:** Do I know the exact folder location (Functions/<Feature>Functions/ subfolder)? (See Section 1.5 for folder structure rules)
4. ‚úÖ **STOP AND VERIFY:** Have I read ALL sections in "AZURE FUNCTIONS RULES"?
5. ‚úÖ **STOP AND VERIFY:** Have I checked Phase 1 document (Section 13: Orchestration Diagram) for ALL System Layer calls (success path AND error path)?
6. ‚úÖ **STOP AND VERIFY:** Have I verified orchestration requirements (single call vs. multiple calls, error handling orchestration)?
7. ‚úÖ **STOP AND VERIFY:** Have I checked Phase 1 document for HTTP headers and request parameters required by the Boomi process?
8. ‚úÖ **STOP AND VERIFY:** Have I verified which fields the System Layer DTO requires (check System Layer DTO validation methods)?
9. ‚úÖ **STOP AND VERIFY:** Have I identified all sources of data (request body, headers, query parameters, config) needed to populate System Layer DTO fields?
10. ‚úÖ **üî¥ CRITICAL - STOP AND VERIFY:** Do I understand that I MUST pass DTO (not Domain) to Service? Domain is for internal purposes only, DTO is the contract between layers (see Section 8.1: Services Rules - Pre-Creation Validation)?
11. ‚úÖ **üî¥ CRITICAL - STOP AND VERIFY:** Do I understand that Function names MUST NOT contain "API" keyword? "API" suffix/keyword is ONLY for System Layer Functions. Process Layer Functions MUST NOT contain "API", "Api", or "api" in Function attribute, class name, or file name.

**üõë IF ANY CHECKPOINT FAILS ‚Üí STOP ‚Üí Complete missing step ‚Üí Then create Function**

**üî¥ MANDATORY WORKFLOW STEP 9: Functions**

**üö® BEFORE creating Functions (BLOCKING - CANNOT PROCEED WITHOUT COMPLETING):**

- [ ] **BLOCKING:** Did I complete WORKFLOW STEP 8 (or skip if no helpers needed)?
- [ ] **BLOCKING:** Did I find exact template/example in Section 2?
- [ ] **BLOCKING:** Did I copy template exactly before writing code?
- [ ] **BLOCKING:** Did I read "üõë PRE-CREATION VALIDATION" in Section 2?
- [ ] **BLOCKING:** Did I check "COMMON MISTAKES" #19 (`var` keyword), #22 (Verbose Header Reading)?

**If you write code without reading Section 2 first ‚Üí DELETE code ‚Üí Read Section 2 ‚Üí Retry**

**Implementation:**
- [ ] Create Function classes
- [ ] **üî¥ CRITICAL:** Verify Function attribute, class name, and file name do NOT contain "API" keyword (NO "API", "Api", or "api")
- [ ] Verify orchestration, error handling
- [ ] Verify `dto.Populate(domain)` is called INLINE (not separate method)
- [ ] Verify NO `var` keyword
- [ ] Verify NO `internal` keyword
- [ ] Verify NO `try-catch` blocks (see Section 11: Middleware Rules)

**üõë IF ANY CHECKPOINT FAILS ‚Üí STOP ‚Üí Complete missing step ‚Üí Then proceed**

### Azure Functions - Folder Structure & Naming

**üî¥ CRITICAL: Function Folder Structure**

**üî¥ CROSS-REFERENCE:** See Section 1.5 (Functions Folder Structure Rules) for complete folder structure details.

**Key Rules:**
- **Folder Location:** `Functions/<Entity>Functions/<Operation>Function.cs` (MANDATORY: plural subfolder matching generic domain name)
- **Namespace Pattern:** `<NS>.Functions.<Entity>Functions`
- **Why:** Process Layer Functions MUST be in subfolders with plural names. Folder name MUST match the generic domain name.
- **üî¥ CRITICAL:** Function folder name represents the business entity (matches domain), while Function class/attribute represent the operation.

**WRONG:**
```
Functions/
‚îî‚îÄ‚îÄ EntityFunction.cs  // ‚ùå Missing subfolder
```

**CORRECT:**
```
Functions/
‚îî‚îÄ‚îÄ EntityFunctions/  // ‚úÖ Plural subfolder matching generic domain name
    ‚îî‚îÄ‚îÄ CreateEntityFunction.cs  // ‚úÖ Function class is operation-specific
    ‚îî‚îÄ‚îÄ GetEntityFunction.cs  // ‚úÖ Multiple operations can be in same folder
```

**Example with Generic Domain:**
```
Functions/
‚îî‚îÄ‚îÄ AttendanceFunctions/  // ‚úÖ Matches generic domain name (Attendance)
    ‚îî‚îÄ‚îÄ LateLoginFunction.cs  // ‚úÖ Operation-specific class
    ‚îî‚îÄ‚îÄ EarlyLoginFunction.cs  // ‚úÖ Another operation for same entity
```

**üî¥ CRITICAL NAMING RULE:**
- **Folder Name:** `<Entity>Functions` (e.g., `AttendanceFunctions`, `LeaveFunctions`) - MUST match generic domain name
- **Class Name:** `<Operation>Function` (e.g., `<Operation>Function`) - Operation-specific
- **File Name:** `<Operation>Function.cs` (e.g., `<Operation>Function.cs`) - Operation-specific
- **Function Attribute:** `[Function("<Operation>")]` (e.g., `[Function("<Operation>")]`) - **NO "API" keyword**
- **üî¥ CRITICAL:** Function folder name represents the business entity (matches domain), while Function class/attribute represent the operation
- **Examples:**
  - Domain: `<Entity>` ‚Üí Folder: `<Entity>Functions` (not `<Operation>Functions`)
  - **Real-world example:** Domain: `Attendance` ‚Üí Folder: `AttendanceFunctions` (not `LateLoginFunctions`)
- **üî¥ CRITICAL: ‚ùå NEVER EVER use "API" keyword in Process Layer Function names** - This is a MANDATORY rule with NO EXCEPTIONS
  - ‚ùå **WRONG:** `[Function("CreateEntityAPI")]` - Contains "API" keyword
  - ‚ùå **WRONG:** `CreateEntityAPIFunction` - Class name contains "API" keyword
  - ‚ùå **WRONG:** `CreateEntityApiFunction` - "Api" (case-insensitive) is also PROHIBITED
  - ‚úÖ **CORRECT:** `[Function("CreateEntity")]` - No "API" keyword
  - ‚úÖ **CORRECT:** `CreateEntityFunction` - No "API" keyword
  - **Why:** "API" suffix/keyword is ONLY for System Layer Functions. Process Layer Functions MUST NOT contain "API" in any form (API, Api, api) in Function attribute, class name, or file name.
- **‚ùå NEVER include SOR (System of Record) name in Function names** - Function names MUST be based on the operation it performs, NOT the target SOR
  - ‚ùå **WRONG:** `<Operation><SOR>Function` (e.g., `<Operation>D365Function`, `<Operation>OracleFunction`, `<Operation>SAPFunction`)
  - ‚úÖ **CORRECT:** `<Operation>Function` (e.g., `<Operation>Function`)
  - **Why:** Function names describe WHAT operation is performed, not WHERE it's performed. The SOR is determined by the System Abstraction being called, not the Function name.

**Naming Comparison:**
| Layer | Class Name | Function Attribute | Example |
|-------|-----------|-------------------|---------|
| **Process Layer** | `<Operation>Function` | `[Function("<Operation>")]` | `CreateEntityFunction` ‚Üí `[Function("CreateEntity")]` |
| **System Layer** | `<Operation>API` | `[Function("<Operation>")]` | `CreateEntityAPI` ‚Üí `[Function("CreateEntity")]` |

### Azure Functions - Function Reuse & Versioning

**üî¥ CRITICAL:** Before creating any new Function, you MUST:

1. ‚úÖ **Check if Function already exists** in the target Process Layer repository
   - Scan `Functions/` directory in the repository
   - Check for Functions with similar names/purposes

2. ‚úÖ **If Function exists:**
   - **Analyze changes:** Are the changes non-breaking (backward compatible)?
     - ‚úÖ **Non-breaking changes** ‚Üí Update existing Function
       - Adding optional fields to request DTO
       - Adding new fields to response DTO
       - Internal logic improvements (same input/output contract)
       - Performance optimizations
     - ‚ùå **Breaking changes** ‚Üí Create new versioned Function
       - Removed required fields from request DTO
       - Changed field types in request/response DTOs
       - Removed fields from response DTO
       - URL/route changes
       - Business logic changes that affect existing consumers

3. ‚úÖ **If Function does NOT exist:** Create new Function following naming conventions

**Function Versioning Pattern:**
- Original: `<Operation>Function` ‚Üí `[Function("<Operation>")]`
- Version 2: `<Operation>V2Function` ‚Üí `[Function("<Operation>V2")]` (if breaking changes)
- Version 3: `<Operation>V3Function` ‚Üí `[Function("<Operation>V3")]` (if further breaking changes)

**Breaking Change Examples:**
```csharp
// ‚ùå BREAKING: Removed required field
// Original: public string <Entity>Id { get; set; }  // Required
// New: Field removed ‚Üí BREAKING

// ‚ùå BREAKING: Changed field type
// Original: public DateTime <Entity>Date { get; set; }
// New: public string <Entity>Date { get; set; } ‚Üí BREAKING

// ‚úÖ NON-BREAKING: Added optional field
// Original: public string <Entity>Name { get; set; }
// New: public string <Entity>Name { get; set; }
//      public string? <Entity>Email { get; set; }  // Optional ‚Üí NON-BREAKING
```

**Decision Flow:**
```
Does Function exist?
‚îú‚îÄ NO ‚Üí Create new Function
‚îî‚îÄ YES ‚Üí Are changes breaking?
    ‚îú‚îÄ NO ‚Üí Update existing Function
    ‚îî‚îÄ YES ‚Üí Create versioned Function (V2, V3, etc.)
```

**üî¥ CRITICAL: Same Operation, Different SOR (System of Record)**

**Scenario:** Same business operation (e.g., `<Operation>`) but targeting different SORs (e.g., `<SOR1>` vs `<SOR2>`).

**Rule:** **CREATE NEW Function** (NOT replace existing, NOT version existing)

**Reasoning:**
- Different SOR = Different System Layer = Different contracts/endpoints
- Different consumers may use different systems
- Allows gradual migration and parallel operation
- Each SOR has its own System Abstraction (e.g., `I<Entity>Mgmt` for `<SOR1>`, `I<SOR2>Mgmt` for `<SOR2>`)

**Example:**
- Existing: `<Operation>Function` ‚Üí calls `I<Entity>Mgmt` ‚Üí `sys-<sor1>-mgmt` (`<SOR1>`)
- New: `<Operation>Function` ‚Üí calls `I<SOR2>Mgmt` ‚Üí `sys-<sor2>-mgmt` (`<SOR2>`)
- **Note:** Both Functions have the same name because they perform the same operation. The SOR is determined by which System Abstraction is injected/called, NOT by the Function name.
- **üî¥ CRITICAL:** If both Functions need to exist in the same repository, they must be differentiated by route or be in different repositories. The Function class name MUST remain `<Operation>Function` (no SOR name in Function name).

**Service Layer Decision:**
- **Option 1:** Service calls specific System Abstraction based on business logic (e.g., flag, configuration)
- **Option 2:** Service calls both System Abstractions (orchestration pattern) if business requires dual-write
- **Option 3:** Separate Services for each SOR (e.g., `<Entity>Service` for `<SOR1>`, `<SOR2><Entity>Service` for `<SOR2>`)

**Documentation Requirement:**
- MUST document in Phase 2 Function Exposure Decision document:
  - Which SOR each Function targets
  - Whether Service calls one or both systems
  - Migration strategy (if replacing old system)

**üõë VALIDATION CHECKLIST:**
- [ ] Scanned for existing Process Layer repositories
- [ ] Identified target repository (existing or new)
- [ ] Checked if Function already exists in target repository
- [ ] Analyzed if changes are breaking or non-breaking
- [ ] **If same operation, different SOR ‚Üí CREATE NEW Function (documented in Phase 2)**
- [ ] Decided: Update existing OR Create new OR Create versioned
- [ ] Documented decision in Phase 2 documentation

**üõë IF ANY CHECKPOINT FAILS ‚Üí STOP ‚Üí Complete repository analysis ‚Üí Then proceed**

### Azure Functions - Orchestration Verification

**üî¥ CRITICAL: FUNCTION ORCHESTRATION VERIFICATION (MANDATORY)**

**üö® BEFORE creating a Function, you MUST verify orchestration requirements:**

1. ‚úÖ **Check Phase 1 document (Section 13: Process and System Layer Orchestration Diagram)** to identify:
   - How many System Layer calls are in the success path?
   - How many System Layer calls are in the error path?
   - What orchestration is required (sequential calls, conditional calls, error handling)?

2. ‚úÖ **Check Phase 1 document (Section 7: Execution Order)** to identify orchestration requirements:
   - Are there multiple sequential System Layer operations?
   - Do System Layer operations depend on each other (output of one feeds into another)?
   - Are there error handling System Layer calls?

3. ‚úÖ **Determine orchestration location:**
   - **Single System Layer call** ‚Üí Service handles it (Function just calls Service)
   - **Multiple System Layer calls (business logic)** ‚Üí Service orchestrates (Function calls Service, Service orchestrates multiple System Abstractions - see Section 8.4: Services Rules - Handling Multiple Failures)
   - **Error handling System Layer calls (cross-cutting concerns)** ‚Üí Function ONLY orchestrates (Services MUST NOT orchestrate cross-cutting concerns - see Section 8.2: Service Separation Rule)

4. ‚úÖ **Verify error handling orchestration:**
   - If Phase 1 shows System Layer call on error ‚Üí Function MUST orchestrate that System Layer call in error path (using `else` block, NOT try-catch)
   - If Phase 1 shows multiple error handling steps ‚Üí Function MUST orchestrate all error handling System Layer calls
   - **Pattern:** Function `else` block ‚Üí Call error handling Service (e.g., `NotificationService`) ‚Üí Throw exception
   - **üî¥ CRITICAL:** Services MUST NOT orchestrate error handling - Error notifications are cross-cutting concerns and violate Service Separation Rule (Section 8.2)

**Example Function Orchestration Pattern:**
```csharp
[Function("<Operation>")]
public async Task<BaseResponseDTO> Run([HttpTrigger(AuthorizationLevel.Anonymous, "post", Route = "<resource>/<operation>")] HttpRequest req)
{
    // Success path: Single System Layer call
    <Operation>ReqDTO? dto = await req.ReadBodyAsync<<Operation>ReqDTO>();
    if (dto == null) throw new NoRequestBodyException(...);
    dto.Validate();
    
    <Entity>Domain domain = new <Entity>Domain();
    dto.Populate(domain);
    
    HttpResponseSnapshot response = await _service.Create<Entity>(dto);
    
    if (response.IsSuccessStatusCode)
    {
        // Transform and return success
        string responseContent = await response.ExtractDataAsync();
        <Operation>ResDTO resDto = new <Operation>ResDTO();
        ResponseDTOHelper.Populate<Entity>Res(responseContent, resDto);
        return new BaseResponseDTO(InfoConstants.SUCCESS_MESSAGE, "", resDto);
    }
    else
    {
        // Error path: Orchestrate error handling System Layer calls BEFORE throwing
        BaseResponseDTO errorResponse = response.ExtractBaseResponse();
        string executionId = RequestHeaders.RequestId.Item2.Value?.ToString() ?? string.Empty;
        string processName = InfoConstants.PROCESS_NAME;
        string environment = _options.Environment;
        string requestPayload = JsonSerializer.Serialize(dto);
        string attachmentFileName = $"{_options.FileName}{DateTime.UtcNow:yyyy-MM-ddTHH:mm:ss.fffZ}.txt";
        string attachmentContent = requestPayload;
        
        HttpResponseMessage notificationResponse = await _notificationService.SendErrorNotificationEmail(
            processName: processName,
            environment: environment,
            executionId: executionId,
            errorMessage: errorResponse.Message,
            attachmentFileName: attachmentFileName,
            attachmentContent: attachmentContent);
        
        if (notificationResponse.IsSuccessStatusCode)
        {
            _logger.Info($"Error notification email sent successfully. Status: {notificationResponse.StatusCode}");
        }
        else
        {
            BaseResponseDTO notificationErrorResponse = await notificationResponse.ExtractBaseResponseAsync();
            string notificationErrorMessage = notificationErrorResponse?.Message ?? "Unknown error";
            _logger.Error($"Failed to send error notification email. Status: {notificationResponse.StatusCode}. Error: {notificationErrorMessage}");
        }
        
        // Throw exception - middleware will handle normalization
        throw new PassThroughHttpException(errorResponse, (HttpStatusCode)response.StatusCode);
    }
}
```

**üî¥ CRITICAL: NEVER skip error handling orchestration:**
- ‚ùå **WRONG:** Function only handles success path, ignores error handling System Layer calls
- ‚úÖ **CORRECT:** Function orchestrates both success and error paths, including all error handling System Layer calls identified in Phase 1

**üî¥ CRITICAL: API Ecosystem Principle - HTTP Status Code Must Match Response Body (MANDATORY)**

**üö® MANDATORY RULE:** HTTP status code MUST accurately reflect the response body state. This is a fundamental API ecosystem principle.

**Principle:**
- ‚úÖ **If HTTP status code is success (2xx)** ‚Üí Response body MUST contain success data
- ‚úÖ **If HTTP status code is error (4xx/5xx)** ‚Üí Response body MUST contain error data
- ‚ùå **NEVER return HTTP 200 with error body** - This violates RESTful API principles

**Rule:**
- ‚úÖ **CORRECT:** Error path throws exception (e.g., `PassThroughHttpException`) ‚Üí Results in HTTP error status code (4xx/5xx) with error body
- ‚ùå **WRONG:** Error path returns `BaseResponseDTO` directly ‚Üí Results in HTTP 200 with error body

**Deviation from Boomi Behavior:**
- **Boomi:** May return HTTP 200 with error message in body (per Phase 1 Section 18)
- **Azure Function (API Ecosystem):** MUST return HTTP error status code (4xx/5xx) with error message in body
- **Why:** API ecosystem standards require proper HTTP status codes for correct client error handling and monitoring

**Implementation Pattern:**
```csharp
else
{
    // Error path: <BusinessOperation> returns non-20x ‚Üí send email ‚Üí throw exception
    BaseResponseDTO errorFromBusinessOperation = response.ExtractBaseResponse();
    _logger.Error($"<BusinessOperation> call failed: {errorMessage}");

    // Error handling orchestration: Send email notification (matches Boomi error path)
    // ... email notification code ...

    // üî¥ CRITICAL: API Ecosystem Principle - HTTP Status Code Must Match Response Body
    // Principle: If HTTP status code is success ‚Üí body should be success
    //            If HTTP status code is error ‚Üí body should be error
    // This is a MANDATORY principle for the API ecosystem.
    //
    // Deviation from Boomi Behavior:
    // - Boomi (Phase 1 Section 18): Error case returns HTTP 200 with error message in body
    // - Azure Function (API Ecosystem): Error case MUST return HTTP error status code (4xx/5xx) with error message in body
    //
    // Rationale:
    // 1. API ecosystem standards require HTTP status codes to accurately reflect response state
    // 2. HTTP 200 with error body violates RESTful API principles and causes confusion for API consumers
    // 3. Proper HTTP status codes enable correct error handling by clients and monitoring systems
    // 4. ExceptionHandlerMiddleware will normalize the exception to BaseResponseDTO with appropriate HTTP status code
    //
    // Error message source: From <BusinessOperation> operation (errorFromBusinessOperation.Message)
    // Note: Email operation failure is logged but does NOT affect the response error message
    // The response error message always comes from the <BusinessOperation> operation failure, not from email operation
    throw new PassThroughHttpException(errorFromBusinessOperation, (HttpStatusCode)response.StatusCode);
}
```

**Why This Rule Exists:**
1. **API Standards:** RESTful API principles require HTTP status codes to accurately reflect response state
2. **Client Error Handling:** Proper status codes enable clients to handle errors correctly
3. **Monitoring Systems:** HTTP status codes are used by monitoring/alerting systems for error detection
4. **Consistency:** Ensures all APIs in the ecosystem follow the same pattern
5. **Documentation:** Comments provide evidence for why we deviate from Boomi behavior

**Example Violations:**
- ‚ùå **WRONG:** `return new BaseResponseDTO("Error", errorMessage, errorResDto);` (returns HTTP 200 with error body)
- ‚úÖ **CORRECT:** `throw new PassThroughHttpException(errorResponse, (HttpStatusCode)response.StatusCode);` (returns HTTP error status with error body)

**üî¥ CRITICAL: Error Message Source Documentation (MANDATORY)**
- **üö® MANDATORY RULE:** When error path contains multiple operations (e.g., business operation + error notification operation), Function MUST clearly document which error message is used in the response
- **Rule:** The error message in the response MUST come from the primary business operation failure, NOT from error notification operation failures
- **Documentation Requirements:**
  1. **MUST document error message source:** Comments MUST explicitly state which operation's error message is used (e.g., "Error message from <BusinessOperation> operation")
  2. **MUST document error notification handling:** Comments MUST clarify that error notification operation failures are logged separately and do NOT affect the response error message
  3. **MUST reference Phase 1:** Comments MUST reference Phase 1 section that documents the error message source (e.g., "Per Phase 1 Section <X>: Error message comes from <BusinessOperation> operation")
- **Implementation Pattern:**
  ```csharp
  else
  {
      // Error path: <BusinessOperation> returns non-20x ‚Üí send email ‚Üí return error response
      BaseResponseDTO errorFromBusinessOperation = response.ExtractBaseResponse();
      string errorMessage = errorFromBusinessOperation.Message; // Extract error message from business operation
      _logger.Error($"<BusinessOperation> call failed: {errorMessage}"); // Logging messages use literal strings, NOT constants

      // Error handling orchestration: Send email notification (matches Boomi error path)
      // ... email notification code ...

      if (emailResponse.IsSuccessStatusCode)
      {
          _logger.Info($"{InfoConstants.ERROR_NOTIFICATION_EMAIL_SENT}. Status: {emailResponse.StatusCode}");
      }
      else
      {
          BaseResponseDTO emailErrorResponse = emailResponse.ExtractBaseResponse();
          string emailErrorMessage = emailErrorResponse?.Message ?? ErrorConstants.UNKNOWN_ERROR.Message;
          _logger.Error($"Failed to send error notification email. Status: {emailResponse.StatusCode}. Error: {emailErrorMessage}");
      }

      // Return error response (matches Boomi <error-map-shape> ‚Üí <return-shape> return with error message)
      // Per Phase 1 Section <X>: Error case returns HTTP <status-code> but contains error message
      // Error message source: From <BusinessOperation> operation (Phase 1 Section <X> extracts <ErrorProperty> from <BusinessOperation> HTTP response, <error-map-shape> uses it)
      // Note: Email operation failure is logged but does NOT affect the response error message
      // The response error message always comes from the <BusinessOperation> operation failure, not from email operation
      <Operation>ResDTO errorResDto = new <Operation>ResDTO
      {
          Success = "false",
          Message = $"Error <operation-description>: {errorMessage}", // errorMessage from <BusinessOperation> operation (errorFromBusinessOperation.Message)
          // ... other properties ...
      };
      return new BaseResponseDTO("Error <operation-description>", errorMessage, errorResDto); // errorMessage from <BusinessOperation> operation
  }
  ```
- **Why This Rule Exists:**
  1. **Clarity:** Developers need to understand which error message is returned to the client
  2. **Debugging:** When troubleshooting, it's critical to know if the error is from the business operation or the notification operation
  3. **Boomi Parity:** Matches Boomi behavior where error response uses error message from primary business operation, not from error handling operations
  4. **Consistency:** Ensures all Functions follow the same pattern for error message handling
- **Example Violations:**
  - ‚ùå **WRONG:** No comment explaining which error message is used
  - ‚ùå **WRONG:** Using error message from email operation in response (should use business operation error message)
  - ‚ùå **WRONG:** Ambiguous variable names (e.g., `errorMessage` without clarifying source)
  - ‚úÖ **CORRECT:** Clear comments documenting error message comes from business operation, email operation failures logged separately

### Azure Functions - Mandatory Call Flow

**MANDATORY CALL FLOW:**
- Functions call Services (inject directly: `<Entity>Service` OR via interface: `I<Entity>Service`)
- Functions NEVER call System/Process Abstractions directly
- Functions NEVER call System/Process Layers directly
- **üî¥ CRITICAL:** Functions MUST pass DTOs to Services (NEVER pass Domain objects)

**KEY RULES:**
- ‚úÖ Functions inject Services (can inject directly: `<Entity>Service` OR via interface: `I<Entity>Service`)
- ‚úÖ Functions pass DTOs to Services (not Domain objects, not individual parameters)
- ‚ùå Functions MUST NOT inject System/Process Abstractions directly
- ‚ùå Functions MUST NOT call System/Process Layers directly
- ‚ùå Functions MUST NOT pass Domain objects to Services
- ‚úÖ **üî¥ CRITICAL:** Functions MUST use constants (InfoConstants.cs, ErrorConstants.cs) for business logic string literals, NEVER hardcode strings
  - **üî¥ CROSS-REFERENCE:** Use constants instead of hardcoded strings (ErrorConstants.cs, InfoConstants.cs)
  - **Examples:** Process names, default environment values, success messages, email subjects, default execution IDs
  - **EXCEPTIONS (ALLOWED as literal strings):** Function attribute names, stepName values, logging messages

### Azure Functions - Structure & Patterns

**Function Structure (Standard):**

```csharp
// Pattern A: Service without interface (direct injection)
public class Create<Entity>Function {
    private readonly ILogger<Create<Entity>Function> _logger; 
    private readonly <Entity>Service _service;  // ‚úÖ Direct injection allowed

    public Create<Entity>Function(ILogger<Create<Entity>Function> l, <Entity>Service s) {
        _logger = l; 
        _service = s; 
    }

// Pattern B: Service with interface (interface injection)
public class Create<Entity>Function {
    private readonly ILogger<Create<Entity>Function> _logger; 
    private readonly I<Entity>Service _service;  // ‚úÖ Interface injection also allowed

    public Create<Entity>Function(ILogger<Create<Entity>Function> l, I<Entity>Service s) {
        _logger = l; 
        _service = s; 
    }
    [Function("CreateEntity")]  // ‚úÖ NO "API" keyword - Process Layer Functions MUST NOT contain "API"
    public async Task<BaseResponseDTO> Run([HttpTrigger(AuthorizationLevel.Anonymous, "post", Route = "entity/create")] HttpRequest req) {
        _logger.Info("HTTP Request received for CreateEntity.");
        <Operation>ReqDTO? dto = await req.ReadBodyAsync<<Operation>ReqDTO>();
        if (dto == null) throw new NoRequestBodyException(errorDetails: [ErrorCodes.REQ_BODY_MISSING_OR_EMPTY.Message], stepName: "Create<Entity>Function.cs / Executing Run");
        // ‚úÖ Headers collection is need-based - only if headers need propagation to System Layer/SOR
        // dto.Headers = req.Headers.ToDictionary(h => h.Key.ToLower(), h => h.Value.FirstOrDefault() ?? string.Empty);
        dto.Validate(); 
        // ‚úÖ Domain is created and populated for internal purposes (business logic, validation, etc.)
        <Entity>Domain domain = new <Entity>Domain(); 
        dto.Populate(domain);
        // ‚úÖ Pass DTO to Service (not domain) - DTO is used for data passing between layers
        HttpResponseSnapshot r = await _service.Execute(dto);
        if (r.IsSuccessStatusCode) { EntityResDTO resDto = new EntityResDTO(); ResponseDTOHelper.PopulateEntity(r.ExtractData(), resDto); return new BaseResponseDTO("Success", "", resDto); }
        else { throw new PassThroughHttpException(r.ExtractBaseResponse(), (HttpStatusCode)r.StatusCode); }
    }
}
```

**Function with Orchestration:**

**üî¥ CRITICAL NOTE:** The example below is from the original rulebook but contains violations. It shows passing `domain` to services and extra parameters, which violates the rule that Functions MUST pass DTOs to Services. **Additionally, it violates the "NO API keyword" rule.** This example is preserved for reference but should NOT be used as a template. The correct pattern is shown in the "Function Structure (Standard)" example above.

```csharp
// ‚ùå NOTE: This example shows [Function("ProcessEntityAPI")] which violates the "NO API keyword" rule
// ‚úÖ CORRECT: Should be [Function("ProcessEntity")] - NO "API" keyword
[Function("ProcessEntity")]  // ‚úÖ CORRECTED: Removed "API" keyword
public async Task<BaseResponseDTO> Run([HttpTrigger(AuthorizationLevel.Anonymous, "post")] HttpRequest req) {
    // ‚ùå NOTE: Original example had "ProcessEntityAPI" in logging - violates "NO API keyword" rule
    // ‚úÖ CORRECT: Should be "ProcessEntity" - NO "API" keyword
    _logger.Info("HTTP Request received for ProcessEntity.");
    <Operation>ReqDTO? dto = await req.ReadBodyAsync<<Operation>ReqDTO>();
    if (dto == null) throw new NoRequestBodyException(errorDetails: [ErrorCodes.REQ_BODY_MISSING_OR_EMPTY.Message], stepName: "ProcessEntityFunction.cs / Executing Run");
        // ‚úÖ Headers collection is need-based - only if headers need propagation to System Layer/SOR
        // dto.Headers = req.Headers.ToDictionary(h => h.Key.ToLower(), h => h.Value.FirstOrDefault() ?? string.Empty);
        dto.Validate();
    <Entity>Domain domain = new <Entity>Domain(); dto.Populate(domain);
    // ‚ùå NOTE: This example shows passing domain to service - THIS IS WRONG per rulebook rules
    // ‚úÖ CORRECT: Should be: HttpResponseSnapshot r1 = await _service1.GetEntity(dto);
    HttpResponseSnapshot r1 = await _service1.GetEntity(domain);
    if (!r1.IsSuccessStatusCode) throw new PassThroughHttpException(r1.ExtractBaseResponse(), (HttpStatusCode)r1.StatusCode);
    ResponseDTOHelper.PopulateEntity(r1.ExtractData(), entityDto);
    HttpResponseSnapshot r2 = await _service2.GetLookupValues(refReq);
    if (!r2.IsSuccessStatusCode) throw new PassThroughHttpException(r2.ExtractBaseResponse(), (HttpStatusCode)r2.StatusCode);
    ReferenceResDTO refData = ResponseDTOHelper.PopulateReference(r2.ExtractData());
    string id = refData.Items?.FirstOrDefault(i => string.Equals(i.Name, dto.Type))?.Code ?? "";
    if (string.IsNullOrEmpty(id)) throw new RequestValidationFailureException(errorDetails: ["Invalid type"], stepName: "ProcessEntityFunction.cs / Executing Run");
    // ‚ùå NOTE: This example shows passing domain + extra parameters - THIS IS WRONG per rulebook rules
    // ‚úÖ CORRECT: Should populate id and param in dto, then: HttpResponseSnapshot r3 = await _service3.Create<Entity>(dto);
    HttpResponseSnapshot r3 = await _service3.Create<Entity>(domain, id, param);
    if (r3.IsSuccessStatusCode) { EntityResDTO res = new EntityResDTO(); ResponseDTOHelper.PopulateEntity(r3.ExtractData(), res, refData); return new BaseResponseDTO("Success", "", res); }
    else { throw new PassThroughHttpException(r3.ExtractBaseResponse(), (HttpStatusCode)r3.StatusCode); }
}
```

**Function with Batch Processing:**

**üî¥ CRITICAL NOTE:** The example below is from the original rulebook but contains violations. It shows using `try-catch` blocks and `var` keyword, which violate rulebook rules. **Additionally, it violates the "NO API keyword" rule.** This example is preserved for reference but should be corrected. The correct pattern avoids try-catch (let exceptions propagate), uses explicit types instead of `var`, and does NOT contain "API" keyword.

```csharp
// ‚ùå NOTE: This example shows [Function("BatchCreateAPI")] which violates the "NO API keyword" rule
// ‚úÖ CORRECT: Should be [Function("BatchCreate")] - NO "API" keyword
[Function("BatchCreate")]  // ‚úÖ CORRECTED: Removed "API" keyword
public async Task<BaseResponseDTO> Run([HttpTrigger(AuthorizationLevel.Anonymous, "post")] HttpRequest req) {
    // ‚ùå NOTE: Original example had "BatchCreateAPI" in logging - violates "NO API keyword" rule
    // ‚úÖ CORRECT: Should be "BatchCreate" - NO "API" keyword
    _logger.Info("HTTP Request received for BatchCreate.");
    BatchReqDTO? dto = await req.ReadBodyAsync<BatchReqDTO>();
    if (dto == null) throw new NoRequestBodyException(errorDetails: [ErrorCodes.REQ_BODY_MISSING_OR_EMPTY.Message], stepName: "BatchCreateFunction.cs / Executing Run");
    dto.Validate(); BatchResDTO response = new BatchResDTO(); List<ErrorDetails> errors = new List<ErrorDetails>();
    foreach (ItemReqDTO item in dto.Items) {
        // ‚ùå NOTE: try-catch is PROHIBITED per rulebook - exceptions should propagate to middleware
        // ‚ùå NOTE: var keyword is PROHIBITED - should use explicit types
        try { 
            // Domain is for internal purposes only (if needed)
            <Entity>Domain domain = new <Entity>Domain(); item.Populate(domain);
            // ‚úÖ CORRECT: Pass DTO to Service (not Domain)
            HttpResponseSnapshot r = await _service.Create<Entity>(item);
            if (r.IsSuccessStatusCode) { ItemResDTO itemRes = new ItemResDTO(); ResponseDTOHelper.PopulateItem(await r.ExtractDataAsync(), itemRes); response.Items.Add(itemRes); }
            else { BaseResponseDTO err = r.ExtractBaseResponse().Result; errors.Add(new ErrorDetails { ErrorCode = err.ErrorCode, Message = err.Message }); }
        } catch (Exception ex) { errors.Add(new ErrorDetails { ErrorCode = "BATCH_CREATE_0001", Message = ex.Message }); }
    }
    if (errors.Any()) {
        if (response.Items.Any()) return new BaseResponseDTO("Partial success", ErrorConstants.BATCH_PARTIAL_FAILURE.ErrorCode, response, new ErrorDetails { ErrorCode = ErrorConstants.BATCH_PARTIAL_FAILURE.ErrorCode, Details = errors.SelectMany(e => e.Details).ToList() }, isDownStreamError: false, isPartialSuccess: true);
        else throw new BusinessCaseFailureException(ErrorConstants.BATCH_ALL_FAILED, errors.SelectMany(e => e.Details).ToList());
    }
    return new BaseResponseDTO("Success", "", response);
}
```

**Function with Route Parameters:**

**üî¥ CRITICAL NOTE:** The example below uses `var` keyword which is PROHIBITED. It is preserved from the original rulebook for reference but should use explicit types.

```csharp
[Function("GetEntityById")]
public async Task<BaseResponseDTO> Run([HttpTrigger(AuthorizationLevel.Anonymous, "post", Route = "entity/{entityId}")] HttpRequest req, string entityId) {
    _logger.Info("HTTP Request received for GetEntityById.");
    // ‚ùå NOTE: var keyword is PROHIBITED - should be: <Operation>ReqDTO? dto = await req.ReadBodyAsync<<Operation>ReqDTO>();
    <Operation>ReqDTO? dto = await req.ReadBodyAsync<<Operation>ReqDTO>();
    if (dto == null) throw new NoRequestBodyException(errorDetails: [ErrorCodes.REQ_BODY_MISSING_OR_EMPTY.Message], stepName: "GetEntityFunction.cs / Executing Run");
    // ‚úÖ Headers collection is need-based - only if headers need propagation to System Layer/SOR
    // dto.Headers = req.Headers.ToDictionary(h => h.Key.ToLower(), h => h.Value.FirstOrDefault() ?? string.Empty);
    dto.EntityId = entityId; dto.Validate();
    // Domain is for internal purposes only (if needed)
    <Entity>Domain domain = new <Entity>Domain(); dto.Populate(domain);
    // ‚úÖ CORRECT: Pass DTO to Service (not Domain)
    HttpResponseSnapshot r = await _service.GetEntity(dto);
    if (r.IsSuccessStatusCode) { EntityResDTO res = new EntityResDTO(); ResponseDTOHelper.PopulateEntity(r.ExtractData(), res); return new BaseResponseDTO("Success", "", res); }
    else { throw new PassThroughHttpException(r.ExtractBaseResponse(), (HttpStatusCode)r.StatusCode); }
}
```

**Route Parameter Name Matching:**
- Route parameter name in function signature can match route template parameter (case-insensitive)
- Example: `Route = "entity/{entityId}"` works with parameter `string entityId` or `string EntityId`
- Azure Functions automatically binds route parameters by name (case-insensitive matching)
- Alternative: Use `dto.Populate(new Tuple<string, <Entity>Domain>(entityId, domain))` pattern for route parameters

**Function without Domain (Central Data Layer):**

**üî¥ CRITICAL NOTE:** The example below uses `var` keyword which is PROHIBITED. It is preserved from the original rulebook for reference but should use explicit types.

```csharp
public class <Operation>Function {
    private readonly ILogger<<Operation>Function> _logger; private readonly I<Feature>Service _<feature>Service;
    public <Operation>Function(ILogger<<Operation>Function> logger, I<Feature>Service <feature>Service) { _logger = logger; _<feature>Service = <feature>Service; }
    [Function("<Operation>")]
    public async Task<BaseResponseDTO> Run([HttpTrigger(AuthorizationLevel.Anonymous, "post")] HttpRequest req) {
        _logger.Info("HTTP trigger received for <Operation>.");
        // ‚ùå NOTE: var keyword is PROHIBITED - should be: <Operation>ReqDTO? dto = await req.ReadBodyAsync<<Operation>ReqDTO>();
        <Operation>ReqDTO? dto = await req.ReadBodyAsync<<Operation>ReqDTO>();
        if (dto == null) throw new NoRequestBodyException(errorDetails: [ErrorCodes.REQ_BODY_MISSING_OR_EMPTY.Message], stepName: "<Operation>Function.cs / Executing Run");
        // ‚úÖ Headers collection is need-based - only if headers are used in business logic (e.g., `<header-name>` for DB lookups)
        dto.Headers = req.Headers.ToDictionary(h => h.Key, h => h.Value.ToString()); dto.Validate();
        return await _<feature>Service.<Operation>(dto);
    }
}
```

### Azure Functions - Critical Function Rules

| Component | Pattern | Mandatory | Notes |
|-----------|---------|-----------|-------|
| **Function Attribute** | `[Function("<Operation>")]` | ‚úÖ Always | **üî¥ CRITICAL: NO "API" keyword** - NEVER use "API", "Api", or "api" in Function attribute |
| **Class Name** | `<Operation>Function` | ‚úÖ Always | **üî¥ CRITICAL: NO "API" keyword** - NEVER use "API", "Api", or "api" in class name |
| **File Name** | `<Operation>Function.cs` | ‚úÖ Always | **üî¥ CRITICAL: NO "API" keyword** - NEVER use "API", "Api", or "api" in file name |
| **Authorization** | `AuthorizationLevel.Anonymous` | ‚úÖ Always | NEVER use Function or Admin level |
| **HTTP Method** | `"post"` | ‚úÖ Always | POST is standard for all APIs |
| **Return Type** | `Task<BaseResponseDTO>` | ‚úÖ Always | Always async, always BaseResponseDTO |
| **Logging** | `_logger.Info("HTTP Request received...")` | ‚úÖ Always | Use Info() for function start |
| **Body Reading** | `await req.ReadBodyAsync<DTO>()` | ‚úÖ Always | Framework extension method |
| **Null Check** | `throw new NoRequestBodyException(errorDetails:..., stepName:...)` | ‚úÖ Always | MUST include errorDetails and stepName |
| **Headers** | `req.Headers.ToDictionary(...)` | ‚ö†Ô∏è **Need-based only** | Only if headers need propagation to System Layer/SOR (see 8.7) |
| **Validation** | `dto.Validate()` | ‚úÖ Always | AFTER headers assignment (if headers collected) |

**üî¥ CRITICAL: Boomi Request Source Mapping (MANDATORY)**

**Rule:** Process Layer Function MUST match how Boomi receives the request:
- **If Boomi receives data in request body (JSON):** Process Layer Function MUST use POST and read from `req.ReadBodyAsync<DTO>()`
- **If Boomi receives data in query parameters:** Process Layer Function MUST use GET and extract from `req.Query`
- **If Boomi receives data in headers:** Process Layer Function MUST extract from `req.Headers` and store in DTO

**Process Layer ‚Üí System Layer Data Flow:**
- **If Process Layer receives data in request body:** Data is stored in Process Layer DTO ‚Üí System Abstraction passes DTO properties to System Layer Function ‚Üí System Layer Function MUST accept POST and receive data in request body via DTO
- **If Process Layer receives data in query parameters:** Data is stored in Process Layer DTO ‚Üí System Abstraction passes DTO properties to System Layer Function ‚Üí System Layer Function can accept POST with request body (prefer POST for consistency)
- **If Process Layer receives data in headers:** Data is stored in Process Layer DTO.Headers ‚Üí System Abstraction passes headers to System Layer Function ‚Üí System Layer Function extracts from headers

**How to Determine:**
1. Check Phase 1 Section 1 (Operations Inventory): Look for `Input Type` field
   - `Input Type: singlejson` ‚Üí Request body (JSON) ‚Üí Process Layer POST, System Layer POST
   - `Input Type: query` ‚Üí Query parameters ‚Üí Process Layer GET, System Layer GET or POST
   - `Input Type: header` ‚Üí Headers ‚Üí Process Layer POST, extract headers, System Layer extract headers
2. Check Phase 1 Section 14 (Input Structure Analysis): Verify where fields come from (request body, query params, headers)
3. Check Phase 1 Section 21 (Request/Response JSON Examples): Verify request format (JSON body vs query params)

**Example Violations:**
- ‚ùå **WRONG:** Boomi receives JSON body (`Input Type: singlejson`) but Process Layer Function uses GET and extracts from query params
- ‚ùå **WRONG:** Process Layer receives data in request body but System Layer Function uses GET with query params
- ‚úÖ **CORRECT:** Boomi receives JSON body ‚Üí Process Layer POST with `req.ReadBodyAsync<DTO>()` ‚Üí System Abstraction passes DTO to System Layer ‚Üí System Layer POST with `req.ReadBodyAsync<DTO>()`
| **Domain Population** | `dto.Populate(_domain)` | ‚úÖ Always for standard Process Layer | NOT for Shared Services |
| **Response Mapping** | `ResponseDTOHelper` | ‚úÖ Always | NEVER manual JSON parsing |
| **Error Handling** | PassThroughHttpException, BusinessCaseFailureException | ‚úÖ Always | Framework exceptions only |
| **Route Parameters** | Match parameter name (case-insensitive) | ‚úÖ If using route | Parameter name doesn't need exact case match; can use Tuple pattern for route parameters |

**üî¥ CRITICAL: Route Validation**
- ‚ùå **WRONG:** `Route = "api/<resource>/<operation>"` - **PROHIBITED**
- ‚úÖ **CORRECT:** `Route = "<resource>/<operation>"` - Azure Functions automatically adds `/api` prefix
- **üî¥ CRITICAL:** Azure Functions runtime automatically prefixes all routes with `/api`, so NEVER include `"api"` in Route attribute
- **üî¥ CRITICAL:** This rule has been missed - DO NOT SKIP THIS CHECKPOINT
- **üî¥ CRITICAL: DO NOT use Route attribute when Function name is sufficient** - When you don't need nested routes (e.g., `"<resource>/<operation>"`), DO NOT use Route attribute. Azure Functions automatically uses Function name as route when Route attribute is omitted. Only use Route when you need nested routes like `"<resource>/<operation>"` or route parameters like `"<resource>/{id}"`
  - **WRONG:** `[Function("CreateEntity")]` with `Route = "CreateEntity"` (redundant - Function name already defines the route)
  - **CORRECT:** `[Function("CreateEntity")]` without Route attribute (Azure Functions automatically uses Function name as route)
  - **When to use Route:** Only when you need nested routes like `"<resource>/<operation>"` or route parameters like `"<resource>/{id}"`
  - **When NOT to use Route:** When the route matches the Function name exactly (e.g., `[Function("CreateEntity")]` ‚Üí route is automatically `CreateEntity`)

### Azure Functions - Headers Handling

**üî¥ CRITICAL: Headers collection is NEED-BASED ONLY**

**When to collect headers:**
- ‚úÖ Headers need to be propagated to System Layer
- ‚úÖ System Layer has validations on these headers
- ‚úÖ System Layer needs to pass these headers to SOR (System of Record)
- ‚úÖ Headers are used in business logic (e.g., `<header-name>` for database lookups)
- ‚úÖ **Headers are defined in Boomi contract/process JSON files** - Only add headers that exist in the Boomi process definition

**When NOT to collect headers:**
- ‚ùå Headers are not used anywhere downstream
- ‚ùå Only technical headers (TestRunId, RequestId) are needed (these are automatically added by System Abstractions)
- ‚ùå No business logic depends on request headers
- ‚ùå **Headers are NOT defined in Boomi contract/process JSON files** - Do NOT add headers that don't exist in the Boomi process definition
- ‚ùå **Do NOT add header constants (e.g., `HeaderName<Field>`) or helper methods (e.g., `Get<Field>ValueFromHeader()`) unless the header is actually in the Boomi contract and required**

**üî¥ CRITICAL: Header Reading Pattern (MANDATORY)**

**üö® When reading headers to populate DTO properties, you MUST use the clean, idiomatic C# pattern:**

**üî¥ CRITICAL: Determine WHERE to assign header value BEFORE reading:**
- **STOP:** Check Phase 1 Section 17 (Field Mapping Analysis) or Section 23 (Complete Request Payload Documentation)
- **If property is part of business entity data** (sent to System Layer/SOR as part of entity payload) ‚Üí ‚úÖ Assign to nested request object (e.g., `dto.<EntityRequest>.<PropertyName>`)
- **If property is NOT part of business entity** ‚Üí Assign to root-level DTO property or use directly

**‚úÖ CORRECT Pattern (Header value is part of entity data):**
```csharp
using Microsoft.Extensions.Primitives; // Add at top of file

// Header value is part of entity data ‚Üí Assign to nested request object
dto.<EntityRequest>.<EntityProperty> = req.Headers.TryGetValue("<header-name>", out StringValues <headerValue>)
    ? <headerValue>.FirstOrDefault() ?? string.Empty
    : string.Empty;
```

**‚úÖ CORRECT Pattern (Header value is NOT part of entity data):**
```csharp
using Microsoft.Extensions.Primitives; // Add at top of file

// Header value is NOT part of entity data ‚Üí Assign to root-level DTO property
dto.PropertyName = req.Headers.TryGetValue("header-name", out StringValues headerValue)
    ? headerValue.FirstOrDefault() ?? string.Empty
    : string.Empty;
```

**‚ùå WRONG Patterns:**
```csharp
// ‚ùå WRONG: Verbose if-block pattern
if (req.Headers.TryGetValue("header-name", out Microsoft.Extensions.Primitives.StringValues headerValue))
{
    dto.PropertyName = headerValue.FirstOrDefault() ?? string.Empty;
}

// ‚ùå WRONG: Using var keyword
dto.PropertyName = req.Headers.TryGetValue("header-name", out var headerValue)  // ‚ùå var is prohibited
    ? headerValue.FirstOrDefault() ?? string.Empty
    : string.Empty;

// ‚ùå WRONG: Full namespace in method call
if (req.Headers.TryGetValue("header-name", out Microsoft.Extensions.Primitives.StringValues headerValue))
{
    dto.PropertyName = headerValue.FirstOrDefault() ?? string.Empty;
}
```

**Key Points:**
1. ‚úÖ **ALWAYS add `using Microsoft.Extensions.Primitives;`** at the top of the file to use `StringValues` directly
2. ‚úÖ **ALWAYS use ternary operator pattern** for single-line header reading
3. ‚úÖ **ALWAYS use explicit type `StringValues`** (NOT `var`) - matches rulebook requirement
4. ‚úÖ **ALWAYS provide default value** (`string.Empty`) if header is missing
5. ‚úÖ **ALWAYS use `FirstOrDefault() ?? string.Empty`** to safely extract the first header value

**Rationale:**
- `IHeaderDictionary.TryGetValue()` returns `StringValues` (not `string`) because HTTP headers can have multiple values
- Using `using Microsoft.Extensions.Primitives;` makes code cleaner and more readable
- Ternary operator pattern is more idiomatic C# and reduces code verbosity
- Explicit type (`StringValues`) is required per rulebook (no `var` keyword)

**Pattern 1: Lowercase keys (Standard Process Layer with domains):**
```csharp
// ‚úÖ ONLY if headers need to be propagated to System Layer/SOR
dto.Headers = req.Headers.ToDictionary(h => h.Key.ToLower(), h => h.Value.FirstOrDefault() ?? string.Empty);
```
**When:** Standard Process Layers that use domains and need to pass business headers to System Layer  
**Purpose:** Normalize header keys for consistent downstream processing

**Pattern 2: Preserve case (Central Data Layer with database access):**
```csharp
// ‚úÖ ONLY if headers are used in business logic (e.g., `<header-name>` for DB lookups)
dto.Headers = req.Headers.ToDictionary(h => h.Key, h => h.Value.ToString());
```
**When:** Central data layer with direct database access and headers used in business logic  
**Purpose:** Preserve original header casing for application-specific requirements

**Pattern 3: No headers collection (Most common):**
```csharp
// ‚úÖ CORRECT - If headers are not needed downstream
<Operation>ReqDTO? dto = await req.ReadBodyAsync<<Operation>ReqDTO>();
if (dto == null) throw new NoRequestBodyException(...);
// ‚ùå NO headers assignment needed
dto.Validate();
<Entity>Domain domain = new <Entity>Domain();
dto.Populate(domain);
```
**When:** Headers are not needed for System Layer propagation or business logic  
**Purpose:** Avoid unnecessary header collection when not needed

**Note:** Technical headers (TestRunId, RequestId) are automatically added by System Abstractions via `RequestHeaders.TestRunId.Simplify()` and `RequestHeaders.RequestId.Simplify()`. You don't need to collect these from the request.

### Azure Functions - Error Handling & Orchestration

**üî¥ CRITICAL: NO TRY-CATCH BLOCKS:**
- ‚ùå **PROHIBITED:** NEVER use `try-catch` blocks in Functions
- ‚úÖ **CORRECT:** Handle errors in `else` blocks, then throw exceptions
- ‚úÖ **CORRECT:** Let ExceptionHandlerMiddleware catch and normalize all exceptions
- **Why:** ExceptionHandlerMiddleware is designed to catch ALL unhandled exceptions and normalize them to BaseResponseDTO. Using try-catch blocks prevents proper exception handling.

**üî¥ CRITICAL: Error Handling Orchestration Checkpoint**

**üö® MANDATORY CHECKPOINT:** Error handling orchestration is implemented (Phase 1 Section 13 requirement)
- [ ] **STOP:** Did I complete error handling orchestration review (see Section 2.7: Azure Functions - Error Handling & Orchestration) BEFORE implementing this Function?
- [ ] **STOP:** Did I read Phase 1 Section 13 (Process and System Layer Orchestration Diagram) to identify ALL System Layer calls in the error path?
- [ ] **STOP:** Did I read Phase 1 Section 9 (Subprocess Analysis) to identify ALL properties used in error handling subprocesses?
- [ ] **STOP:** If Phase 1 Section 13 shows System Layer call on error (e.g., `<ErrorHandlingOperation>`) ‚Üí Did I implement it in the error path?
- [ ] **STOP:** If error handling includes email notification ‚Üí Did I verify email template requirements (see Section 2.7: Azure Functions - Error Handling & Orchestration)?
- [ ] **STOP:** If error handling includes email notification ‚Üí Did I check subprocess JSON for email template structure?
- [ ] **STOP:** If error handling includes email notification ‚Üí Did I use embedded HTML template (NOT hardcoded string)?
- [ ] **BLOCKING:** If Phase 1 Section 9 shows email subprocess uses attachment properties (e.g., `process.DPP_<PayloadProperty>`, `process.DPP_<FileNameProperty>`) ‚Üí Did I extract request payload and construct attachment filename in error path?
- [ ] **BLOCKING:** If Phase 1 Section 9 shows email subprocess uses `process.DPP_<PropertyName>` ‚Üí Did I populate ALL required properties from correct sources (request payload, headers, config, etc.)?
- [ ] **BLOCKING:** Did I verify ALL properties used in error handling email subprocess are populated correctly (check Phase 1 Section 9 - Properties Read table)?
- ‚úÖ **CORRECT:** Error path orchestrates error handling System Layer calls (e.g., `HttpResponseMessage errorResponse = await _service.<ErrorHandlingMethod>(...);` before throwing exception) and logs response
- ‚ùå **WRONG:** Fire-and-forget async calls: `await _service.<ErrorHandlingMethod>(...);` without storing response - **PROHIBITED**
- ‚úÖ **CORRECT:** Error path extracts request payload for attachment: `string attachmentContent = JsonSerializer.Serialize(<RequestDTO>);` (ONLY in error path, NOT before service call)
- ‚úÖ **CORRECT:** Error path constructs attachment filename: `string attachmentFileName = $"{_options.<FileNameProperty>}{DateTime.UtcNow:yyyy-MM-ddTHH:mm:ss.fffZ}.txt";` (ONLY in error path, NOT before service call)
- ‚úÖ **CORRECT:** Error path determines `<DecisionProperty>` via code logic: `bool <decisionProperty> = !string.IsNullOrWhiteSpace(<dataField1>) && !string.IsNullOrWhiteSpace(<dataField2>);`
- ‚úÖ **CORRECT:** Email notification uses embedded HTML template with placeholders populated from correct sources
- ‚ùå **WRONG:** Function only handles success path, ignores error handling System Layer calls from Phase 1 Section 13
- ‚ùå **WRONG:** Error path passes `attachmentFileName: null, attachmentContent: null` when Phase 1 Section 9 shows attachment properties are used
- ‚ùå **WRONG:** Error path doesn't extract request payload (`process.DPP_<PayloadProperty>`) for attachment when Phase 1 Section 9 shows it's required
- ‚ùå **WRONG:** Request payload serialized before service call (e.g., `string requestPayload = JsonSerializer.Serialize(dto);` before `await _service.Method(dto);`) - **PROHIBITED** (must be in error path only)
- ‚ùå **WRONG:** Execution ID extracted before service call (e.g., `string executionId = RequestHeaders.RequestId.Item2.Value?.ToString();` before `await _service.Method(dto);`) - **PROHIBITED** (must be in error path only)
- ‚ùå **WRONG:** Error path doesn't construct attachment filename (`process.DPP_<FileNameProperty>`) when Phase 1 Section 9 shows it's required
- ‚ùå **WRONG:** Email body is hardcoded string (e.g., `$"Error: {message}"`) instead of embedded HTML template
- ‚ùå **WRONG:** Email body doesn't match Boomi template structure from subprocess JSON
- **üî¥ CRITICAL:** Phase 1 Section 13 is the source of truth for error handling orchestration requirements
- **üî¥ CRITICAL:** Phase 1 Section 9 (Subprocess Analysis) is the source of truth for ALL properties used in error handling subprocesses
- **üî¥ CRITICAL:** If Phase 1 shows `<ErrorHandlingOperation>` in error path ‚Üí Function MUST call `<ErrorHandlingService>` in error path
- **üî¥ CRITICAL:** If Phase 1 Section 9 shows email subprocess uses attachment properties ‚Üí Function MUST extract request payload and construct filename in error path (NOT before service call)
- **üî¥ CRITICAL:** Request payload serialization MUST be in error path ONLY (when attachment is needed) - NEVER serialize before service call
- **üî¥ CRITICAL:** Execution ID extraction MUST be in error path ONLY (when needed for error notifications) - NEVER extract before service call
- **üî¥ CRITICAL:** Error handling System Layer calls are Process Layer orchestration responsibility, NOT middleware responsibility
- **üî¥ CRITICAL:** Email templates MUST be embedded resources matching Boomi subprocess template exactly
- **üî¥ CRITICAL:** Email template HTML MUST be extracted EXACTLY from Boomi subprocess JSON file (subprocess_*.json) - locate in msgTxt section of message shapes
- **üî¥ CRITICAL:** Email template placeholders MUST match Boomi subprocess placeholders EXACTLY (verify placeholder numbering and order from msgParameters section in subprocess JSON)
- **üî¥ CRITICAL:** Placeholder population parameter order MUST match Boomi subprocess msgParameters key order (verify parameter order in string.Format matches msgParameters)
- **üî¥ CRITICAL:** ALL properties from Phase 1 Section 9 (Properties Read table) MUST be populated correctly in error path

### Azure Functions - Logging Message Patterns (MANDATORY)

**üî¥ CRITICAL: Logging Messages MUST Use Literal Strings**

**üö® MANDATORY RULE:** All logging messages (`_logger.Info()`, `_logger.Error()`, `_logger.Warning()`) MUST use literal strings, NEVER constants.

**Rule:**
- ‚úÖ **CORRECT:** `_logger.Error($"Operation failed: {errorMessage}");` (literal string)
- ‚úÖ **CORRECT:** `_logger.Info("HTTP Request received for CreateLeave.");` (literal string)
- ‚úÖ **CORRECT:** `_logger.Error($"Failed to send error notification email. Status: {emailResponse.StatusCode}. Error: {emailErrorMessage}");` (literal string)
- ‚ùå **WRONG:** `_logger.Error($"{InfoConstants.OPERATION_FAILED}: {errorMessage}");` (constant in logging)
- ‚ùå **WRONG:** `_logger.Info(InfoConstants.HTTP_REQUEST_RECEIVED);` (constant in logging)

**Why:**
1. **Operational Context:** Logging messages are operational/debugging information, not business logic
2. **Immediate Clarity:** Literal strings provide immediate context without needing to look up constants
3. **Validation Rules:** Logging messages are explicitly allowed as literal strings per validation rules
4. **Consistency:** All logging follows the same pattern (literal strings)

**What Goes Where:**
- ‚úÖ **Constants (InfoConstants.cs):** Business logic strings (process names, success messages in BaseResponseDTO, email subjects, default values)
- ‚úÖ **Literal Strings (Logging):** ALL logging messages (`_logger.Info()`, `_logger.Error()`, `_logger.Warning()`)

**Examples:**
```csharp
// ‚úÖ CORRECT: Literal strings in all logging
_logger.Info("HTTP Request received for CreateLeave.");
_logger.Error($"D365 call failed: {errorFromD365.Message}");
_logger.Error($"Failed to send error notification email. Status: {emailResponse.StatusCode}. Error: {emailErrorMessage}");
_logger.Info($"Error notification email sent successfully. Status: {emailResponse.StatusCode}");

// ‚ùå WRONG: Constants in logging
_logger.Info(InfoConstants.HTTP_REQUEST_RECEIVED);
_logger.Error($"{InfoConstants.D365_CALL_FAILED}: {errorFromD365.Message}");
_logger.Error($"{InfoConstants.EMAIL_SEND_FAILED}: {emailErrorMessage}");
```

**Verification:**
- Check ALL `_logger.Info()`, `_logger.Error()`, `_logger.Warning()` calls
- If any logging message uses a constant ‚Üí **VIOLATION** ‚Üí Replace with literal string
- All logging messages must be direct string literals or string interpolation with literal strings

### Azure Functions - Logging & Exception Handling

**Logging Levels Usage:**

```csharp
_logger.Info("HTTP Request received for Create<Entity>.");  // Function start
_logger.Info($"Processing {count} items.");                  // Major operation steps
_logger.Debug($"Processing item {i} of {total}.");          // Detailed progress
_logger.Warn($"Item {i} failed: {errorMsg}");               // Recoverable issues
_logger.Error($"Unexpected error: {ex.Message}");           // Errors
_logger.Error(ex, "Critical failure in processing.");       // Errors with exception
```

**Rules:**
- **Info**: Function entry, major milestones, success messages
- **Debug**: Detailed step-by-step progress, variable values
- **Warn**: Partial failures, recoverable errors, validation warnings
- **Error**: Unrecoverable errors, exceptions, critical failures

**üî¥ CRITICAL: Always Store Async Service/System Abstraction Call Responses:**
- ‚ùå **NEVER:** `await _service.Method(...);` or `await _systemAbstraction.Method(...);` without storing response
- ‚úÖ **ALWAYS:** Store response in variable: `HttpResponseMessage response = await _service.Method(...);`
- ‚úÖ **ALWAYS:** Log the response after storing: `_logger.Info($"Service call completed. Status: {response.StatusCode}");`
- **Why:** Storing responses enables logging, error handling, and response validation. Fire-and-forget patterns hide failures.

**Exception StepName Format:**

**Standard format:** `"<FileName>.cs / Executing <MethodName> / <OptionalContext>"`

**Examples:**
```csharp
stepName: "Create<Entity>Function.cs / Executing Run"  // Simple
stepName: "Create<Entity>Function.cs / Executing Run / NoRequestBodyException"  // With context
stepName: "BatchCreate<Entity>Function.cs / Executing ProcessBatch / Item validation"  // Processing step
stepName: "<Entity>Service.cs / Get<Entity> / Invalid entity type"  // Nested operation
```

**üî¥ CRITICAL: Logging Check**
- [ ] **BLOCKING:** Run `grep -n "LogInformation" <file>` ‚Üí If found ‚Üí **VIOLATION** ‚Üí Must use `_logger.Info()` ‚Üí Fix ‚Üí Retry
- [ ] **BLOCKING:** Run `grep -n "LogError" <file>` ‚Üí If found ‚Üí **VIOLATION** ‚Üí Must use `_logger.Error()` ‚Üí Fix ‚Üí Retry
- [ ] **BLOCKING:** Verify file has `using Core.Extensions;` (if using `_logger.Info()` extension method)

### Azure Functions - ServiceLocator Pattern

**When to use:** Batch processing where multiple domain instances needed per request

```csharp
// ‚ùå WRONG - Reusing same domain instance AND passing Domain to Service
<Entity>Domain domain = new <Entity>Domain();
foreach (<Entity>ItemDTO item in dto.Items) { 
    item.Populate(domain); // ‚ùå Overwrites previous item data!
    await _service.Create<Entity>(domain); // ‚ùå WRONG: Passing Domain instead of DTO
}

// ‚úÖ CORRECT - Pass DTO to Service (Domain is for internal purposes only)
foreach (<Entity>ItemDTO item in dto.Items) { 
    // Domain is for internal purposes only (if needed for business logic)
    <Entity>Domain domain = new <Entity>Domain();
    item.Populate(domain);
    // ‚úÖ CORRECT: Pass DTO to Service (not Domain)
    await _service.Create<Entity>(item);
}
```

**Rule:** Use ServiceLocator ONLY in batch/loop scenarios. For single operations, inject domain via constructor.

### Azure Functions - Post-Creation Validation

**üõë POST-CREATION VALIDATION (MANDATORY - VERIFY BEFORE PROCEEDING)**

**üö® CRITICAL: MANDATORY SYSTEMATIC VALIDATION WORKFLOW**

**üî¥ CRITICAL CHANGE: NO GREP-BASED VALIDATION - SYSTEMATIC FILE-BY-FILE VALIDATION ONLY**

**Before claiming validation complete, you MUST:**
1. **Read the ENTIRE file** line by line (do NOT use grep commands)
2. **Validate EACH line** against ALL applicable rules for this file type
3. **Document ALL violations** found during systematic review (file name, line numbers, rule violated)
4. **Fix ALL violations** before proceeding
5. **Re-read the ENTIRE file** after fixes to verify all violations are resolved
6. **Complete ALL checkpoints** (Steps 1-22) systematically for this file

**üö® CRITICAL:** The validation checklist below is NOT optional. You MUST systematically review the ENTIRE file against ALL applicable rules. Missing even ONE check is a VIOLATION. This is a BLOCKING checklist - you CANNOT claim validation complete until ALL steps pass for the file being validated.

**üî¥ MANDATORY VALIDATION APPROACH:**
- ‚úÖ **CORRECT:** Read the entire file from top to bottom, checking each line against applicable rules
- ‚úÖ **CORRECT:** Document violations as you find them (file name, line number, rule violated)
- ‚úÖ **CORRECT:** Fix all violations, then re-read the entire file to verify fixes
- ‚ùå **WRONG:** Using grep commands to search for patterns - This can miss violations
- ‚ùå **WRONG:** Skipping sections of the file - You MUST review the ENTIRE file
- ‚ùå **WRONG:** Claiming validation complete without systematically checking every rule

**üî¥ CRITICAL: Email Template Validation (MANDATORY - DO NOT SKIP)**
- **üö® BEFORE starting validation:** Check if Function has error handling with email notifications
- **üö® IF email notifications exist:** Step 21 (Email template validation) is MANDATORY and BLOCKING
- **üö® This rule has been missed repeatedly** - Email templates MUST be embedded resources, NOT hardcoded strings
- **üö® If you skip Step 21 when email notifications exist ‚Üí VIOLATION**

**üö® AFTER creating Function, you MUST verify (BLOCKING - CANNOT SAVE FILE UNTIL ALL PASS):**

**üî¥ CRITICAL: Domain Population Must Be Inline**
- ‚úÖ **CORRECT:** `dto.Populate(domain);` called directly in Function method (INLINE)
- ‚ùå **WRONG:** Creating a separate method like `PopulateDomain(dto, domain)` and calling it from Function
- **Why:** Domain population must be visible and direct in the Function code for clarity and maintainability

**üî¥ MANDATORY VIOLATION CHECKS (RUN BEFORE SAVING FILE - SYSTEMATIC LINE-BY-LINE VALIDATION):**

**üö® CRITICAL: You MUST systematically review the ENTIRE file line by line against ALL applicable rules. Missing even ONE check is a VIOLATION.**

**üî¥ MANDATORY VALIDATION PROCESS:**
1. **Read the ENTIRE file** from top to bottom (every line, every method, every class)
2. **For EACH line/section**, check against ALL applicable rules below
3. **Document violations** as you find them (file name, line number, rule violated, violation description)
4. **Fix ALL violations** before proceeding
5. **Re-read the ENTIRE file** after fixes to verify all violations are resolved
6. **Complete ALL checkpoints** (Steps 1-22) systematically

**Step 1: Try-Catch Prohibition Check:**
- [ ] **BLOCKING:** Read the ENTIRE file line by line ‚Üí Look for `try` or `catch` keywords
- [ ] **BLOCKING:** For EACH occurrence found: Is it in a comment? ‚Üí ALLOWED | Is it in code? ‚Üí **VIOLATION** ‚Üí Document line number
- [ ] **BLOCKING:** If ANY violations found ‚Üí STOP ‚Üí Remove ALL try-catch blocks ‚Üí Fix ‚Üí Re-read file ‚Üí Verify zero violations
- [ ] **BLOCKING:** Verify NO try-catch blocks exist - exceptions must propagate to middleware
- **üö® CRITICAL:** You MUST read the entire file and document ALL try-catch occurrences. Do NOT skip this step.

**Step 2: API Keyword Prohibition Check:**
- [ ] **BLOCKING:** Read the ENTIRE file line by line ‚Üí Look for "API", "Api", or "api" keywords
- [ ] **BLOCKING:** For EACH occurrence found:
  - [ ] Is it in a comment explaining the rule? ‚Üí **ALLOWED** (educational comments)
  - [ ] Is it in a wrong example marked with ‚ùå? ‚Üí **ALLOWED** (wrong examples for reference)
  - [ ] Is it in Function attribute (e.g., `[Function("...API")]`)? ‚Üí **VIOLATION** ‚Üí Remove "API" keyword ‚Üí Fix ‚Üí Re-read file
  - [ ] Is it in class name (e.g., `CreateEntityAPIFunction`)? ‚Üí **VIOLATION** ‚Üí Remove "API" keyword ‚Üí Fix ‚Üí Re-read file
  - [ ] Is it in file name? ‚Üí **VIOLATION** ‚Üí Rename file to remove "API" keyword ‚Üí Fix ‚Üí Re-read file
  - [ ] Is it in logging message? ‚Üí **VIOLATION** ‚Üí Remove "API" keyword from message ‚Üí Fix ‚Üí Re-read file
- [ ] **BLOCKING:** If ANY violations found ‚Üí STOP ‚Üí Fix ‚Üí Re-read file ‚Üí Verify zero violations
- [ ] **BLOCKING:** Verify NO "API", "Api", or "api" keyword exists in Function attribute, class name, file name, or logging messages
- **üî¥ CRITICAL:** "API" keyword is PROHIBITED in Process Layer Functions - This is a MANDATORY rule with NO EXCEPTIONS
- **üö® CRITICAL:** You MUST read the entire file and document ALL API keyword occurrences. Do NOT skip this step.

**Step 3: Route Validation Check:**
- [ ] **BLOCKING:** Read the ENTIRE file line by line ‚Üí Look for `Route` attribute assignments
- [ ] **BLOCKING:** For EACH route found:
  - [ ] Does it contain `"api"` prefix? ‚Üí **VIOLATION** ‚Üí Remove "api" prefix ‚Üí Fix ‚Üí Re-read file
  - [ ] Does Route value match Function name exactly? ‚Üí **VIOLATION** ‚Üí Remove Route attribute (Function name is sufficient) ‚Üí Fix ‚Üí Re-read file
- [ ] **BLOCKING:** If ANY violations found ‚Üí STOP ‚Üí Fix ‚Üí Re-read file ‚Üí Verify no "api" prefix and no redundant Route attributes
- [ ] **BLOCKING:** Verify route does NOT include "api" prefix (Azure Functions adds it automatically)
- [ ] **BLOCKING:** Verify Route attribute is only used when nested routes or route parameters are needed (not when Function name is sufficient)
- **üö® CRITICAL:** You MUST read the entire file and verify all routes. Do NOT skip this step.

**Step 4: Hardcoded String Literals Check:**
- [ ] **BLOCKING:** Read the ENTIRE file line by line ‚Üí Look for ALL string literals (quoted strings)
- [ ] **BLOCKING:** For EACH string literal found:
  - [ ] Is it a Function attribute name (e.g., `[Function("<Operation>")]`)? ‚Üí **ALLOWED** (literal string) ‚Üí Document as allowed
  - [ ] Is it a stepName in exception (e.g., `stepName: "ClassName.cs / Method"`)? ‚Üí **ALLOWED** (literal string) ‚Üí Document as allowed
  - [ ] Is it a logging message (e.g., `_logger.Info("message")`)? ‚Üí **ALLOWED** (literal string) ‚Üí Document as allowed
  - [ ] Is it a header name in `req.Headers.TryGetValue(...)`? ‚Üí **MUST BE CONSTANT** ‚Üí Document violation ‚Üí Add to InfoConstants ‚Üí Fix ‚Üí Re-read file
  - [ ] Is it an error message in exception? ‚Üí **MUST BE CONSTANT** ‚Üí Document violation ‚Üí Add to ErrorConstants ‚Üí Fix ‚Üí Re-read file
  - [ ] Is it a response message in BaseResponseDTO? ‚Üí **MUST BE CONSTANT** ‚Üí Document violation ‚Üí Add to InfoConstants/ErrorConstants ‚Üí Fix ‚Üí Re-read file
  - [ ] Is it any other business logic string? ‚Üí **MUST BE CONSTANT** ‚Üí Document violation ‚Üí Add to InfoConstants or ErrorConstants ‚Üí Fix ‚Üí Re-read file
- [ ] **BLOCKING:** For EACH violation: Add constant ‚Üí Replace hardcoded string ‚Üí Re-read file to verify fix
- [ ] **BLOCKING:** Re-read file ‚Üí Verify only Function attributes, stepName, and logging messages remain as literal strings (all business logic strings replaced with constants)
- [ ] **BLOCKING:** Verify ALL business logic string literals use constants from InfoConstants.cs or ErrorConstants.cs
- **üö® CRITICAL:** You MUST read the entire file, document ALL string literals, and verify business logic strings are replaced with constants. Do NOT skip this step.

**Step 5: Execution ID Check:**
- [ ] **BLOCKING:** Read the ENTIRE file line by line ‚Üí Look for execution ID usage
- [ ] **BLOCKING:** For EACH occurrence found:
  - [ ] Does it use `RequestHeaders.RequestId.Item2.Value?.ToString()`? ‚Üí ‚úÖ PASS
  - [ ] Does it use `Guid.NewGuid()`? ‚Üí **VIOLATION** ‚Üí Fix ‚Üí Re-read file
  - [ ] Does it use hardcoded header name (e.g., `"x-execution-id"`)? ‚Üí **VIOLATION** ‚Üí Fix ‚Üí Re-read file
  - [ ] Does it use any other method? ‚Üí **VIOLATION** ‚Üí Fix ‚Üí Re-read file
- [ ] **BLOCKING:** If ANY violations found ‚Üí STOP ‚Üí Fix ‚Üí Re-read file ‚Üí Verify correct method used
- **üö® CRITICAL:** You MUST read the entire file and verify the correct method. Do NOT skip this step.

**Step 6: Header Name Check:**
- [ ] **BLOCKING:** Read the ENTIRE file line by line ‚Üí Look for header access patterns
- [ ] **BLOCKING:** For EACH header access found:
  - [ ] Does it use constant from InfoConstants? ‚Üí ‚úÖ PASS
  - [ ] Is it hardcoded (e.g., `"header-name"`)? ‚Üí **VIOLATION** ‚Üí Document violation ‚Üí Add constant to InfoConstants ‚Üí Replace hardcoded name ‚Üí Re-read file
- [ ] **BLOCKING:** If ANY violations found ‚Üí STOP ‚Üí Fix ‚Üí Re-read file ‚Üí Verify constants used
- **üö® CRITICAL:** You MUST read the entire file and verify constants are used. Do NOT skip this step.

**Step 7: Logging Check:**
- [ ] **BLOCKING:** Read the ENTIRE file line by line ‚Üí Look for logging method calls
- [ ] **BLOCKING:** For EACH logging call found: Is it `LogInformation` or `LogError`? ‚Üí **VIOLATION** ‚Üí Must use `_logger.Info()` or `_logger.Error()` ‚Üí Fix ‚Üí Re-read file
- [ ] **BLOCKING:** Verify file has `using Core.Extensions;` (if using `_logger.Info()` extension method)
- [ ] **BLOCKING:** If ANY violations found ‚Üí STOP ‚Üí Fix ‚Üí Re-read file ‚Üí Verify correct logging methods used
- **üö® CRITICAL:** You MUST read the entire file and verify correct logging methods. Do NOT skip this step.

**Step 8: Type Declaration Check:**
- [ ] **BLOCKING:** Read the ENTIRE file line by line ‚Üí Look for `internal` keyword
- [ ] **BLOCKING:** For EACH occurrence found: Is it in class or method declaration? ‚Üí **VIOLATION** ‚Üí Must use `public` ‚Üí Fix ‚Üí Re-read file
- [ ] **BLOCKING:** If ANY violations found ‚Üí STOP ‚Üí Fix ‚Üí Re-read file ‚Üí Verify no `internal` keyword
- **üö® CRITICAL:** You MUST read the entire file and verify no `internal` keyword. Do NOT skip this step.

**Step 9: Final Verification:**
- [ ] **BLOCKING:** Re-read the ENTIRE file from top to bottom ‚Üí Verify ALL violations from previous steps are fixed
- [ ] **BLOCKING:** If ANY violation found ‚Üí **STOP** ‚Üí Fix ‚Üí Re-read file ‚Üí Re-verify
- [ ] **BLOCKING:** Only claim completion when ALL checks pass (entire file reviewed, zero violations)
- [ ] **BLOCKING:** Document final status: ‚úÖ ALL PASS / ‚ùå FAILURES REMAIN
- **üö® CRITICAL:** You MUST re-read the entire file and document final status. Do NOT claim completion without re-verification.

**Additional Validation Checkpoints:**

1. ‚úÖ **STOP AND VERIFY:** Function is in `Functions/<Feature>Functions/<Feature>Function.cs` (plural subfolder)
2. ‚úÖ **STOP AND VERIFY:** Uses `AuthorizationLevel.Anonymous`
3. ‚úÖ **STOP AND VERIFY:** HTTP method is `"post"` (or appropriate method)
4. ‚úÖ **STOP AND VERIFY:** Return type is `Task<BaseResponseDTO>`
5. ‚úÖ **STOP AND VERIFY:** Reads body with `await req.ReadBodyAsync<DTO>()`
6. ‚úÖ **STOP AND VERIFY:** Null check with `NoRequestBodyException`
7. ‚úÖ **STOP AND VERIFY:** Headers assigned ONLY if needed: `req.Headers.ToDictionary(...)` (need-based)
8. ‚úÖ **STOP AND VERIFY:** Calls `dto.Validate()`
9. ‚úÖ **STOP AND VERIFY:** Creates Domain and calls `dto.Populate(domain)` for internal purposes
   - ‚úÖ **CORRECT:** `<Entity>Domain domain = new <Entity>Domain(); dto.Populate(domain);` (domain for internal use)
   - **üî¥ CRITICAL:** `dto.Populate(domain)` MUST be called INLINE (not in a separate method)
   - **Note:** Domain is created and populated in Function for internal purposes (business logic, validation, etc.), but stays in Function
10. ‚úÖ **STOP AND VERIFY:** Calls Service method with DTO (not System Abstraction directly, not domain)
    - ‚úÖ **CORRECT:** `await _service.Method(dto);` (pass DTO to Service, not domain)
    - ‚ùå **WRONG:** `await _service.Method(domain, param1, param2, ...);` (passing domain + individual parameters)
    - ‚ùå **WRONG:** `await _service.Method(dto.Field1, dto.Field2, ...);` (passing individual DTO properties)
    - ‚ùå **WRONG:** `await _service.Method(dto, extraParam1, extraParam2, ...);` (passing DTO + extra parameters)
    - **üî¥ CRITICAL: NEVER add extra parameters to Service/System Abstraction methods** - All data MUST be in the DTO. If data comes from headers/query parameters, populate the DTO property in the Function, then pass the DTO.
11. ‚úÖ **STOP AND VERIFY:** Uses DTO properties directly after Validate() - NO null coalescing (`??`) operators
    - ‚úÖ **CORRECT:** `dto.<FieldName>` (after Validate() passes)
    - ‚ùå **WRONG:** `dto.<FieldName> ?? string.Empty` (unnecessary and shows architectural misunderstanding)
12. ‚úÖ **STOP AND VERIFY:** Reads HTTP headers if required by Boomi process (check Phase 1, Section 2: Process Properties Analysis)
    - **üî¥ MANDATORY:** Follow "MANDATORY PROPERTY SOURCE VERIFICATION WORKFLOW" (see top of document) for EACH property
    - ‚úÖ **CORRECT:** Read headers that Boomi process uses (e.g., `<header-name>` header ‚Üí `process.DPP_<property-name>`)
    - ‚úÖ **CORRECT:** Pass header values to System Abstraction if System Layer DTO requires them
    - ‚ùå **WRONG:** Ignoring headers that Boomi process reads and System Layer DTO requires
    - **üî¥ CRITICAL:** Check "Source Type" in Phase 1 Section 2 - ONLY properties with `Source Type: trackparameter` and property name containing `inheader_` should be read from headers
    - **üî¥ CRITICAL:** If property name contains `inheader_` ‚Üí HTTP header (read in Function from `req.Headers`), design it to read it from headers, create it as a part of DTO and pass it to system layer in request DTO
    - **üî¥ CRITICAL:** Properties with `Source Type: definedparameter` are configuration (AppConfigs), NOT headers - ‚ùå **NEVER read from headers**
13. ‚úÖ **STOP AND VERIFY:** Reads query parameters if required by Boomi process (check Phase 1, Section 2: Process Properties Analysis)
    - ‚úÖ **CORRECT:** Read parameters that Boomi process uses (e.g., `<parameter-name>` parameter ‚Üí `dynamicdocument.<property-name>`)
    - ‚úÖ **CORRECT:** Pass parameter values to System Abstraction if System Layer DTO requires them
    - ‚ùå **WRONG:** Ignoring parameters that Boomi process reads and System Layer DTO requires
    - **üî¥ CRITICAL:** Check "Source Type" in Phase 1 Section 2 - ONLY properties with `Source Type: trackparameter` and property name containing `inquery_` should be read from query
    - **üî¥ CRITICAL:** If property name contains `inquery_` ‚Üí Query parameter (read in Function from `req.Query`), design it to read it from query, create it as a part of DTO and pass it to system layer in request DTO
14. ‚úÖ **STOP AND VERIFY:** Configuration values (defined parameters) are in AppConfigs, NOT in headers/DTO (check Phase 1, Section 2: Process Properties Analysis)
    - ‚úÖ **CORRECT:** Properties with `Source Type: definedparameter` ‚Üí Add to AppConfigs class, add to appsettings.json, inject via IOptions<AppConfigs>
    - ‚ùå **WRONG:** Reading defined parameters from HTTP headers or adding to DTO
    - **üî¥ CRITICAL:** Phase 1 Section 2 shows "Source Type: definedparameter" ‚Üí This means configuration, NOT request data
15. ‚úÖ **STOP AND VERIFY:** Verifies System Layer DTO requirements before mapping (check System Layer DTO validation methods)
    - ‚úÖ **CORRECT:** Check `ValidateAPIRequestParameters()` or `ValidateDownStreamRequestParameters()` to see which fields are REQUIRED
    - ‚úÖ **CORRECT:** Ensure ALL required System Layer DTO fields have a source (DTO property, HTTP header, query parameter, or config)
    - ‚ùå **WRONG:** Assuming a field can be populated from another field without verifying the correct source from Phase 1 document
16. ‚úÖ **üî¥ CRITICAL - MANDATORY CHECKPOINT:** Business logic string literals use constants (InfoConstants.cs, ErrorConstants.cs)
    - [ ] **BLOCKING:** Did I verify NO hardcoded string literals in business logic code?
    - [ ] **BLOCKING:** Did I add constants to InfoConstants.cs for ALL business logic string values (process names, messages, etc.)?
    - [ ] **BLOCKING:** Did I use `RequestHeaders.RequestId.Item2.Value?.ToString()` for Execution ID (NOT hardcoded header name)?
    - ‚úÖ **CORRECT:** `string processName = InfoConstants.PROCESS_NAME;` (constant from InfoConstants.cs)
    - ‚úÖ **CORRECT:** `string executionId = RequestHeaders.RequestId.Item2.Value?.ToString() ?? string.Empty;` (rulebook requirement)
    - ‚úÖ **ALLOWED:** `stepName: "CreateLeaveFunction.cs / Executing Run"` (literal string - stepName is exception)
    - ‚úÖ **ALLOWED:** `_logger.Info("HTTP Request received for CreateLeave.");` (literal string - logging messages are exception)
    - ‚ùå **WRONG:** `string processName = "<Operation> Process";` (hardcoded string literal in business logic - **PROHIBITED**)
    - ‚ùå **WRONG:** `req.Headers.TryGetValue("company-code", ...)` (hardcoded header name - **PROHIBITED**, must use constant)
17. ‚úÖ **üî¥ CRITICAL - MANDATORY CHECKPOINT:** Uses `ResponseDTOHelper` for response mapping
    - ‚úÖ **CORRECT:** `ResponseDTOHelper.Populate<Entity>Res(responseContent, resDto)` - mapping method in `Helper/ResponseDTOHelper.cs`
    - ‚ùå **WRONG:** Private mapping method in Function class (e.g., `private <Operation>ResDTO Map<SOR>ResponseTo<Operation>Response(...)`)
    - ‚ùå **WRONG:** Manual JSON parsing with `JsonDocument` or `JsonElement` in Function class
    - **üî¥ CRITICAL:** ALL response mapping logic MUST be in `Helper/ResponseDTOHelper.cs` as `public static` methods
    - **üî¥ CRITICAL:** Function class MUST NOT contain any mapping/transformation methods - Functions are thin orchestrators
18. ‚úÖ **üî¥ CRITICAL - MANDATORY CHECKPOINT:** Async patterns follow rulebook requirements
   - [ ] **STOP:** Did I verify ALL async calls use `await` and store return values?
   - [ ] **STOP:** Did I verify NO `_ = await ...` pattern (discarding task results)?
   - [ ] **STOP:** Did I verify NO `_ = Task.Run(...)` pattern (fire-and-forget)?
   - ‚úÖ **CORRECT:** `HttpResponseSnapshot response = await _service.Method(...);` (store return value with explicit type)
   - ‚úÖ **CORRECT:** Check response status: `if (!response.IsSuccessStatusCode) { ... }`
   - ‚ùå **WRONG:** `_ = await _service.Method(...);` (discarding task result - **PROHIBITED**)
   - ‚ùå **WRONG:** `await _service.Method(...);` without storing return value (missing response status check)
   - **üî¥ CRITICAL:** ALL async calls MUST store return values for consistency and proper error handling
   - **üî¥ CRITICAL:** ALL async calls MUST check response status codes

19. ‚úÖ **üî¥ CRITICAL - MANDATORY CHECKPOINT:** Configuration files validation completed
   - [ ] **BLOCKING:** Did I verify `appsettings.json` validation completed? (follow Section 13.9 - Config Models Rules - Post-Creation Validation)
   - [ ] **BLOCKING:** Did I verify `appsettings.json` is kept EMPTY (or minimal structure only)?
   - [ ] **BLOCKING:** Did I verify all properties are added to ALL environment-specific files (`appsettings.dev.json`, `appsettings.qa.json`, `appsettings.stg.json`, `appsettings.prod.json`, `appsettings.dr.json`)?
   - [ ] **BLOCKING:** Did I verify `HttpClientPolicy.RetryCount` is `0` (not `1`) in all environment files unless explicitly required?
   - [ ] **BLOCKING:** Did I verify NO SOR URLs, SOR base URLs, or SOR resource paths in Process Layer AppConfigs?
   - **üö® CRITICAL:** `appsettings.json` validation is MANDATORY and MUST be completed as part of Process Layer validation

20. ‚úÖ **üî¥ CRITICAL - MANDATORY CHECKPOINT:** host.json validation completed
   - [ ] **BLOCKING:** Did I verify `host.json` validation completed? (follow Section 19.7 - host.json Rules - Post-Creation Validation)
   - [ ] **BLOCKING:** Did I verify `host.json` uses EXACT template format (no deviations)?
   - [ ] **BLOCKING:** Did I verify version is `"2.0"` (for .NET 8 Isolated Worker Model)?
   - [ ] **BLOCKING:** Did I verify NO `excludedTypes` property in `samplingSettings`?
   - [ ] **BLOCKING:** Did I verify NO environment-specific host.json files created (host.dev.json, host.prod.json, etc.)?
   - [ ] **BLOCKING:** Did I verify NO app configs added to host.json (use appsettings.json)?
   - [ ] **BLOCKING:** Did I verify NO retry policies added to host.json (use Polly in Program.cs)?
   - **üö® CRITICAL:** `host.json` validation is MANDATORY and MUST be completed as part of Process Layer validation

21. ‚úÖ **üî¥ CRITICAL - MANDATORY CHECKPOINT:** Email template validation (if Function has error handling with email notifications)
   - [ ] **BLOCKING:** Read the ENTIRE file line by line ‚Üí Check if this Function has error handling that includes email notifications (check error path in Function code)
   - [ ] **BLOCKING:** If YES ‚Üí Did I verify email templates are embedded HTML resources (NOT hardcoded strings)?
   - [ ] **BLOCKING:** Read the ENTIRE file line by line ‚Üí Look for email body construction patterns (`emailBody`, `BuildErrorEmailBody`, HTML strings, etc.)
   - [ ] **BLOCKING:** For EACH email body construction found:
     - [ ] Is it calling a helper method that reads embedded template (e.g., `ResponseDTOHelper.ReadEmailTemplate(...)`)? ‚Üí ‚úÖ PASS
     - [ ] Is it a hardcoded HTML string (e.g., `$@"<!DOCTYPE html>..."` or `"<html>..."`)? ‚Üí **VIOLATION** ‚Üí Must use embedded template ‚Üí Document line number ‚Üí Fix ‚Üí Re-read file
     - [ ] Is it a private method that builds email body with hardcoded HTML? ‚Üí **VIOLATION** ‚Üí Must use embedded template ‚Üí Document line number ‚Üí Fix ‚Üí Re-read file
   - [ ] **BLOCKING:** Did I verify `EmailTemplate/<TemplateName>.html` folder and file exist (where `<TemplateName>` is the specific template name for this process)?
   - [ ] **BLOCKING:** Did I verify email template is marked as `EmbeddedResource` in .csproj?
   - [ ] **BLOCKING:** Did I verify email body uses embedded template (via helper method) instead of hardcoded string?
   - [ ] **BLOCKING:** Did I read Boomi subprocess JSON file (subprocess_*.json) to find email template?
   - [ ] **BLOCKING:** Did I locate email template in subprocess JSON (search for "msgTxt" or "MailBody" in message/documentproperties shapes)?
   - [ ] **BLOCKING:** Did I extract EXACT email template HTML from Boomi subprocess JSON (copy entire template including DOCTYPE, html, head, body tags)?
   - [ ] **BLOCKING:** Did I verify email template structure matches Boomi subprocess template EXACTLY (same tags, same structure, same placeholders, same whitespace) by comparing line-by-line?
   - [ ] **BLOCKING:** Did I verify email template placeholders match Boomi subprocess placeholders EXACTLY (e.g., `{1}`, `{2}`, `{3}`, `{4}` - verify order and numbering from msgParameters section)?
   - [ ] **BLOCKING:** Did I verify placeholder order matches Boomi subprocess parameter order (check msgParameters in subprocess JSON to verify key values and their corresponding process properties)?
   - [ ] **BLOCKING:** Did I verify placeholders in email template are populated from correct sources (check Phase 1 Section 9 - Properties Read table and subprocess JSON msgParameters)?
   - [ ] **BLOCKING:** Did I verify placeholder population uses `string.Format()` with correct parameter order matching Boomi subprocess msgParameters key order?
   - [ ] **BLOCKING:** Read the ENTIRE file line by line ‚Üí Verify NO hardcoded email HTML strings in Function or Service code (e.g., `string.Format(InfoConstants.EMAIL_BODY_TEMPLATE, ...)`)
   - [ ] **BLOCKING:** Read InfoConstants.cs and ErrorConstants.cs files ‚Üí Verify NO email HTML constants exist
   - ‚úÖ **CORRECT:** Email notification uses embedded HTML template: `string template = ResponseDTOHelper.ReadEmailTemplate("<ProjectName>.EmailTemplate.<TemplateName>.html"); string emailBody = string.Format(template, processName, environment, executionId, errorMessage);`
   - ‚úÖ **CORRECT:** Email template file exists: `EmailTemplate/<TemplateName>.html` with exact Boomi HTML structure extracted from subprocess JSON msgTxt section
   - ‚úÖ **CORRECT:** Email template marked as embedded resource in .csproj: `<EmbeddedResource Include="EmailTemplate\<TemplateName>.html" />`
   - ‚ùå **WRONG:** Hardcoded email body: `string emailBody = $@"<!DOCTYPE html>...";` - **PROHIBITED**
   - ‚ùå **WRONG:** Private method with hardcoded HTML: `private string BuildErrorEmailBody(...) { return $@"<!DOCTYPE html>..."; }` - **PROHIBITED**
   - ‚ùå **WRONG:** Email HTML hardcoded in constants: `EMAIL_BODY_TEMPLATE = "Process: {0}<br>..."` in `InfoConstants.cs` - **PROHIBITED**
   - ‚ùå **WRONG:** Email template doesn't match Boomi structure from subprocess JSON - **PROHIBITED**
   - ‚ùå **WRONG:** Email template placeholders don't match Boomi subprocess msgParameters numbering - **PROHIBITED**
   - ‚ùå **WRONG:** Placeholder population parameter order doesn't match Boomi subprocess msgParameters key order - **PROHIBITED**
   - **üî¥ CRITICAL:** Email templates MUST be embedded HTML resources matching Boomi subprocess template exactly (see Section 17.4: Email Template Helpers)
   - **üî¥ CRITICAL:** Email template HTML MUST be extracted EXACTLY from Boomi subprocess JSON file (subprocess_*.json) - locate in msgTxt section of message shapes
   - **üî¥ CRITICAL:** Email template placeholders MUST match Boomi subprocess placeholders EXACTLY (verify placeholder numbering and order from msgParameters section in subprocess JSON)
   - **üî¥ CRITICAL:** Placeholder population parameter order MUST match Boomi subprocess msgParameters key order (verify parameter order in string.Format matches msgParameters)
   - **üî¥ CRITICAL:** Each process has different email templates - verify template name and structure from Phase 1 Section 9 or subprocess JSON
   - **üî¥ CRITICAL:** This rule has been missed repeatedly - DO NOT SKIP THIS CHECKPOINT if Function has error handling with email notifications
   - **üö® CRITICAL:** You MUST read the entire file systematically and verify embedded templates are used. Do NOT skip this step.

22. ‚úÖ **üî¥ CRITICAL - MANDATORY CHECKPOINT:** Function dependency injection validation
   - [ ] **BLOCKING:** Read the ENTIRE file line by line ‚Üí Look for constructor parameters and field declarations
   - [ ] **BLOCKING:** For EACH constructor parameter or field declaration found:
     - [ ] Is it in a comment? ‚Üí **ALLOWED**
     - [ ] Is it a System/Process Abstraction (e.g., `SendNotificationMgmtSys`, `ILeaveMgmt`, `EntityProc`)? ‚Üí **VIOLATION** ‚Üí Function MUST NOT inject System/Process Abstractions directly ‚Üí Document line number
     - [ ] Is it a Service (e.g., `<Entity>Service`, `NotificationService`)? ‚Üí ‚úÖ PASS
   - [ ] **BLOCKING:** If ANY violations found ‚Üí STOP ‚Üí Create Service (e.g., `<Entity>Service`, `NotificationService`) ‚Üí Inject Service into Function ‚Üí Remove System/Process Abstraction injection ‚Üí Re-read file ‚Üí Verify zero violations
   - [ ] **BLOCKING:** Verify Function ONLY injects Services (direct: `<Entity>Service` OR via interface: `I<Entity>Service`)
   - [ ] **BLOCKING:** Verify Services handle System/Process Abstraction injection (Services inject Abstractions via interface)
   - ‚úÖ **CORRECT:** `private readonly <Entity>Service _<entity>Service;` (Function injects Service)
   - ‚úÖ **CORRECT:** `private readonly NotificationService _notificationService;` (Function injects Service for cross-cutting concerns)
   - ‚úÖ **CORRECT:** `private readonly I<Entity>Service _<entity>Service;` (Function injects Service via interface)
   - ‚ùå **WRONG:** `private readonly <Entity>MgmtSys _<entity>MgmtSys;` (Function injects System Abstraction directly - **PROHIBITED**)
   - ‚ùå **WRONG:** `private readonly I<Entity>Mgmt _<entity>Mgmt;` (Function injects System Abstraction interface directly - **PROHIBITED**)
   - **üî¥ CRITICAL:** Functions MUST NOT inject System/Process Abstractions directly - This violates the mandatory call flow (Functions ‚Üí Services ‚Üí System/Process Abstractions)
   - **üî¥ CRITICAL:** Cross-cutting concerns (e.g., error notifications) MUST be handled via Services (e.g., `NotificationService`), NOT by injecting System Abstractions directly into Functions
   - **üö® CRITICAL:** You MUST read the entire file systematically and verify Functions only inject Services. Do NOT skip this step.

**üõë IF ANY VIOLATION ‚Üí STOP ‚Üí Fix Function ‚Üí Then proceed**

### Azure Functions - Common Mistakes

**‚ùå Using "API" Keyword in Function Names**
- **üî¥ CRITICAL: NEVER EVER use "API" keyword** - This is a MANDATORY rule with NO EXCEPTIONS
- **WRONG:** `[Function("CreateEntityAPI")]` - Contains "API" keyword in Function attribute
- **WRONG:** `public class CreateEntityAPIFunction` - Contains "API" keyword in class name
- **WRONG:** `CreateEntityAPIFunction.cs` - Contains "API" keyword in file name
- **WRONG:** `[Function("CreateEntityApi")]` - "Api" (case-insensitive) is also PROHIBITED
- **CORRECT:** `[Function("CreateEntity")]` - No "API" keyword
- **CORRECT:** `public class CreateEntityFunction` - No "API" keyword
- **CORRECT:** `CreateEntityFunction.cs` - No "API" keyword
- **Why:** "API" suffix/keyword is ONLY for System Layer Functions. Process Layer Functions MUST NOT contain "API" in any form (API, Api, api) in Function attribute, class name, or file name. This is a critical architectural distinction between Process Layer and System Layer.

**‚ùå Using `var` Keyword in Functions**
- **üî¥ CRITICAL: NEVER EVER use `var` keyword** - This is a MANDATORY rule with NO EXCEPTIONS
- **WRONG:** `var response = await _systemAbstraction.CallSystemLayer();`
- **CORRECT:** `HttpResponseSnapshot response = await _systemAbstraction.CallSystemLayer();`
- **Why:** Explicit types improve code clarity, consistency, and make it easier to understand return types and variable declarations

**‚ùå Using `internal` Keyword in Functions**
- **üî¥ CRITICAL: NEVER EVER use `internal` keyword** - This is a MANDATORY rule with NO EXCEPTIONS
- **WRONG:** `internal async Task<HttpResponseSnapshot> CreateEntity(EntityReqDTO dto)`
- **CORRECT:** `public async Task<HttpResponseSnapshot> CreateEntity(EntityReqDTO dto)`
- **Why:** Function methods MUST be `public` - Functions are entry points and must be accessible

**‚ùå Null Coalescing After Validation**
- **WRONG:** `dto.<FieldName> ?? string.Empty` (after Validate() passes)
- **CORRECT:** `dto.<FieldName>` (after Validate() passes, use DTO properties directly)
- **Why:** After `Validate()` passes, use DTO properties directly, no `??` operators. DTO properties default to `string.Empty`.

**‚ùå Verbose Header Reading Pattern**
- **WRONG:** Verbose if-blocks for header reading
- **CORRECT:** Use clean ternary operator pattern with `StringValues`
- **Why:** Clean ternary operator pattern with `StringValues`, not verbose if-blocks

**‚ùå Wrong Function Folder Structure**
- **WRONG:** `Functions/EntityFunction.cs` (Missing subfolder)
- **CORRECT:** `Functions/EntityFunctions/EntityFunction.cs` (Plural subfolder)
- **Why:** Process Layer Functions MUST be in subfolders with plural names.

**‚ùå Adding "api" to Route**
- **WRONG:** `Route = "api/<resource>/<operation>"`
- **CORRECT:** `Route = "<resource>/<operation>"` (Azure Functions automatically adds `/api` prefix)
- **Why:** Azure Functions runtime automatically prefixes all routes with `/api`, so NEVER include `"api"` in Route attribute

**‚ùå Using Route Attribute When Function Name is Sufficient**
- **üî¥ CRITICAL:** When you don't need nested routes (e.g., `"<resource>/<operation>"`), DO NOT use Route attribute
- **WRONG:** `[Function("CreateEntity")]` with `Route = "CreateEntity"` (redundant - Function name already defines the route)
- **CORRECT:** `[Function("CreateEntity")]` without Route attribute (Azure Functions automatically uses Function name as route)
- **When to use Route:** Only when you need nested routes like `"<resource>/<operation>"` or route parameters like `"<resource>/{id}"`
- **When NOT to use Route:** When the route matches the Function name exactly (e.g., `[Function("CreateEntity")]` ‚Üí route is automatically `CreateEntity`)
- **Why:** Azure Functions automatically uses the Function name as the route when Route attribute is omitted. Using Route attribute with the same value as Function name is redundant and violates DRY principle

**‚ùå Using try-catch Blocks**
- **WRONG:** Using `try-catch` blocks in Functions
- **CORRECT:** Handle errors in `else` blocks, then throw exceptions. Let ExceptionHandlerMiddleware catch and normalize all exceptions.
- **Why:** ExceptionHandlerMiddleware is designed to catch ALL unhandled exceptions and normalize them to BaseResponseDTO. Using try-catch blocks prevents proper exception handling.

**‚ùå Hardcoded String Literals**
- **WRONG:** `string processName = "<Operation> Process";` (business logic string - must use constant)
- **WRONG:** `req.Headers.TryGetValue("company-code", ...)` (header name - must use constant)
- **CORRECT:** `string processName = InfoConstants.PROCESS_NAME;` (constant from InfoConstants.cs)
- **CORRECT:** `req.Headers.TryGetValue(InfoConstants.COMPANY_CODE_HEADER, ...)` (constant for header name)
- **ALLOWED:** `stepName: "CreateLeaveFunction.cs / Executing Run"` (literal string - stepName is exception)
- **ALLOWED:** `_logger.Info("HTTP Request received for CreateLeave.");` (literal string - logging messages are exception)
- **Why:** Functions MUST use constants (InfoConstants.cs, ErrorConstants.cs) for business logic string literals. Exceptions: Function attribute names, stepName values, and logging messages are allowed as literal strings.

**‚ùå Passing Domain Objects to Services**
- **WRONG:** `await _service.Method(domain);`
- **CORRECT:** `await _service.Method(dto);` (pass DTO to Service, not domain)
- **Why:** Functions MUST pass DTOs to Services (NEVER pass Domain objects). Domain is for internal purposes only, DTO is the contract between layers.

**‚ùå Manual Response Mapping in Function**
- **WRONG:** Private mapping method in Function class or manual JSON parsing
- **CORRECT:** `ResponseDTOHelper.Populate<Entity>Res(responseContent, resDto)`
- **Why:** ALL response mapping logic MUST be in `Helper/ResponseDTOHelper.cs` as `public static` methods. Function class MUST NOT contain any mapping/transformation methods.

### Azure Functions - AppConfigs & URLs

**üî¥ CRITICAL: Process Layer AppConfigs URL Rules**

**Process Layer AppConfigs URLs MUST ONLY contain:**
- ‚úÖ **System Layer Function URLs** - URLs pointing to System Layer Azure Functions (e.g., `SystemLayerUrl`, `NotificationSystemLayerUrl`)
- ‚úÖ **Process Layer Function URLs** - URLs pointing to other Process Layer Azure Functions (e.g., `AuthProcessLayerUrl`, `DataProcessLayerUrl`)

**Process Layer AppConfigs URLs MUST NEVER contain:**
- ‚ùå **SOR (System of Record) URLs** - Direct URLs to external systems/APIs (e.g., `https://api.example.com`, `https://smtp.example.com`)
- ‚ùå **Downstream API URLs** - Direct URLs to third-party services
- ‚ùå **SOR base URLs** - Base URLs for external systems
- ‚ùå **SOR resource paths** - Resource paths for external systems
- ‚ùå **Any SOR URL construction components** - Components used to build SOR URLs

**Why:** Process Layer calls System Layer Functions via HTTP. System Layer Functions handle SOR communication. Process Layer should NEVER directly call SORs.

**Naming Convention:**
- System Layer URLs: `{SystemName}SystemLayerUrl` or `{SystemName}SystemLayer{Operation}Url`
- Process Layer URLs: `{ProcessName}ProcessLayerUrl` or `{ProcessName}ProcessLayer{Operation}Url`
- ‚ùå **WRONG:** `SystemApiUrl`, `NotificationSmtpUrl`, `SORUrl` (these suggest SOR URLs)
- ‚úÖ **CORRECT:** `SystemSystemLayerUrl`, `NotificationSystemLayerUrl` (these indicate System Layer Functions)

**Example:**
- ‚úÖ **CORRECT:** `Create<Entity>Url = "https://<system-layer-function-url>/api/<operation>"` (System Layer Function URL)
- ‚ùå **WRONG:** `SORBaseUrl = "https://<sor-base-url>"`, `SORResourcePath = "/api/services/..."` (SOR URL construction - belongs in System Layer AppConfigs)

**Configuration Injection:**
- Configuration values MUST be injected via `IOptions<AppConfigs>` in Function/Service
- ‚ùå **NEVER read from HTTP headers** - Defined parameters are configuration, not request data
- ‚ùå **NEVER add to DTO** - Defined parameters are configuration, not request data

---

## 3. Domain Rules (Business Objects)

**üö® CRITICAL:** Domains are ALWAYS required and ALWAYS populated. They encapsulate business entities with behavior and are MANDATORY for Process Layer operations.

### 3.1 Domain - Pre-Creation Validation

**üõë PRE-CREATION VALIDATION (MANDATORY - STOP IF NOT COMPLETE)**

**üö® YOU CANNOT CREATE ANY DOMAIN UNTIL:**

1. ‚úÖ **STOP AND VERIFY:** Have I read ALL sections in "DOMAIN RULES"?
2. ‚úÖ **STOP AND VERIFY:** Have I checked Phase 1 document to identify which entity properties are needed?
3. ‚úÖ **STOP AND VERIFY:** Have I verified which properties are in the Boomi contract (Phase 1 document, Boomi JSON profile files)?
4. ‚úÖ **STOP AND VERIFY:** Have I verified which properties are used in System Abstraction when building request to SOR?
5. ‚úÖ **STOP AND VERIFY:** Do I understand that Domain is for internal purposes only (created in Function, populated by DTO, but NEVER passed to Services or System Abstractions)?
6. ‚úÖ **STOP AND VERIFY:** Do I understand that Domain MUST NOT inject System/Process Abstractions or have methods that call external systems?
7. ‚úÖ **STOP AND VERIFY:** Do I understand that `ICacheable` is NEED-BASED ONLY (only implement if caching is actually used with `[CacheableService]` attribute)?

**üõë IF ANY CHECKPOINT FAILS ‚Üí STOP ‚Üí Complete missing step ‚Üí Then create Domain**

**üî¥ MANDATORY WORKFLOW STEP 5: Domains**

**üö® BEFORE creating Domains (BLOCKING - CANNOT PROCEED WITHOUT COMPLETING):**

- [ ] **BLOCKING:** Did I complete WORKFLOW STEP 4 (DTOs)?
- [ ] **BLOCKING:** Did I use `read_file` tool to read Section 3 (Domain Rules)?
- [ ] **BLOCKING:** Did I find exact template/example in Section 3?
- [ ] **BLOCKING:** Did I copy template exactly before writing code?
- [ ] **BLOCKING:** Did I read "üõë PRE-CREATION VALIDATION" in Section 3?
- [ ] **BLOCKING:** Did I check "COMMON MISTAKES" #25 (Domain Object Passing Between Layers)?

**If you write code without reading Section 3 first ‚Üí DELETE code ‚Üí Read Section 3 ‚Üí Retry**

**Implementation:**
- [ ] Create Domain classes
- [ ] Verify domain implements `IDomain<T>` (if main domain)
- [ ] Verify domain implements `ICacheable` ONLY if caching is actually used
- [ ] Verify domain is for internal use only
- [ ] Verify NO constructor injection of System/Process Abstractions
- [ ] Verify NO methods that call external systems
- [ ] Verify ONLY simple business validation methods (need-based)

**üõë IF ANY CHECKPOINT FAILS ‚Üí STOP ‚Üí Complete missing step ‚Üí Then proceed**

### 3.2 Domain - Folder Structure & Naming

**üî¥ CRITICAL: Domain Folder Structure Rules**

- **‚úÖ CORRECT: Single Domain (No Subfolder):** If only ONE domain exists for a business domain ‚Üí `Domains/<EntityName>.cs`
  - ‚úÖ **CORRECT:** `Domains/<Entity>.cs` with class `<Entity>` (if only one domain exists)
- **‚úÖ CORRECT: Multiple Domains (Subfolder Required):** If MULTIPLE domains exist for a business domain ‚Üí `Domains/<BusinessDomain>/<EntityName>.cs`
  - ‚úÖ **CORRECT:** `Domains/<BusinessDomain>/<Entity>.cs` and `Domains/<BusinessDomain>/<Entity>Attachment.cs` (multiple related domains)
- **‚úÖ CORRECT Domain Class Name:** Use the business entity name, NOT the operation name
  - ‚úÖ **CORRECT:** Class `<Entity>` (for `<Operation>` operation)
  - ‚ùå **WRONG:** Class `<Operation>Request` (operation name, not entity name)
- **Rule:** Domain represents the business entity, not the operation. Operations are in Functions/DTOs, entities are in Domains.
- **üî¥ CRITICAL:** Only create a subfolder if MULTIPLE domains exist in that business domain. If only one domain exists, put it directly in `Domains/` without a subfolder.

**Examples of Business Domains:**
- Properties
- Facilities
- Automotive
- Food
- HumanResource
- KABITaxi
- And many more business domains as needed

**Note:** `<BusinessDomain>` represents the business domain name (e.g., `Properties`, `Facilities`, `Automotive`) that groups related domain entities.

**Namespace Pattern:** `<NS>.Domains.<BusinessDomain>`

### 3.3 Domain - Structure & Patterns

**Domain Pattern (Standard Process Layer):**

```csharp
public class <Entity>Domain : IDomain<int> {
    private int _id;
    public int Id { get => _id; set => _id = value; }
    public string? PropertyA { get; set; }
    public string? PropertyB { get; set; }
    public <Entity>Details? Details { get; set; }
    public List<<Entity>Child> Items { get; set; } = new();
    
    // ‚úÖ ONLY simple business validation methods (need-based only)
    // Example: IsRecurring() checks business rule based on Details.Code property
    public bool IsRecurring() => Details != null && !string.IsNullOrEmpty(Details.Code);
    public bool HasItems() => Items != null && Items.Count > 0;
}
```

**Key Points:**
- NO constructor injection (no System Abstractions, no ILogger)
- NO methods that call external systems
- ONLY data properties and simple business validation methods
- Used internally in Functions (populated by DTOs, but NEVER passed to Services or System Abstractions)

### 3.4 Domain - Caching (ICacheable) - NEED-BASED ONLY

**üî¥ CRITICAL:** This section applies **ONLY** if you are actually using caching with `[CacheableService]` attribute. If caching is not needed, do NOT implement `ICacheable`.

**Pattern A: With IDomain<T> (ONLY if caching is used)**

```csharp
public class <Entity>Info : IDomain<int>, ICacheable {
    public int Id { get; set; }
    public string Code { get; set; } = string.Empty;
    public List<string> Details { get; set; }
    
    public IDictionary<PropertyInfo, object> GetCacheKey() {
        Dictionary<PropertyInfo, object> p = new Dictionary<PropertyInfo, object>();
        p.Add(GetType().GetProperty(nameof(Code))!, Code!);
        if (Details?.Count > 0) { 
            Details.Sort(); 
            p.Add(GetType().GetProperty(nameof(Details))!, string.Join("|", Details)); 
        }
        return p;
    }
}
```

**Pattern B: ONLY ICacheable (NO IDomain)**

```csharp
public class DataEntity : ICacheable {
    public string Code { get; set; } = string.Empty;
    public string Status { get; set; } = string.Empty;
    public string StartDate { get; set; } = string.Empty;
    public List<Attachment> Items { get; set; } = new();
    
    public IDictionary<PropertyInfo, object> GetCacheKey() {
        Dictionary<PropertyInfo, object> p = new Dictionary<PropertyInfo, object>();
        p.Add(GetType().GetProperty(nameof(Code))!, Code!);
        p.Add(GetType().GetProperty(nameof(Status))!, Status!);
        p.Add(GetType().GetProperty(nameof(StartDate))!, StartDate!);
        return p;
    }
}
```

**When to use:**
- **Pattern A (IDomain<T> + ICacheable):** Domain has business logic methods (e.g., `IsRecurring()`, `IsExpired()`) AND is used in cached System Layer calls
- **Pattern B (ONLY ICacheable):** Domain is used ONLY as request parameter for cached System Layer calls (no business logic methods needed)

**üî¥ CRITICAL:** `ICacheable` is **NEED-BASED** - Only implement if you are actually using caching with `[CacheableService]` attribute. If caching is not needed, do NOT implement `ICacheable`.

### 3.5 Domain - Child Domain Objects - NEED-BASED ONLY

**üî¥ CRITICAL: Only Create If Actually Required**

- ‚úÖ **ONLY create child domain objects** if they are explicitly required by:
  - System Layer API contract (the SOR API expects a nested structure)
  - Business logic that needs to operate on the child object separately
  - Actual data structure requirements from Boomi contract
- ‚ùå **NEVER create child domain objects** "just in case" or for future use
- ‚ùå **NEVER create child domain objects** if a simple property (e.g., `string Attachment`) is sufficient
- ‚úÖ **Verify necessity** - Before creating a child domain object, verify it's actually needed

**Purpose:** Supporting/nested objects used within main domains (attachments, details, events) - **ONLY if actually required**

**Pattern A: Simple POCO (No DI) - ONLY if required**

```csharp
// ‚úÖ ONLY create if System Layer API or business logic actually requires this structure
public class <Entity>Attachment {
    public string FileName { get; set; } = string.Empty;
    public string FileType { get; set; } = string.Empty;
    public string FileContent { get; set; } = string.Empty;
    public string Description { get; set; } = string.Empty;
}
```

**When NOT to create child domain objects:**

```csharp
// ‚ùå WRONG - Creating unnecessary child class when simple property is sufficient
public class <Entity> {
    public List<<Entity>Attachment> Attachments { get; set; }  // ‚ùå Unnecessary if attachment is just a string
}

// ‚úÖ CORRECT - Use simple property if that's all that's needed
public class <Entity> {
    public string Attachment { get; set; } = string.Empty;  // ‚úÖ Sufficient if System Layer just needs a string
}
```

**Pattern B: With Constructor DI (If logging/dependencies needed)**

```csharp
public class <Entity>Details {
    private int _id;
    public int Id { get => _id; set => _id = value; }
    public string Status { get; set; } = string.Empty;
    public DateTime? ScheduledDate { get; set; }
    
    private readonly ILogger<<Entity>Details> _logger;
    public <Entity>Details(ILogger<<Entity>Details> logger) { _logger = logger; }
}
```

**Usage in Parent Domain:**

```csharp
public class <Entity>Domain : IDomain<int> {
    public int Id { get; set; }
    public <Entity>Details? Details { get; set; }
    public List<<Entity>Attachment> Attachments { get; set; } = new();
}
```

### 3.6 Domain - DI Registration

**üî¥ CRITICAL: Domain Registration Rules**

```csharp
// Main domains - NOT registered (simple POCOs, no constructor dependencies)
// <Entity>Domain, DataDomain - NOT registered

// Child domains with DI (if they have constructor dependencies like ILogger)
builder.Services.AddScoped<<Entity>Details>();

// Child domains without DI (simple POCOs) - NOT registered
```

**CRITICAL:** Main domains are NOT registered in DI because they have NO constructor dependencies. They are simple POCOs populated by DTOs for internal use within Functions. **NEVER pass Domain objects to Services or System Abstractions - always pass DTOs.**

### 3.7 Domain - Key Rules

| Rule | Main Domain | Child Domain (with DI) | Child Domain (POCO) |
|------|-------------|----------------------|---------------------|
| **Interface** | `IDomain<T>` OR `ICacheable` OR both (need-based) | NO interface | NO interface |
| **ICacheable** | ‚úÖ **ONLY** if caching is actually used (with `[CacheableService]` attribute) | ‚ùå Not used | ‚ùå Not used |
| **Constructor DI** | ‚ùå **NEVER** inject dependencies | ‚úÖ ILogger (if needed) | ‚ùå No constructor |
| **Methods** | ‚úÖ **ONLY** simple business validation (need-based: IsRecurring, IsExpired, HasItems) | Rare | None |
| **System Calls** | ‚ùå **NEVER** call System/Process Abstractions | ‚ùå Not used | ‚ùå Not used |
| **Registration** | ‚ùå **NOT** registered (POCOs) | `AddScoped<<Entity>Details>()` | ‚ùå Not registered |
| **Id Property** | ‚úÖ Required (IDomain<T>) | ‚úÖ Optional | ‚ùå Rarely |
| **Folder** | `Domains/<BusinessDomain>/<Entity>.cs` | Same as parent | Same as parent |
| **Purpose** | Data holder + simple validation | Nested data | Nested data |

**CRITICAL:** Main domains are NOT registered in DI because they have NO constructor dependencies. They are simple POCOs populated by DTOs for internal use within Functions. **NEVER pass Domain objects to Services or System Abstractions - always pass DTOs.**

### 3.8 Domain - Responsibilities

**üö® WHAT DOMAINS SHOULD DO:**

- ‚úÖ Hold data properties **ONLY if actually needed** - Properties must be:
  - Used in `Populate()` method from DTO (mapped from Boomi request)
  - Used in System Abstraction when building request to SOR
  - Required by business logic
  - **Source of truth:** Boomi JSON profile files and Phase 1 document
- ‚úÖ Implement business logic validation methods **ONLY WHEN NEEDED** (e.g., `IsRecurring()`, `IsExpired()`, `HasItems()`)
- ‚úÖ Implement `IDomain<T>` if needed
- ‚úÖ Implement `ICacheable` **ONLY** if caching is actually used (with `[CacheableService]` attribute) - **NEED-BASED, NOT MANDATORY**
- ‚úÖ Be populated by DTOs via `dto.Populate(domain)`

**üî¥ CRITICAL: Domain Property Verification**

- ‚úÖ **ALWAYS verify domain properties against Boomi JSON profile files** - Check Phase 1 document (Step 1a) to see which fields are in the Boomi request
- ‚úÖ **ALWAYS verify domain properties are used** - Check if property is:
  - Populated from DTO in `Populate()` method
  - Used in System Abstraction when building request to SOR
- ‚ùå **NEVER add properties that don't exist in Boomi contract** - If property is not in Boomi JSON profile, it should not be in domain
- ‚ùå **NEVER add properties "just in case"** - Only add properties that are actually needed and used

**‚ùå WHAT DOMAINS SHOULD NEVER DO:**

- ‚ùå **NEVER** inject System Abstractions or Process Abstractions
- ‚ùå **NEVER** have methods that call System Layer or Process Layer APIs
- ‚ùå **NEVER** contain orchestration logic
- ‚ùå **NEVER** directly call external systems
- ‚ùå **NEVER** duplicate DTO validation (checking if required fields are present)

**üî¥ CRITICAL DISTINCTION:**

- **DTO Validation (`dto.Validate()`):** Checks if required fields are present, format validation, input validation
- **Domain Business Logic Methods:** Check business rules based on domain properties (e.g., `IsRecurring()` checks if entity is recurring based on `Details.Code`, `IsExpired()` checks if entity expired based on dates)

**‚ö†Ô∏è NEED-BASED ONLY:** Domain validation methods are **OPTIONAL** and should **ONLY** be created when there's a business logic need. Do NOT create methods that just check if required fields are present - that's DTO validation territory.

**‚úÖ CORRECT DOMAIN PATTERN:**

```csharp
public class <Entity>Domain : IDomain<int>, ICacheable {
    public int Id { get; set; }
    public string Code { get; set; } = string.Empty;
    public <Entity>Details? Details { get; set; }
    public DateTime? ExpiresAt { get; set; }
    public List<<Entity>Child> Items { get; set; } = new();
    
    // ‚úÖ GOOD: Business logic checks (need-based only)
    public bool IsRecurring() => Details != null && !string.IsNullOrEmpty(Details.Code);  // Checks business rule
    public bool IsExpired() => ExpiresAt.HasValue && ExpiresAt.Value < DateTime.UtcNow;  // Checks business state
    public bool HasItems() => Items != null && Items.Count > 0;  // Checks business condition
    
    // ‚ùå WRONG: Duplicating DTO validation
    // public bool IsValid() => !string.IsNullOrEmpty(Code) && Items.Count > 0;  // ‚ùå This is DTO validation, not business logic
    
    public IDictionary<PropertyInfo, object> GetCacheKey() {
        Dictionary<PropertyInfo, object> p = new Dictionary<PropertyInfo, object>();
        p.Add(GetType().GetProperty(nameof(Code))!, Code!);
        return p;
    }
}
```

**Examples of Business Logic vs Input Validation:**

- ‚úÖ `IsRecurring()` - Checks if entity is recurring based on `Details.Code` property (business rule)
- ‚úÖ `IsExpired()` - Checks if token/entity expired based on `ExpiresAt` date (business state)
- ‚úÖ `HasItems()` - Checks if entity has items for business processing (business condition)
- ‚ùå `IsValid()` checking if required fields are present - **This is DTO validation, NOT domain validation**

**‚ùå WRONG PATTERN (DEPRECATED - DO NOT USE):**

```csharp
// ‚ùå NEVER DO THIS - Domains should NOT call System Abstractions
public class <Entity>Domain : IDomain<int> {
    private readonly ILogger<<Entity>Domain> _logger;
    private readonly <Entity>Sys _entitySys;  // ‚ùå WRONG: No System Abstraction injection
    
    public <Entity>Domain(ILogger<<Entity>Domain> l, <Entity>Sys s) { 
        _logger = l; 
        _entitySys = s;  // ‚ùå WRONG
    }
    
    public async Task<HttpResponseMessage> CreateEntity() {  // ‚ùå WRONG: No API calls in domains
        HttpResponseMessage r = await _entitySys.CreateEntity(this);  // ‚ùå WRONG
        return r;
    }
}
```

**WHY THIS IS WRONG:**

- Violates separation of concerns (domains should be data + simple logic only)
- Makes domains tightly coupled to System Layer
- Orchestration belongs in Services, not Domains
- Testing becomes difficult with external dependencies in domains

**WHERE TO PUT SYSTEM LAYER CALLS:**

- ‚úÖ Services call System Abstractions
- ‚úÖ Azure Functions orchestrate via Services
- ‚úÖ DTOs are passed from Function to Service, then from Service to System Abstraction (NEVER pass Domain objects between layers)

### 3.9 Domain - Post-Creation Validation

**üõë POST-CREATION VALIDATION (MANDATORY - VERIFY BEFORE PROCEEDING)**

**üö® AFTER creating Domain, you MUST verify:**

1. ‚úÖ **STOP AND VERIFY:** Implements `IDomain<T>` (if main domain)
2. ‚úÖ **STOP AND VERIFY:** Implements `ICacheable` **ONLY** if caching is actually used (with `[CacheableService]` attribute) - **NEED-BASED, NOT MANDATORY**
3. ‚úÖ **STOP AND VERIFY:** **ALL domain properties are actually needed** - Verify each property is:
   - Used in `Populate()` method from DTO
   - Used in System Abstraction when building request to SOR
   - Required by business logic
   - **Source of truth:** Check Boomi JSON profile files and Phase 1 document to verify which properties are actually in the request/response
4. ‚úÖ **STOP AND VERIFY:** NO properties that don't exist in Boomi contract or aren't used anywhere - **NEVER add properties "just in case"**
5. ‚úÖ **STOP AND VERIFY:** NO constructor injection of System/Process Abstractions
6. ‚úÖ **STOP AND VERIFY:** NO methods that call external systems
7. ‚úÖ **STOP AND VERIFY:** ONLY simple business validation methods (need-based: IsRecurring, IsExpired, etc.) - NOT input validation
8. ‚úÖ **STOP AND VERIFY:** NO implementation-specific comments in Domain properties
   - ‚ùå **WRONG:** `// From header: company-code` (implementation detail - DTO concern)
   - ‚ùå **WRONG:** `// Transformed from dateTime via PopulateDate` (implementation detail - Service concern)
   - ‚úÖ **CORRECT:** No comments about data sources, transformations, or mapping logic
   - **Why:** Domain is a pure business entity - it should NOT know about implementation details
   - **Rule:** Domain represents WHAT the entity is, not HOW data is obtained or transformed
9. ‚úÖ **STOP AND VERIFY:** Located correctly based on number of domains:
   - **If only ONE domain exists:** `Domains/<EntityName>.cs` (e.g., `Domains/<Entity>.cs`) - **NO subfolder**
   - **If MULTIPLE domains exist:** `Domains/<BusinessDomain>/<EntityName>.cs` (e.g., `Domains/<BusinessDomain>/<Entity>.cs`)
   - **üî¥ CRITICAL:** Domain class name MUST be entity name (e.g., `<Entity>`), NOT operation name (e.g., `<Operation>Request`)
   - **üî¥ CRITICAL:** Domain name MUST be generic business entity, NOT operation-specific
     - ‚úÖ **CORRECT:** `<Entity>` (for `<Operation>` operation) - Generic business entity name
     - ‚ùå **WRONG:** `<Operation>` (operation-specific), `<Adjective><Operation>` (operation-specific)
     - **Rule:** If operation is `<Operation>` ‚Üí Domain should be `<Entity>` (generic, reusable)
     - **Real-world example:** If operation is `LateLogin` ‚Üí Domain should be `Attendance` (generic, reusable)
     - **Rule:** Domain name should represent WHAT the entity is, not HOW it's used in operations
     - **üî¥ CRITICAL:** Ask: "What is the generic business entity?" NOT "What operation is this for?"
   - **üî¥ CRITICAL:** Only create subfolder if MULTIPLE domains exist in that business domain
9. ‚úÖ **STOP AND VERIFY:** NOT registered in Program.cs (POCOs, instantiated directly)
10. ‚úÖ **STOP AND VERIFY:** Child domain objects (e.g., `<Entity>Attachment`, `<Entity>Child`) are **ONLY** created if actually required by System Layer API contract or business logic - **NEED-BASED, NOT MANDATORY**

**üõë IF ANY VIOLATION ‚Üí STOP ‚Üí Fix Domain ‚Üí Then proceed**

### 3.10 Domain - Common Mistakes

**‚ùå Domain Object Passing Between Layers**

- **WRONG:** Passing Domain objects to Services or System Abstractions
- **CORRECT:** Pass DTOs between layers, Domain stays in Function for internal use
- **Why:** Domain is for internal purposes only (business logic, validation, etc.), DTO is the contract between layers

**‚ùå Unnecessary ICacheable Interface**

- **WRONG:** Implementing `ICacheable` "just in case" or without actually using caching
- **CORRECT:** Only implement `ICacheable` if caching is actually used with `[CacheableService]` attribute
- **Why:** `ICacheable` is NEED-BASED ONLY - only implement if you are actually using caching

**‚ùå Creating Unnecessary Child Domain Objects**

- **WRONG:** Creating child domain objects "just in case" or when simple property is sufficient
- **CORRECT:** Only create child domain objects if explicitly required by System Layer API contract or business logic
- **Why:** Keep domain structure simple - only create what's actually needed

**‚ùå Adding Implementation-Specific Comments in Domain Classes**

- **WRONG:** 
  ```csharp
  public class Attendance
  {
      public string CompanyCode { get; set; } = string.Empty; // From header: company-code  // ‚ùå Implementation detail
      public string RequestDateTime { get; set; } = string.Empty; // Transformed from dateTime via PopulateDate  // ‚ùå Implementation detail
  }
  ```
- **CORRECT:**
  ```csharp
  public class Attendance
  {
      public string CompanyCode { get; set; } = string.Empty;  // ‚úÖ No implementation comments
      public string RequestDateTime { get; set; } = string.Empty;  // ‚úÖ No implementation comments
  }
  ```
- **Why:** 
  - Domain is a pure business entity - it should NOT know about implementation details
  - Comments like "From header" are DTO concerns (where data comes from)
  - Comments like "Transformed via PopulateDate" are Service concerns (transformation logic)
  - Domain should only represent WHAT the entity is, not HOW data is obtained or transformed
  - Implementation details belong in DTOs (data source) and Services (transformation logic)
- **üî¥ CRITICAL:** Domain classes must be implementation-agnostic. No comments about data sources, transformations, or mapping logic.

**‚ùå Using Operation-Specific Names for Domain Classes**

- **WRONG:** 
  ```csharp
  public class <Operation>  // ‚ùå Operation-specific name
  {
      public string Property1 { get; set; }
      public string Property2 { get; set; }
      public string Property3 { get; set; }
  }
  ```
- **CORRECT:**
  ```csharp
  public class <Entity>  // ‚úÖ Generic business entity name
  {
      public string Property1 { get; set; }
      public string Property2 { get; set; }
      public string Property3 { get; set; }
  }
  ```
- **Why:** 
  - Domain represents the business entity, not the operation
  - Generic names are reusable across multiple operations (e.g., `<Entity>` can be used for multiple related operations)
  - Operation-specific names (like `<Operation>`) tie the domain to a single operation, violating the principle that domains are reusable business entities
  - **Examples:**
    - Operation: `<Operation>` ‚Üí Domain: `<Entity>` (not `<Operation>`)
    - **Real-world example:** Operation: `LateLogin` ‚Üí Domain: `Attendance` (not `LateLogin`)
- **üî¥ CRITICAL:** When creating a domain, ask: "What is the generic business entity this represents?" NOT "What operation is this for?"

**‚ùå Using Operation-Specific Names for Domain Classes**

- **WRONG:** 
  ```csharp
  public class <Operation>  // ‚ùå Operation-specific name
  {
      public string Property1 { get; set; }
      public string Property2 { get; set; }
      public string Property3 { get; set; }
  }
  ```
- **CORRECT:**
  ```csharp
  public class <Entity>  // ‚úÖ Generic business entity name
  {
      public string Property1 { get; set; }
      public string Property2 { get; set; }
      public string Property3 { get; set; }
  }
  ```
- **Why:** 
  - Domain represents the business entity, not the operation
  - Generic names are reusable across multiple operations (e.g., `Attendance` can be used for late, on-time, early check-ins)
  - Operation-specific names (like `LateLogin`) tie the domain to a single operation, violating the principle that domains are reusable business entities
  - **Examples:**
    - Operation: `LateLogin` ‚Üí Domain: `Attendance` (not `LateLogin`)
    - Operation: `CreateLeave` ‚Üí Domain: `Leave` (not `CreateLeave`)
    - Operation: `GetEmployeeDetails` ‚Üí Domain: `Employee` (not `GetEmployeeDetails`)
- **üî¥ CRITICAL:** When creating a domain, ask: "What is the generic business entity this represents?" NOT "What operation is this for?"

**‚ùå Domain Methods Calling External Systems**

- **WRONG:** Injecting System Abstractions or having methods that call external systems
- **CORRECT:** Domains should only have data properties and simple business validation methods
- **Why:** Domains are data holders with simple logic - orchestration belongs in Services

**‚ùå Duplicating DTO Validation in Domain**

- **WRONG:** Creating `IsValid()` methods that check if required fields are present
- **CORRECT:** Domain validation methods should check business rules (e.g., `IsRecurring()`, `IsExpired()`), not input validation
- **Why:** DTO validation checks required fields - Domain validation checks business rules

---

## 4. Caching Rules

**üö® CRITICAL:** Use caching interceptor for System Layer API calls to improve performance. Caching is **NEED-BASED ONLY** - only implement if you actually need to cache System Layer responses.

### 4.1 Caching - Pre-Creation Validation

**üõë PRE-CREATION VALIDATION (MANDATORY - STOP IF NOT COMPLETE)**

**üö® YOU CANNOT IMPLEMENT CACHING UNTIL:**

1. ‚úÖ **STOP AND VERIFY:** Have I verified that caching is actually needed for this System Layer call?
2. ‚úÖ **STOP AND VERIFY:** Do I understand that caching is NEED-BASED ONLY (only implement if actually needed)?
3. ‚úÖ **STOP AND VERIFY:** Have I read ALL sections in "CACHING RULES"?
4. ‚úÖ **STOP AND VERIFY:** Do I understand that System Abstraction method MUST return `HttpResponseSnapshot` (not `HttpResponseMessage`) for caching to work?
5. ‚úÖ **STOP AND VERIFY:** Do I understand that Domain MUST implement `ICacheable` interface with `GetCacheKey()` method (ONLY if caching is used)?
6. ‚úÖ **STOP AND VERIFY:** Do I understand that method MUST be decorated with `[CacheableService(Namespace = nameof(MethodName))]` attribute (ONLY if caching is used)?
7. ‚úÖ **STOP AND VERIFY:** Have I registered System Abstraction with `AddCachedService` (not `AddScoped`) in Program.cs?

**üõë IF ANY CHECKPOINT FAILS ‚Üí STOP ‚Üí Complete missing step ‚Üí Then implement caching**

**üî¥ CRITICAL:** `ICacheable` and `[CacheableService]` are **NEED-BASED** - Only implement if you are actually using caching. If caching is not needed, do NOT implement `ICacheable` or use `[CacheableService]` attribute.

### 4.2 Caching - Caching Interceptor Pattern

**Purpose:** Automatically cache System Layer responses using `[CacheableService]` attribute

**Requirements (ONLY if caching is needed):**

1. System Abstraction method returns `HttpResponseSnapshot` (not `HttpResponseMessage`)
2. Domain implements `ICacheable` interface with `GetCacheKey()` method (ONLY if caching is used)
3. Method decorated with `[CacheableService(Namespace = nameof(MethodName))]` (ONLY if caching is used)
4. System Abstraction registered with `AddCachedService` (not `AddScoped`) in Program.cs

**Example: Domain with ICacheable**

```csharp
public class <Entity>Info : IDomain<int>, ICacheable {
    public int Id { get; set; }
    public string Code { get; set; } = string.Empty;
    public List<string> Details { get; set; }
    
    public IDictionary<PropertyInfo, object> GetCacheKey() {
        Dictionary<PropertyInfo, object> p = new Dictionary<PropertyInfo, object>();
        p.Add(GetType().GetProperty(nameof(Code))!, Code!);
        if (Details?.Count > 0) { 
            Details.Sort(); 
            p.Add(GetType().GetProperty(nameof(Details))!, string.Join("|", Details)); 
        }
        return p;
    }
}
```

**Example: System Abstraction with Caching**

```csharp
public class <Entity>MgmtSys : I<Entity>Mgmt {
    [CacheableService(Namespace = nameof(GetDetails))]
    public async Task<HttpResponseSnapshot> GetDetails(<Entity>Info entity, string type) {
        // ‚úÖ CORRECT - Method returns HttpResponseSnapshot for caching
        HttpResponseMessage r = await _customHttpClient.SendProcessHTTPReqAsync(...);
        return await HttpResponseSnapshot.FromAsync(r);
    }
}
```

**How It Works:**

1. `[CacheableService]` attribute activates caching interceptor
2. CachingInterceptor (Castle DynamicProxy) intercepts method calls
3. Cache key is generated from Domain's `GetCacheKey()` method
4. If cache hit ‚Üí Returns cached `HttpResponseSnapshot`
5. If cache miss ‚Üí Calls System Layer, caches response, returns result

### 4.3 Caching - ICacheable Interface

**üî¥ CRITICAL:** `ICacheable` is **NEED-BASED** - Only implement if you are actually using caching with `[CacheableService]` attribute. If caching is not needed, do NOT implement `ICacheable`.

**Interface Definition:**

```csharp
public interface ICacheable {
    IDictionary<PropertyInfo, object> GetCacheKey();
}
```

**Implementation Requirements:**

1. ‚úÖ Domain MUST implement `ICacheable` interface
2. ‚úÖ MUST implement `GetCacheKey()` method
3. ‚úÖ `GetCacheKey()` MUST return `IDictionary<PropertyInfo, object>`
4. ‚úÖ Cache key MUST be unique for each distinct request
5. ‚úÖ List properties MUST be sorted before adding to cache key (for consistency)

**Pattern A: With IDomain<T> (ONLY if caching is used)**

```csharp
public class <Entity>Info : IDomain<int>, ICacheable {
    public int Id { get; set; }
    public string Code { get; set; } = string.Empty;
    public List<string> Details { get; set; }
    
    public IDictionary<PropertyInfo, object> GetCacheKey() {
        Dictionary<PropertyInfo, object> p = new Dictionary<PropertyInfo, object>();
        p.Add(GetType().GetProperty(nameof(Code))!, Code!);
        if (Details?.Count > 0) { 
            Details.Sort(); 
            p.Add(GetType().GetProperty(nameof(Details))!, string.Join("|", Details)); 
        }
        return p;
    }
}
```

**Pattern B: ONLY ICacheable (NO IDomain)**

```csharp
public class DataEntity : ICacheable {
    public string Code { get; set; } = string.Empty;
    public string Status { get; set; } = string.Empty;
    public string StartDate { get; set; } = string.Empty;
    public List<Attachment> Items { get; set; } = new();
    
    public IDictionary<PropertyInfo, object> GetCacheKey() {
        Dictionary<PropertyInfo, object> p = new Dictionary<PropertyInfo, object>();
        p.Add(GetType().GetProperty(nameof(Code))!, Code!);
        p.Add(GetType().GetProperty(nameof(Status))!, Status!);
        p.Add(GetType().GetProperty(nameof(StartDate))!, StartDate!);
        return p;
    }
}
```

**When to use:**
- **Pattern A (IDomain<T> + ICacheable):** Domain has business logic methods (e.g., `IsRecurring()`, `IsExpired()`) AND is used in cached System Layer calls
- **Pattern B (ONLY ICacheable):** Domain is used ONLY as request parameter for cached System Layer calls (no business logic methods needed)

### 4.4 Caching - CacheableService Attribute

**Purpose:** Activates caching interceptor for System Abstraction methods

**Usage:**

```csharp
[CacheableService(Namespace = nameof(MethodName))]
public async Task<HttpResponseSnapshot> MethodName(<Entity>Info entity, string param) {
    // Method implementation
}
```

**Requirements:**

1. ‚úÖ Attribute MUST be placed on System Abstraction method
2. ‚úÖ `Namespace` parameter MUST use `nameof(MethodName)` (method name)
3. ‚úÖ Method MUST return `HttpResponseSnapshot` (not `HttpResponseMessage`)
4. ‚úÖ Method parameter MUST be Domain that implements `ICacheable`
5. ‚úÖ System Abstraction MUST be registered with `AddCachedService` (not `AddScoped`)

**Example:**

```csharp
public class <Entity>MgmtSys : I<Entity>Mgmt {
    [CacheableService(Namespace = nameof(GetDetails))]
    public async Task<HttpResponseSnapshot> GetDetails(<Entity>Info entity, string type) {
        HttpResponseMessage r = await _customHttpClient.SendProcessHTTPReqAsync(...);
        return await HttpResponseSnapshot.FromAsync(r);
    }
}
```

### 4.5 Caching - Cache Operations Pattern (Central Data Layer)

**üî¥ CRITICAL:** This pattern is ONLY for Central Data Layer (Shared Services). Standard Process Layer uses caching interceptor pattern (Section 4.2).

**Purpose:** Manual cache operations for Central Data Layer Services

**Pattern:**

```csharp
// Create cache key with TTL
CacheKey key = CacheKey.CreateCacheKey(requestDto.GetCacheKey(), _namespace: "data", _cacheKeySettings: new CacheKeySettings { TimeToLive = TimeSpan.FromMinutes(30) });

// Get from cache
<Entity>? cached = await key.GetAsync<<Entity>>();
if (cached != null && cached.IsValid()) {
    return new BaseResponseDTO("Success", "", new <Entity>ResDTO { Id = cached.Id });
}

// Set to cache
await key.SetAsync(entity);

// Delete from cache
await key.DeleteAsync();

// Update TTL dynamically
key.Settings = new CacheKeySettings { TimeToLive = TimeSpan.FromMinutes(60) };
await key.SetAsync(entity);
```

**Cache + DB Hybrid Pattern (Central Data Layer):**

```csharp
public async Task<BaseResponseDTO> ProcessData(DataReqDTO req) {
    // Get config from DB
    ConfigEntity cfg = await _cfgRepo.GetAsync(x => x.Id == Convert.ToInt32(req.Headers["id"]));
    if (cfg == null) throw new HttpBaseServerException(...);
    
    // Create cache key with TTL from config
    CacheKey key = CacheKey.CreateCacheKey(req.GetCacheKey(), _namespace: "data", _cacheKeySettings: new CacheKeySettings { TimeToLive = TimeSpan.FromMinutes(cfg.TTL) });
    
    // Get from cache
    DataEntity? cached = await key.GetAsync<DataEntity>();
    if (cached != null) { 
        if (cached.IsExpired()) throw new BusinessCaseFailureException(...); 
        if (cached.ExpiresAt > DateTimeOffset.UtcNow) throw new BusinessCaseFailureException(...); 
    }
    
    // Generate entity and set to cache
    DataEntity entity = GenerateEntity(out string code, req, cfg);
    await key.SetAsync(entity);
    
    return new BaseResponseDTO("Success", "", new DataResDTO { Id = entity.Id });
}
```

### 4.6 Caching - Cache Settings (TTL Configuration)

**Purpose:** Configure cache TTL (Time To Live) per method

**Configuration (appsettings.json):**

```json
{
  "CacheSettings": {
    "DefaultTTL": 15,
    "TTLsInMinutes": {
      "GetEntityDetails": 120,
      "GetDataInfo": 120,
      "GetLookupValues": 1440,
      "GetReferenceData": 120
    }
  }
}
```

**Config Model:**

```csharp
public class CacheSettings {
    public int DefaultTTL { get; set; } = 15;
    public Dictionary<string, int> TTLsInMinutes { get; set; } = new();
    
    public int GetTTLForMethod(string methodName) {
        if (TTLsInMinutes != null && TTLsInMinutes.TryGetValue(methodName, out int ttl) && ttl > 0) {
            return ttl;
        }
        return DefaultTTL;
    }
}
```

**Usage:**

- `DefaultTTL`: Default cache TTL in minutes (used if method name not found in `TTLsInMinutes`)
- `TTLsInMinutes`: Method-specific TTL configuration (method name ‚Üí TTL in minutes)

### 4.7 Caching - DI Registration

**üî¥ CRITICAL:** System Abstractions with caching MUST be registered with `AddCachedService` (not `AddScoped`).

**Registration Pattern:**

```csharp
// 1. Register Redis Cache Library (REQUIRED for caching)
builder.Services.AddRedisCacheLibrary(builder.Configuration);

// 2. Register System Abstractions
// Without caching
builder.Services.AddScoped<I<Entity>Mgmt, <Entity>MgmtSys>();  // Standard registration

// With caching
builder.Services.AddCachedService<IDataMgmt, DataMgmtSys>();  // Caching interceptor enabled
```

**How AddCachedService Works:**

1. Registers System Abstraction with interface
2. Wraps it with CachingInterceptor (uses Castle DynamicProxy)
3. Intercepts methods with `[CacheableService]` attribute
4. Caches `HttpResponseSnapshot` results based on ICacheable domain's cache key
5. Returns cached response for subsequent calls with same cache key

**Source:** `Framework/Cache/Extensions/CachingExtensions.cs`

**Registration Order:**

1. Redis Cache Library (before System Abstractions)
2. System Abstractions (AddScoped OR AddCachedService)
3. Other services

### 4.8 Caching - Key Rules

| Component | Requirement | Purpose |
|-----------|-------------|---------|
| **Attribute** | `[CacheableService(Namespace = "...")]` | Activates caching interceptor |
| **Return Type** | `HttpResponseSnapshot` (not `HttpResponseMessage`) | Supports caching |
| **Domain** | Implements `ICacheable` (ONLY if caching is used) | Generates cache key (ONLY if caching is used) |
| **Cache Key** | From `GetCacheKey()` method | Unique identifier |
| **Registration** | `AddCachedService<TInterface, TImplementation>()` | Enables caching interceptor |
| **Redis** | `AddRedisCacheLibrary(builder.Configuration)` | Cache storage backend |

**üî¥ CRITICAL RULES:**

1. ‚úÖ Caching is **NEED-BASED ONLY** - Only implement if actually needed
2. ‚úÖ System Abstraction method MUST return `HttpResponseSnapshot` for caching
3. ‚úÖ Domain MUST implement `ICacheable` with `GetCacheKey()` method
4. ‚úÖ Method MUST be decorated with `[CacheableService(Namespace = nameof(MethodName))]`
5. ‚úÖ System Abstraction MUST be registered with `AddCachedService` (not `AddScoped`)
6. ‚úÖ Redis Cache Library MUST be registered before System Abstractions
7. ‚ùå **NEVER** implement `ICacheable` "just in case" - only if caching is actually used
8. ‚ùå **NEVER** use `[CacheableService]` without `ICacheable` implementation
9. ‚ùå **NEVER** register cached service with `AddScoped` - use `AddCachedService`

### 4.9 Caching - Post-Creation Validation

**üõë POST-CREATION VALIDATION (MANDATORY - VERIFY BEFORE PROCEEDING)**

**üö® AFTER implementing caching, you MUST verify:**

1. ‚úÖ **STOP AND VERIFY:** Domain implements `ICacheable` interface (ONLY if caching is used)
2. ‚úÖ **STOP AND VERIFY:** `GetCacheKey()` method is implemented correctly
3. ‚úÖ **STOP AND VERIFY:** List properties are sorted before adding to cache key (for consistency)
4. ‚úÖ **STOP AND VERIFY:** System Abstraction method returns `HttpResponseSnapshot` (not `HttpResponseMessage`)
5. ‚úÖ **STOP AND VERIFY:** Method is decorated with `[CacheableService(Namespace = nameof(MethodName))]`
6. ‚úÖ **STOP AND VERIFY:** System Abstraction is registered with `AddCachedService` (not `AddScoped`)
7. ‚úÖ **STOP AND VERIFY:** Redis Cache Library is registered in Program.cs
8. ‚úÖ **STOP AND VERIFY:** Cache settings (TTL) are configured in appsettings.json (if needed)

**üõë IF ANY VIOLATION ‚Üí STOP ‚Üí Fix caching implementation ‚Üí Then proceed**

### 4.10 Caching - Common Mistakes

**‚ùå Unnecessary ICacheable Interface**

- **WRONG:** Implementing `ICacheable` "just in case" or without actually using caching
- **CORRECT:** Only implement `ICacheable` if caching is actually used with `[CacheableService]` attribute
- **Why:** `ICacheable` is NEED-BASED ONLY - only implement if you are actually using caching

**‚ùå Using CacheableService Without ICacheable**

- **WRONG:** Using `[CacheableService]` attribute without Domain implementing `ICacheable`
- **CORRECT:** Domain MUST implement `ICacheable` with `GetCacheKey()` method
- **Why:** Cache key is generated from Domain's `GetCacheKey()` method

**‚ùå Wrong Return Type for Caching**

- **WRONG:** System Abstraction method returns `HttpResponseMessage` instead of `HttpResponseSnapshot`
- **CORRECT:** Method MUST return `HttpResponseSnapshot` for caching to work
- **Why:** Caching interceptor works with `HttpResponseSnapshot`, not `HttpResponseMessage`

**‚ùå Wrong Registration Method**

- **WRONG:** Registering cached System Abstraction with `AddScoped` instead of `AddCachedService`
- **CORRECT:** Use `AddCachedService<TInterface, TImplementation>()` for cached services
- **Why:** `AddCachedService` wraps service with CachingInterceptor, `AddScoped` does not

**‚ùå Missing Redis Cache Library Registration**

- **WRONG:** Using `AddCachedService` without registering Redis Cache Library first
- **CORRECT:** Register `AddRedisCacheLibrary(builder.Configuration)` before System Abstractions
- **Why:** Redis is the cache storage backend - must be registered first

**‚ùå Unsorted List Properties in Cache Key**

- **WRONG:** Adding list properties to cache key without sorting
- **CORRECT:** Sort list properties before adding to cache key (for consistency)
- **Why:** Same data with different list order should generate same cache key

---

## 5. System Abstractions Rules

**üö® CRITICAL:** System Abstractions handle Process‚ÜíSystem Layer communication via HTTP calls. They are MANDATORY for all Process Layer implementations that call System Layer Functions.

### 5.1 System Abstractions - Pre-Creation Validation

**üõë PRE-CREATION VALIDATION (MANDATORY - STOP IF NOT COMPLETE)**

**üö® YOU CANNOT CREATE System Abstraction UNTIL:**

1. ‚úÖ **STOP AND VERIFY:** Have I identified which System Layer Function to call?
2. ‚úÖ **STOP AND VERIFY:** Do I have the System Layer Function URL in AppConfigs?
3. ‚úÖ **STOP AND VERIFY:** Have I verified I'm NOT adding SOR base URLs or resource paths to Process Layer AppConfigs? (SOR URL construction belongs in System Layer AppConfigs)
4. ‚úÖ **STOP AND VERIFY:** Have I read this section completely?
5. ‚úÖ **STOP AND VERIFY:** Do I know System Abstractions make HTTP calls (NOT project references)?
6. ‚úÖ **STOP AND VERIFY:** Do I know to use `SendProcessHTTPReqAsync()` extension method for HTTP calls?
7. ‚úÖ **STOP AND VERIFY:** Have I checked date/datetime field formats from Boomi JSON profile files (System Layer output profile) to ensure dates are formatted correctly for SOR API?
8. ‚úÖ **STOP AND VERIFY:** Do I understand the System Layer Function's response structure (BaseResponseDTO format, data property structure)?
9. ‚úÖ **STOP AND VERIFY:** Do I know how to map System Layer response to Process Layer response DTO (for ResponseDTOHelper)?
10. ‚úÖ **STOP AND VERIFY:** Have I checked Phase 1 document (Section 2: Process Properties Analysis) for HTTP headers and request parameters that the Boomi process reads?
11. ‚úÖ **STOP AND VERIFY:** Have I verified the System Layer DTO validation methods (`ValidateAPIRequestParameters()`, `ValidateDownStreamRequestParameters()`) to see which fields are REQUIRED?
12. ‚úÖ **STOP AND VERIFY:** Have I verified that ALL required System Layer DTO fields can be populated from available sources (Process Layer DTO, HTTP headers passed from Function, query parameters passed from Function, or config)?
13. ‚úÖ **STOP AND VERIFY:** Have I verified the correct source for each System Layer DTO field from Phase 1 document (NOT assuming one field can be populated from another field)?
14. ‚úÖ **STOP AND VERIFY:** Have I read System Layer Function's request DTO file to verify property names and required fields?
15. ‚úÖ **üî¥ CRITICAL:** Do I understand that dynamic request property names MUST match System Layer Function's request DTO property names EXACTLY?
16. ‚úÖ **üî¥ CRITICAL:** Do I understand that all required fields from System Layer Function's request DTO validation MUST be included in dynamic request?

**üõë IF ANY MISSING ‚Üí STOP ‚Üí Complete verification ‚Üí Then create System Abstraction**

**üî¥ MANDATORY WORKFLOW STEP 6: System Abstractions**

**üö® BEFORE creating System Abstractions (BLOCKING - CANNOT PROCEED WITHOUT COMPLETING):**

- [ ] **BLOCKING:** Did I complete WORKFLOW STEP 5 (Domains)?
- [ ] **BLOCKING:** Did I use `read_file` tool to read Section 5 (System Abstractions Rules)?
- [ ] **BLOCKING:** Did I find exact template/example in Section 5?
- [ ] **BLOCKING:** Did I copy template exactly before writing code?
- [ ] **BLOCKING:** Did I read "üõë PRE-CREATION VALIDATION" in Section 5?
- [ ] **BLOCKING:** Did I verify orchestration requirements from Phase 1 document?

**If you write code without reading Section 5 first ‚Üí DELETE code ‚Üí Read Section 5 ‚Üí Retry**

**Implementation:**
- [ ] Create System Abstraction interface
- [ ] Create System Abstraction implementation
- [ ] Verify System Abstraction uses `SendProcessHTTPReqAsync()` extension method
- [ ] Verify System Abstraction uses `await` (NOT `.Result`)
- [ ] Verify System Abstraction calls System Layer Function URL (not SOR URL)
- [ ] Verify System Abstraction implements interface
- [ ] Register System Abstraction with interface in Program.cs

**üõë IF ANY CHECKPOINT FAILS ‚Üí STOP ‚Üí Complete missing step ‚Üí Then proceed**

**üî¥ CRITICAL: PROCESS ORCHESTRATION VERIFICATION (MANDATORY)**

**üö® BEFORE implementing Process Layer code, you MUST verify orchestration requirements:**

1. ‚úÖ **Check Phase 1 document (Section 13: Process and System Layer Orchestration Diagram)** to identify ALL System Layer calls:
   - How many System Layer Functions are called in the success path?
   - How many System Layer Functions are called in the error path?
   - What is the execution order of System Layer calls?
   - Are there conditional System Layer calls (if/else branches)?

2. ‚úÖ **Check Phase 1 document (Section 7: Execution Order)** to identify orchestration requirements:
   - Are there multiple sequential System Layer operations?
   - Do System Layer operations depend on each other (output of one feeds into another)?
   - Are there error handling System Layer calls (e.g., notification services)?

3. ‚úÖ **Check Phase 1 document (Section 9: Subprocess Analysis)** to identify subprocess calls:
   - Are there subprocesses that translate to System Layer calls?
   - Do subprocesses need to be orchestrated in Process Layer?

4. ‚úÖ **Verify orchestration pattern:**
   - **Single System Layer call** ‚Üí Service directly calls System Abstraction (no orchestration needed)
   - **Multiple System Layer calls (business logic)** ‚Üí Service MUST orchestrate multiple System Abstraction calls (see Section 8.4: Services Rules - Handling Multiple Failures)
   - **Error handling System Layer calls (cross-cutting concerns)** ‚Üí Function ONLY MUST orchestrate error handling System Layer calls (Services MUST NOT orchestrate cross-cutting concerns - see Section 8.2: Service Separation Rule)

5. ‚úÖ **üî¥ CRITICAL: NEVER miss error handling orchestration:**
   - If Phase 1 shows System Layer call on error ‚Üí Function MUST call that System Layer System Abstraction in error path (using `else` block, NOT try-catch)
   - If Phase 1 shows multiple error handling steps ‚Üí Function MUST orchestrate all error handling System Layer calls
   - **Source of truth:** Phase 1 document (Section 13: Orchestration Diagram) shows error handling System Layer calls
   - **üö® MANDATORY:** Review Section 2.7 (Azure Functions - Error Handling & Orchestration) for detailed error handling checklist
   - **üî¥ CRITICAL:** Error handling orchestration is Function responsibility ONLY - Services MUST NOT orchestrate cross-cutting concerns like error notifications (violates Service Separation Rule - Section 8.2)

6. ‚úÖ **üî¥ CRITICAL: Verify ALL properties used in error handling subprocesses (Phase 1 Section 9):**
   - **STOP:** Check Phase 1 Section 9 (Subprocess Analysis) - "Properties Read" table for error handling subprocesses
   - **STOP:** For EACH property listed in "Properties Read" table (e.g., `process.DPP_<PropertyName>`):
     - [ ] Did I identify the source of this property from Phase 1 Section 2 (Process Properties Analysis)?
     - [ ] Did I extract/populate this property in the error path?
     - [ ] Did I pass this property to the error handling Service/System Abstraction?
   - **STOP:** If Phase 1 Section 9 shows email subprocess uses attachment properties:
     - [ ] Did I extract request payload (`process.DPP_<PayloadProperty>`) for attachment content?
     - [ ] Did I construct attachment filename (`process.DPP_<FileNameProperty>`) according to Phase 1 Section 2 format?
     - [ ] Did I determine `<DecisionProperty>` via code logic (not AppConfigs) if used in decision shape?
   - **STOP:** Verify ALL properties from Phase 1 Section 9 are populated and passed correctly
   - ‚úÖ **CORRECT:** Error path extracts request payload: `string attachmentContent = JsonSerializer.Serialize(<RequestDTO>);`
   - ‚úÖ **CORRECT:** Error path constructs filename: `string attachmentFileName = $"{_options.<FileNameProperty>}{DateTime.UtcNow:yyyy-MM-ddTHH:mm:ss.fffZ}.txt";`
   - ‚ùå **WRONG:** Error path passes `attachmentFileName: null, attachmentContent: null` when Phase 1 Section 9 shows these properties are required
   - ‚ùå **WRONG:** Error path doesn't extract request payload when Phase 1 Section 9 shows `process.DPP_<PayloadProperty>` is used
   - **üî¥ CRITICAL:** Phase 1 Section 9 (Subprocess Analysis) is the source of truth for ALL properties used in error handling subprocesses
   - **üî¥ CRITICAL:** ALL properties listed in Phase 1 Section 9 "Properties Read" table MUST be populated and passed correctly
   - **üî¥ CRITICAL:** Never use try catch while generating code

**Example Orchestration Verification:**
```
Phase 1 Section 13 shows:
  - Success path: <SOR> API call (1 System Layer call) ‚Üí ‚úÖ Single call, no orchestration needed
  - Error path: <ErrorHandlingSOR> API call (1 System Layer call) ‚Üí ‚úÖ Error handling orchestration required

Current implementation:
  - Service only calls <SOR> ‚Üí ‚ùå MISSING: <ErrorHandlingSOR> call on error
  - Fix: Add error handling System Layer orchestration in Function catch block or Service error handling
```

**üî¥ CRITICAL: System Layer DTO Field Source Verification**

**üö® BEFORE creating System Abstraction, you MUST verify field sources:**

1. ‚úÖ **üî¥ MANDATORY: Read System Layer DTO file FIRST** - You CANNOT proceed without this:
   - [ ] **BLOCKING:** Did I use `read_file` tool to read the complete System Layer DTO file?
   - [ ] **BLOCKING:** Did I identify ALL required fields from validation methods?
   - [ ] **BLOCKING:** Did I document the required fields in verification checklist?
   - **Check System Layer DTO validation methods** to identify REQUIRED fields:
     - Read `ValidateAPIRequestParameters()` or `ValidateDownStreamRequestParameters()` methods
     - Fields that throw `RequestValidationFailureException` if missing are REQUIRED
     - Example: If `<FieldName>` validation throws exception when null/empty, it's REQUIRED
   - **Check DTO structure:**
     - Identify nested objects (e.g., `@params` wrapper)
     - Identify arrays and their structure
     - Identify property names (exact casing, naming conventions)

2. ‚úÖ **Check Phase 1 document (Section 2: Process Properties Analysis)** to identify data sources:
   - **üî¥ CRITICAL: Check "Source Type" field in Phase 1 Section 2 for EACH property:**
     - **`Source Type: trackparameter`** ‚Üí Property comes from HTTP request (header, query parameter, or request body)
       - If property name contains `inheader_` ‚Üí HTTP header (read in Function from `req.Headers`), design it to read it from headers, create it as a part of DTO and pass it to system layer in request DTO
       - If property name contains `inquery_` ‚Üí Query parameter (read in Function from `req.Query`), design it to read it from query, create it as a part of DTO and pass it to system layer in request DTO
       - If property name contains `indocument_` ‚Üí Request body field (in DTO)
     - **`Source Type: definedparameter`** ‚Üí Property comes from Boomi defined parameter (configuration)
       - **üî¥ CRITICAL FIRST CHECK: Is this used in a decision shape?**
         - **STOP:** Check Phase 1 Section 3 (Decision Shape Analysis) or subprocess JSON files for `shapetype: "decision"` that uses this property
         - **If used in decision shape** ‚Üí ‚úÖ **Code Logic (NOT AppConfigs)** - Determine via code logic based on actual data (e.g., `bool hasAttachment = !string.IsNullOrWhiteSpace(attachmentFileName) && !string.IsNullOrWhiteSpace(attachmentContent);`)
         - **Why:** Decision shapes represent runtime conditional logic, not static configuration. The decision should be made by code based on actual data availability.
         - **If NOT used in decision shape** ‚Üí Continue to next check
       - **üî¥ CRITICAL: Determine which layer needs this configuration:**
         - **STOP:** Check Phase 1 Section 11 (System Configuration Table) and Section 13 (Orchestration Diagram) to see where this property is used
         - **If used to construct SOR (external system) URLs** ‚Üí ‚ùå **DO NOT add to Process Layer AppConfigs** - This belongs in System Layer AppConfigs
           - **Example:** `<ResourcePath>` used to build `<SOR>` API URL ‚Üí System Layer constructs `<SOR>` URL internally ‚Üí `<ResourcePath>` belongs in System Layer AppConfigs, NOT Process Layer
           - **Rule:** Process Layer calls System Layer Functions via HTTP. System Layer constructs SOR URLs internally using its own AppConfigs.
         - **If used for Process Layer configuration** ‚Üí ‚úÖ Add to Process Layer AppConfigs
           - **Example:** System Layer Function URL (e.g., `https://<system-layer-function-url>/api/<operation>`), email addresses for Process Layer notifications
       - **üî¥ CRITICAL RULE - URL CONSTRUCTION SEPARATION:**
         - ‚úÖ **Process Layer AppConfigs:** ONLY System Layer Function URLs (complete Azure Function endpoints)
         - ‚ùå **Process Layer AppConfigs:** NEVER SOR API URLs, SOR base URLs, SOR resource paths, or any SOR URL construction components
         - ‚úÖ **System Layer AppConfigs:** SOR base URLs, SOR resource paths, SOR API construction details
         - **Architectural Principle:** Process Layer System Abstraction calls System Layer Function URL. System Layer Function internally constructs SOR API URL using System Layer AppConfigs.
       - **If adding to Process Layer AppConfigs:**
         - MUST be added to ALL environment files: `appsettings.json`, `appsettings.dev.json`, `appsettings.qa.json`, `appsettings.stg.json`, `appsettings.prod.json`, `appsettings.dr.json`
         - MUST be injected via `IOptions<AppConfigs>` in Function/Service
         - Check component JSON file for default value (e.g., `component_*.json` shows `defaultValue`)
       - ‚ùå **NEVER read from HTTP headers** - Defined parameters are configuration, not request data
       - ‚ùå **NEVER add to DTO** - Defined parameters are configuration, not request data
     - **`Source Type: processparameter`** ‚Üí Property comes from process property (runtime, not config)
   - HTTP headers that Boomi process reads (e.g., `<header-name>` header ‚Üí `process.DPP_<property-name>`)
   - Request parameters that Boomi process reads (e.g., `<parameter-name>` parameter ‚Üí `dynamicdocument.<property-name>`)
   - How these headers/parameters are used in the Boomi process flow
   - **üî¥ MANDATORY CHECKLIST for each property in Phase 1 Section 2:**
     1. Read the "Source Type" field
     2. If "definedparameter" ‚Üí **STOP:** 
        - **FIRST:** Check Phase 1 Section 3 (Decision Shape Analysis) or subprocess JSON - Is this property used in a decision shape?
          - **If YES** ‚Üí ‚úÖ **Code Logic (NOT AppConfigs)** - Determine via code logic based on actual data
          - **If NO** ‚Üí Continue to next step
        - **SECOND:** Check which layer needs it (Process Layer or System Layer)
          - If used for SOR URL construction ‚Üí System Layer AppConfigs (NOT Process Layer)
          - If used for Process Layer configuration ‚Üí Process Layer AppConfigs
     3. If "trackparameter" with "inheader_" ‚Üí Read from req.Headers in Function, create it as a part of DTO and pass it to system layer in request DTO
     4. If "trackparameter" with "inquery_" ‚Üí Read from req.Query in Function, create it as a part of DTO and pass it to system layer in request DTO
     5. If "trackparameter" with "indocument_" ‚Üí Add to DTO request body structure

3. ‚úÖ **Verify field mapping sources** - For each REQUIRED System Layer DTO field, verify the source:
   - **Request body fields** ‚Üí Map from Process Layer DTO to System Layer DTO
   - **HTTP headers** ‚Üí Read from `HttpRequest.Headers` in Function, create it as a part of DTO and pass it to system layer in request DTO
   - **Query parameters** ‚Üí Read from `HttpRequest.Query` in Function, create it as a part of DTO and pass it to system layer in request DTO
   - **Config values** ‚Üí Use from `AppConfigs` in System Abstraction

4. ‚úÖ **üî¥ CRITICAL: NEVER assume field mapping** - Always verify the correct source:
   - ‚ùå **WRONG:** Using `dto.<SomeField>` for `<AnotherField>` without verifying from Phase 1
   - ‚úÖ **CORRECT:** Reading `<header-name>` header in Function, passing to System Abstraction, mapping to `<FieldName>` in System Layer DTO
   - **Source of truth:** Phase 1 document (Section 2: Process Properties Analysis) shows how Boomi process reads headers/parameters

**Example Verification Pattern:**
```
System Layer DTO requires: <FieldName> (validated in ValidateAPIRequestParameters())
Phase 1 Section 2 shows: Boomi process reads "<header-name>" header ‚Üí process.DPP_<property-name>
Solution: Function reads req.Headers["<header-name>"], passes to System Abstraction, maps to <FieldName>
```

**üî¥ CRITICAL:** Before implementing Process Layer response mapping, you MUST:
- Review the System Layer Function's Handler to understand what `BaseResponseDTO` structure it returns
- Review the System Layer Function's response DTOs to understand the `data` property structure
- Understand how the System Layer maps downstream API responses to its response DTOs
- This knowledge is REQUIRED to correctly implement `ResponseDTOHelper.Populate*()` methods in Process Layer

### 5.2 System Abstractions - Architecture & Patterns

**üî¥ MANDATORY ARCHITECTURE RULE - NEVER VIOLATE:**

- ‚úÖ **Process Layer calls System Layer via HTTP** (Azure Function to Azure Function)
- ‚ùå **NEVER add project references to System Layer projects** in Process Layer .csproj
- ‚ùå **NEVER register System Layer services/handlers** in Process Layer Program.cs
- ‚ùå **NEVER inject System Layer services directly** in Process Layer
- ‚úÖ **ONLY register System Abstractions** that make HTTP calls to System Layer Functions
- **üî¥ CRITICAL: URL CONSTRUCTION SEPARATION:**
  - ‚úÖ **Process Layer System Abstraction:** Calls System Layer Function URL (complete Azure Function endpoint from Process Layer AppConfigs)
  - ‚ùå **Process Layer System Abstraction:** NEVER constructs SOR API URLs, NEVER uses SOR base URLs or resource paths
  - ‚úÖ **System Layer:** Constructs SOR API URLs internally using System Layer AppConfigs (base URL + resource path)
  - **Example:**
    - ‚úÖ **Process Layer AppConfigs:** `<Operation>Url = "https://<system-layer-function-url>/api/<operation>"` (System Layer Function URL)
    - ‚ùå **Process Layer AppConfigs:** `<SOR>BaseUrl`, `<SOR>ResourcePath` (SOR URL construction - belongs in System Layer AppConfigs)
    - ‚úÖ **System Layer AppConfigs:** `<SOR>BaseUrl = "https://<sor-base-url>"`, `<SOR>ResourcePath = "/api/services/..."` (SOR URL construction)

**‚ùå WRONG PATTERN (DO NOT USE):**

```csharp
// ‚ùå WRONG - Process Layer .csproj
<ProjectReference Include="..\SystemLayerProject\SystemLayerProject.csproj" />

// ‚ùå WRONG - Process Layer Program.cs
services.AddScoped<ISystemLayerService, SystemLayerService>();  // System Layer service
services.AddScoped<SystemLayerHandler>();  // System Layer handler

// ‚ùå WRONG - System Abstraction calling System Layer service directly
public class <Entity>MgmtSys : I<Entity>Mgmt {
    private readonly ISystemLayerService _systemLayerService;  // ‚ùå Direct service injection
    public async Task<HttpResponseSnapshot> CreateEntity(...) {
        return await _systemLayerService.CreateEntity(...);  // ‚ùå Direct call
    }
}
```

**‚úÖ CORRECT PATTERN (MANDATORY):**

```csharp
// ‚úÖ CORRECT - Process Layer .csproj (NO System Layer references)
<ItemGroup>
  <ProjectReference Include="..\Framework\Core\Core\Core.csproj" />
  <!-- ‚ùå NO System Layer project references -->
</ItemGroup>

// ‚úÖ CORRECT - Process Layer Program.cs (ONLY System Abstractions)
services.AddScoped<I<Entity>Mgmt, <Entity>MgmtSys>();  // System Abstraction only

// ‚úÖ CORRECT - System Abstraction making HTTP call to System Layer Function
public class <Entity>MgmtSys : I<Entity>Mgmt {
    private readonly AppConfigs _options;
    private readonly CustomHTTPClient _customHttpClient;  // ‚úÖ HTTP client
    private readonly ILogger<<Entity>MgmtSys> _logger;
    
    public <Entity>MgmtSys(IOptions<AppConfigs> o, CustomHTTPClient c, ILogger<<Entity>MgmtSys> l) {
        _options = o.Value; _customHttpClient = c; _logger = l;
    }
    
    public async Task<HttpResponseMessage> CreateEntity(<Entity>Domain domain) {
        string url = _options.CreateEntityUrl;  // ‚úÖ System Layer Function URL from config
        // ‚úÖ Direct call - SendProcessHTTPReqAsync automatically adds TestRunId/RequestId headers
        // No helper methods needed - extension method handles everything
        HttpResponseMessage response = await _customHttpClient.SendProcessHTTPReqAsync(
            method: HttpMethod.Post, 
            url: url, 
            contentType: "application/json", 
            body: request, 
            reqHeaders: null);
        return response;  // ‚úÖ HTTP call to System Layer Function
    }
}
```

### 5.3 System Abstractions - Structure & Patterns

**üî¥ CRITICAL: System Abstraction Class Separation Rule (MANDATORY - NEVER VIOLATE)**

**üö® System Abstraction classes MUST be separated by business domain/entity, NOT by SOR (System of Record):**

- ‚úÖ **CORRECT:** Each business domain/entity has its own System Abstraction class
  - `<Entity1>MgmtSys` ‚Üí Contains ONLY `<Entity1>`-related operations (e.g., `Create<Entity1>`, `Get<Entity1>Details`)
  - `<Entity2>MgmtSys` ‚Üí Contains ONLY `<Entity2>`-related operations (e.g., `Create<Entity2>`, `Update<Entity2>`)
  - Both can be in the same SOR directory (`SystemAbstractions/<SOR>Mgmt/`) since they connect to the same SOR
- ‚ùå **WRONG:** Mixing different business domains/entities in the same System Abstraction class
  - `<Entity1>MgmtSys` containing both `<Entity1>` operations AND `<Entity2>` operations
  - `<SOR>MgmtSys` containing all `<SOR>` operations regardless of business domain

**Why:**
- **Separation of Concerns:** Each business domain/entity has its own lifecycle, requirements, and potential changes
- **Maintainability:** Changes to `<Entity1>` operations don't affect `<Entity2>` operations and vice versa
- **Clarity:** Class names clearly indicate which business domain/entity they handle
- **Single Responsibility:** Each System Abstraction class has a single, well-defined responsibility

**Rule:**
- ‚úÖ **One System Abstraction class per business domain/entity** (e.g., `<Entity1>MgmtSys`, `<Entity2>MgmtSys`, `<Entity3>MgmtSys`)
- ‚úÖ **Multiple System Abstraction classes can exist in the same SOR directory** (e.g., `SystemAbstractions/<SOR>Mgmt/<Entity1>MgmtSys.cs` and `SystemAbstractions/<SOR>Mgmt/<Entity2>MgmtSys.cs`)
- ‚úÖ **System Abstraction class name reflects the business domain/entity** (e.g., `<Entity2>MgmtSys` for `<Entity2>` operations, NOT `<Entity1>MgmtSys`)
- ‚ùå **NEVER add operations from different business domains/entities to the same System Abstraction class**

**Examples:**
- ‚úÖ **CORRECT:** `<Entity1>MgmtSys` contains `Create<Entity1>()`, `Get<Entity1>Details()` (both `<Entity1>` operations)
- ‚úÖ **CORRECT:** `<Entity2>MgmtSys` contains `Create<Entity2>()` (`<Entity2>` operation)
- ‚úÖ **CORRECT:** Both `<Entity1>MgmtSys.cs` and `<Entity2>MgmtSys.cs` in `SystemAbstractions/<SOR>Mgmt/` directory
- ‚ùå **WRONG:** `<Entity1>MgmtSys` containing `<Entity2>` operations (different business domain/entity)
- ‚ùå **WRONG:** `<SOR>MgmtSys` containing all `<SOR>` operations (mixing business domains)

**System Abstraction Pattern (Standard):**

```csharp
public interface I<Entity>Mgmt {
    Task<HttpResponseMessage> CreateEntity(<Entity>Domain domain);
}

public class <Entity>MgmtSys : I<Entity>Mgmt {
    private readonly AppConfigs _options;
    private readonly CustomHTTPClient _customHttpClient;  // ‚úÖ HTTP client for System Layer calls
    private readonly ILogger<<Entity>MgmtSys> _logger;
    
    public <Entity>MgmtSys(IOptions<AppConfigs> o, CustomHTTPClient c, ILogger<<Entity>MgmtSys> l) { 
        _options = o.Value; _customHttpClient = c; _logger = l; 
    }
    
    public async Task<HttpResponseMessage> CreateEntity(<Entity>Domain domain) {
        // ‚úÖ Build dynamic request payload
        dynamic req = new ExpandoObject();
        req.Name = domain.PropertyA;
        req.Status = domain.Details?.Code;
        
        // ‚úÖ Direct call to SendProcessHTTPReqAsync - no helper methods needed
        // Extension method automatically adds TestRunId/RequestId headers and handles JSON serialization
        string url = _options.CreateEntityUrl;  // ‚úÖ System Layer Function URL from AppConfigs
        return await _customHttpClient.SendProcessHTTPReqAsync(
            method: HttpMethod.Post, 
            url: url, 
            contentType: "application/json", 
            body: (object)req, 
            reqHeaders: null);
    }
}
```

**Key Points:**
- ‚úÖ MUST implement interface
- ‚úÖ MUST inject `CustomHTTPClient` for HTTP calls
- ‚úÖ MUST inject `IOptions<AppConfigs>` for System Layer Function URLs
- ‚úÖ MUST use `SendProcessHTTPReqAsync()` extension method
- ‚úÖ MUST use `await` (NEVER `.Result`, `.Wait()`, or `.GetAwaiter().GetResult()`)
- ‚úÖ Builds dynamic request using `ExpandoObject`
- ‚úÖ Calls System Layer Function URL (not SOR URL)
- ‚úÖ Logs at start and end of method (simple logging)
- ‚úÖ Returns `HttpResponseMessage` directly
- ‚úÖ **üî¥ CRITICAL:** One System Abstraction class per business domain/entity (e.g., `<Entity1>MgmtSys` for `<Entity1>`, `<Entity2>MgmtSys` for `<Entity2>`)
- ‚ùå **NEVER checks response status codes** (Service/Function responsibility)
- ‚ùå **NEVER extracts error details from response** (Service/Function responsibility)
- ‚ùå **NEVER logs based on response status** (Service/Function responsibility)
- ‚ùå **NEVER mix different business domains/entities in the same System Abstraction class**

**üî¥ CRITICAL: Request Payload Alignment Rule (MANDATORY - NEVER VIOLATE)**

**üö® System Abstraction dynamic request MUST align EXACTLY with System Layer Function's request DTO structure:**
- ‚úÖ **MUST match property names** - Dynamic request property names MUST match System Layer Function's request DTO property names exactly
- ‚úÖ **MUST include all required fields** - All required fields from System Layer Function's request DTO validation MUST be included
- ‚úÖ **MUST verify field mapping** - Before creating dynamic request, MUST read System Layer Function's request DTO to verify property names and required fields
- ‚úÖ **MUST verify from System Layer repository** - Source of truth is System Layer Function's request DTO file (e.g., `<Operation>ReqDTO.cs`)
- ‚úÖ **MUST open and read System Layer DTO file** - Cannot validate without opening the actual System Layer DTO file
- ‚úÖ **MUST compare every property** - For each property in System Layer DTO, verify it exists in dynamic request with exact same name
- ‚úÖ **MUST compare every dynamic property** - For each property in dynamic request, verify it exists in System Layer DTO with exact same name
- ‚ùå **NEVER assume property names** - Property names in dynamic request MUST match System Layer DTO exactly
- ‚ùå **NEVER skip required fields** - All required fields from System Layer DTO validation MUST be populated
- ‚ùå **NEVER use different property names** - Cannot use Process Layer DTO property names if they differ from System Layer DTO property names

**Example:**
```csharp
// System Layer Function DTO: <Operation>ReqDTO
// Properties: RequiredField1, RequiredField2, OptionalField1, OptionalField2, etc.

// ‚úÖ CORRECT: Dynamic request matches System Layer DTO property names exactly
dynamic dynamicReq = new ExpandoObject();
dynamicReq.RequiredField1 = dto.RequiredField1;           // Matches System Layer DTO
dynamicReq.RequiredField2 = dto.NestedObject.Field2;      // Matches System Layer DTO
dynamicReq.SystemLayerFieldName = dto.ProcessLayerFieldName;   // Matches System Layer DTO (mapped from Process Layer DTO)
dynamicReq.AnotherSystemField = dto.AnotherProcessField;  // Matches System Layer DTO (mapped from Process Layer DTO)

// ‚ùå WRONG: Using Process Layer DTO property names that don't match System Layer DTO
dynamicReq.ProcessLayerFieldName = dto.ProcessLayerFieldName;  // System Layer expects "SystemLayerFieldName", not "ProcessLayerFieldName"
dynamicReq.AnotherProcessField = dto.AnotherProcessField;       // System Layer expects "AnotherSystemField", not "AnotherProcessField"
```

**Why:** System Layer Function deserializes the request body into its request DTO. If property names don't match, fields will be null/missing, causing validation failures or incorrect data mapping.

### 5.4 System Abstractions - With Caching (HttpResponseSnapshot)

**üö® CACHING INTERCEPTOR:** Use `[CacheableService]` attribute to enable caching for System Layer responses.

```csharp
public class <Entity>MgmtSys : I<Entity>Mgmt {
    [CacheableService(Namespace = nameof(GetDetails))]  // Caching interceptor
    public async Task<HttpResponseSnapshot> GetDetails(<Entity>Info entity, string type) {
        dynamic req = new ExpandoObject();
        string url = _options.EntityDetailsUrl.Replace("{id}", entity.Code).Replace("{type}", type);
        // ‚úÖ Direct call - use await, NEVER use .Result
        HttpResponseMessage r = await _customHttpClient.SendProcessHTTPReqAsync(
            method: HttpMethod.Post, 
            url: url, 
            contentType: "application/json", 
            body: (object)req, 
            reqHeaders: null);
        return await HttpResponseSnapshot.FromAsync(r);
    }
}
```

**Key Rules (ONLY if caching is needed):**
- Return type MUST be `HttpResponseSnapshot` (not `HttpResponseMessage`)
- Use `[CacheableService(Namespace = nameof(MethodName))]` attribute (ONLY if caching is used)
- Domain MUST implement `ICacheable` interface for cache key generation (ONLY if caching is used)

**üî¥ CROSS-REFERENCE:** See Section 4 (Caching Rules) for complete caching pattern.

### 5.5 System Abstractions - HTTP Call Method (SendProcessHTTPReqAsync)

**üî¥ MANDATORY:** Use `SendProcessHTTPReqAsync()` extension method for ALL Process‚ÜíSystem Layer calls (System Abstractions) and ALL Process‚ÜíProcess Layer calls (Process Abstractions).

**Where it's used:**
- ‚úÖ **System Abstractions** - Process‚ÜíSystem Layer calls (Section 5)
- ‚úÖ **Process Abstractions** - Process‚ÜíProcess Layer calls (Section 6)

**Extension Method Signature:**

```csharp
public static Task<HttpResponseMessage> SendProcessHTTPReqAsync(
    this CustomHTTPClient client,
    HttpMethod method,
    string url,
    string contentType = "application/json",
    object? body = null,
    List<Tuple<string, string>>? reqHeaders = null
)
```

**Location:** `Framework/Core/Core/ProcessLayer/Extensions/CustomHttpClientExtensions.cs`

**Key Features:**
- ‚úÖ **Automatically adds technical headers:** TestRunId and RequestId are automatically added by the extension method
- ‚úÖ **JSON serialization:** Automatically serializes body to JSON if provided
- ‚úÖ **Content-Type handling:** Defaults to "application/json" but can be customized
- ‚úÖ **Optional headers:** Can pass additional headers via `reqHeaders` parameter

**Usage Pattern:**

```csharp
// ‚úÖ CORRECT - Direct call with await (technical headers added automatically, no helper methods needed)
// Used in: System Abstractions (Process‚ÜíSystem) and Process Abstractions (Process‚ÜíProcess)
public async Task<HttpResponseMessage> CreateEntity(<Entity>Domain domain) {
    dynamic req = new ExpandoObject();
    req.PropertyA = domain.PropertyA;
    req.PropertyB = domain.PropertyB;

    // ‚úÖ CORRECT - Use await, method must be async
    HttpResponseMessage response = await _customHttpClient.SendProcessHTTPReqAsync(
        method: HttpMethod.Post, 
        url: url, 
        contentType: "application/json", 
        body: (object)req, 
        reqHeaders: null);
    return response;
}

// ‚úÖ CORRECT - With additional business headers
public async Task<HttpResponseMessage> GetEntity(string id) {
    List<Tuple<string, string>> headers = new List<Tuple<string, string>> 
    { 
        Tuple.Create("x-custom-header", "value") 
    };
    // ‚úÖ CORRECT - Use await
    HttpResponseMessage response = await _customHttpClient.SendProcessHTTPReqAsync(
        method: HttpMethod.Post, 
        url: url, 
        contentType: "application/json", 
        body: (object)req, 
        reqHeaders: headers);
    return response;
}

// ‚ùå WRONG - Using .Result causes deadlocks and thread blocking
public Task<HttpResponseMessage> CreateEntity(<Entity>Domain domain) {
    HttpResponseMessage response = _customHttpClient.SendProcessHTTPReqAsync(...).Result;  // ‚ùå PROHIBITED
    return Task.FromResult(response);
}

// ‚ùå WRONG - Blocking async call
public HttpResponseMessage CreateEntity(<Entity>Domain domain) {
    HttpResponseMessage response = _customHttpClient.SendProcessHTTPReqAsync(...).GetAwaiter().GetResult();  // ‚ùå PROHIBITED
    return response;
}

// ‚ùå WRONG - Don't manually add TestRunId/RequestId (extension method does this)
List<Tuple<string, string>> h = new List<Tuple<string, string>> 
{ 
    RequestHeaders.TestRunId.Simplify(),  // ‚ùå Redundant - extension method adds this
    RequestHeaders.RequestId.Simplify()   // ‚ùå Redundant - extension method adds this
};
```

**üìò NOTE:** `.Simplify()` is a Framework extension function (`Core/Extensions/TupleExtension.cs`) that converts `Tuple<string, AsyncLocal<StringBuilder>>` to `Tuple<string, string>` by extracting the string value from AsyncLocal. It's used internally by the extension method to prepare RequestHeaders.

### 5.6 System Abstractions - Date/DateTime Format Handling

**üî¥ CRITICAL: Date/DateTime Format Requirements**

**MANDATORY CHECK:**
- ‚úÖ **ALWAYS check Boomi JSON profile files** for date/datetime field formats before implementing System Abstraction
- ‚úÖ **Check the System Layer output profile** (the profile that maps to SOR API) for `ProfileDateFormat` with `dateFormat` attribute
- ‚úÖ **Document date format in Phase 1** if not already documented (e.g., `"yyyy-MM-dd"`, `"yyyy-MM-dd'T'HH:mm:ss"`, `"yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"`)

**How to Find Date Format in Boomi JSON Profile:**
1. Locate the System Layer output profile JSON file (the profile that maps to SOR API)
2. Find the date/datetime field in the profile
3. Look for `DataFormat` ‚Üí `ProfileDateFormat` ‚Üí `dateFormat` attribute
4. Example: `"dateFormat": "yyyy-MM-dd"` means dates must be formatted as `"2024-01-15"`

**System Abstraction Implementation:**
- ‚úÖ **Format dates according to SOR API requirements** before sending to System Layer
- ‚úÖ **Use the format specified in Boomi JSON profile** (found in `ProfileDateFormat.dateFormat`)
- ‚úÖ **Document the format in Phase 1** if not already documented

**Example:**

```csharp
// If Boomi JSON profile shows: "dateFormat": "yyyy-MM-dd"
// System Abstraction must format dates accordingly:
dynamic dynamicReq = new ExpandoObject();
dynamicReq.StartDate = DateTime.Parse(dto.StartDate).ToString("yyyy-MM-dd");  // ‚úÖ Format according to SOR requirement
dynamicReq.EndDate = DateTime.Parse(dto.EndDate).ToString("yyyy-MM-dd");      // ‚úÖ Format according to SOR requirement
```

**Source of Truth:**
1. **Boomi JSON Profile Files** - Check `ProfileDateFormat.dateFormat` in System Layer output profile
2. **Phase 1 Document** - Should document date formats if found in Boomi profiles
3. **System Layer API Documentation** - If available, cross-reference with Boomi profile format

### 5.7 System Abstractions - Key Rules

**üö® CRITICAL:** System Abstractions MUST implement interfaces and be injected via interface in Services.

| Component | Pattern | Usage |
|-----------|---------|-------|
| **Interface** | `public interface I<Entity>Mgmt` | ‚úÖ MANDATORY - All System Abstractions must have interfaces |
| **Implementation** | `public class <Entity>MgmtSys : I<Entity>Mgmt` | ‚úÖ MANDATORY - Must implement interface |
| **Injection in Service** | `private readonly I<Entity>Mgmt _entityMgmt;` | ‚úÖ MANDATORY - Inject via interface |
| **Registration** | `builder.Services.AddScoped<I<Entity>Mgmt, <Entity>MgmtSys>();` | ‚úÖ MANDATORY - Register with interface |
| **Request Building** | `ExpandoObject` for dynamic requests | Field mapping |
| **URL Parameters** | `string.Replace("{param}", value)` | Parameter substitution |
| **Headers** | TestRunId, RequestId (automatically added by extension method) | Technical tracing |
| **Return Type** | `HttpResponseMessage` or `HttpResponseSnapshot` | Standard or cached |
| **Caching** | `[CacheableService]` attribute | Cacheable operations (see Section 4) |
| **HTTP Method** | `CustomHTTPClient.SendProcessHTTPReqAsync()` (extension method) | System Layer calls - automatically adds TestRunId/RequestId headers |
| **Async Pattern** | **MUST use `await`** - NEVER use `.Result`, `.Wait()`, or `.GetAwaiter().GetResult()` | Prevents deadlocks and thread blocking |
| **URL Source** | System Layer Function URL from Process Layer AppConfigs | Complete Azure Function endpoint |
| **SOR URL Construction** | ‚ùå **NEVER** - System Layer constructs SOR URLs internally | Process Layer does NOT construct SOR URLs |

**üî¥ CRITICAL RULES:**

1. ‚úÖ System Abstractions MUST implement interfaces
2. ‚úÖ System Abstractions MUST be registered with interface in Program.cs
3. ‚úÖ System Abstractions MUST use `SendProcessHTTPReqAsync()` extension method
4. ‚úÖ System Abstractions MUST use `await` (NEVER `.Result`, `.Wait()`, or `.GetAwaiter().GetResult()`)
5. ‚úÖ System Abstractions MUST call System Layer Function URL (not SOR URL)
6. ‚úÖ **üî¥ CRITICAL:** Dynamic request property names MUST match System Layer Function's request DTO property names EXACTLY (MUST verify from System Layer repository)
7. ‚úÖ **üî¥ CRITICAL:** All required fields from System Layer Function's request DTO validation MUST be included in dynamic request
8. ‚úÖ **üî¥ CRITICAL:** System Abstractions do NOT check response status codes (Service/Function responsibility)
9. ‚úÖ **üî¥ CRITICAL:** System Abstractions do NOT extract error details from response (Service/Function responsibility)
10. ‚úÖ **üî¥ CRITICAL:** System Abstractions do NOT log based on response status (Service/Function responsibility)
11. ‚úÖ System Abstractions log at start and end of method (simple logging only)
12. ‚úÖ System Abstractions return `HttpResponseMessage` directly (no status checking or error extraction)
6. ‚úÖ Process Layer AppConfigs contains ONLY System Layer Function URLs (not SOR URLs)
7. ‚ùå **NEVER** add project references to System Layer projects
8. ‚ùå **NEVER** register System Layer services/handlers in Process Layer
9. ‚ùå **NEVER** inject System Layer services directly
10. ‚ùå **NEVER** construct SOR API URLs in Process Layer
11. ‚ùå **NEVER** use SOR base URLs or resource paths in Process Layer AppConfigs

### 5.8 System Abstractions - Post-Creation Validation

**üõë POST-CREATION VALIDATION (MANDATORY - VERIFY BEFORE PROCEEDING)**

**üö® AFTER creating System Abstraction, you MUST verify (BLOCKING - CANNOT SAVE FILE UNTIL ALL PASS):**

**üî¥ MANDATORY VIOLATION CHECKS (RUN BEFORE SAVING FILE):**
- [ ] **BLOCKING:** Run `grep -n "<SOR>SystemBaseUrl\|<SOR>BaseUrl\|SORBaseUrl\|ResourcePath" <file>` ‚Üí If found ‚Üí **VIOLATION** ‚Üí System Abstraction must NOT construct SOR URLs ‚Üí Fix ‚Üí Retry
- [ ] **BLOCKING:** Run `grep -n "\\.Result\\|\\.Wait()\\|\\.GetAwaiter()" <file>` ‚Üí If found ‚Üí **VIOLATION** ‚Üí Must use `await` ‚Üí Fix ‚Üí Retry
- [ ] **BLOCKING:** Verify System Abstraction calls System Layer Function URL (NOT SOR URL)
- [ ] **BLOCKING:** Open System Layer Function's request DTO file
- [ ] **BLOCKING:** Read ALL property definitions (lines with `public` properties) ‚Üí Document all property names
- [ ] **BLOCKING:** For EACH property in System Layer DTO: Check if it exists in dynamic request with EXACT same property name (case-sensitive) ‚Üí If mismatch ‚Üí **VIOLATION** ‚Üí Fix ‚Üí Retry
- [ ] **BLOCKING:** For EACH property in dynamic request: Check if it exists in System Layer DTO with EXACT same property name (case-sensitive) ‚Üí If mismatch ‚Üí **VIOLATION** ‚Üí Fix ‚Üí Retry
- [ ] **BLOCKING:** Read System Layer Function's request DTO validation method (e.g., `ValidateAPIRequestParameters()` or `ValidateDownStreamRequestParameters()`)
- [ ] **BLOCKING:** Identify ALL required fields (fields that throw validation errors if null/empty) ‚Üí Document all required fields
- [ ] **BLOCKING:** For EACH required field: Verify it is included in dynamic request ‚Üí If missing ‚Üí **VIOLATION** ‚Üí Fix ‚Üí Retry
- [ ] **BLOCKING:** For EACH required field: Verify it is populated (not null/empty) or has a valid source ‚Üí If not populated ‚Üí **VIOLATION** ‚Üí Fix ‚Üí Retry

1. ‚úÖ **STOP AND VERIFY:** System Abstraction calls System Layer Function URL from Process Layer AppConfigs (complete Azure Function endpoint)
2. ‚úÖ **üî¥ CRITICAL:** System Abstraction does NOT construct SOR API URLs, does NOT use SOR base URLs or resource paths
3. ‚úÖ **üî¥ CRITICAL:** Process Layer AppConfigs contains ONLY System Layer Function URLs, NOT SOR base URLs or resource paths
4. ‚úÖ **STOP AND VERIFY:** System Abstraction uses `SendProcessHTTPReqAsync()` extension method (NOT direct HTTP calls)
5. ‚úÖ **STOP AND VERIFY:** System Abstraction uses `await` (NOT `.Result`, `.Wait()`, or `.GetAwaiter().GetResult()`)
6. ‚úÖ **STOP AND VERIFY:** System Abstraction implements interface and is registered with interface in Program.cs
7. ‚úÖ **STOP AND VERIFY:** Date/datetime fields are formatted according to Boomi JSON profile requirements
8. ‚úÖ **STOP AND VERIFY:** All required System Layer DTO fields are populated from correct sources (verified from Phase 1)
9. ‚úÖ **üî¥ CRITICAL:** Dynamic request property names match System Layer Function's request DTO property names EXACTLY (verified from System Layer repository)
10. ‚úÖ **üî¥ CRITICAL:** All required fields from System Layer Function's request DTO validation are included in dynamic request
11. ‚úÖ **üî¥ CRITICAL:** System Abstraction does NOT check response status codes (Service/Function responsibility)
12. ‚úÖ **üî¥ CRITICAL:** System Abstraction does NOT extract error details from response (Service/Function responsibility)
13. ‚úÖ **üî¥ CRITICAL:** System Abstraction does NOT log based on response status (Service/Function responsibility)
14. ‚úÖ System Abstraction logs at start and end of method (simple logging only)
15. ‚úÖ System Abstraction returns `HttpResponseMessage` directly (no status checking or error extraction)

**üõë IF ANY VIOLATION ‚Üí STOP ‚Üí Fix System Abstraction ‚Üí Then proceed**

### 5.9 System Abstractions - Common Mistakes

**‚ùå Adding SOR URL Construction Components to Process Layer AppConfigs**

- **WRONG:** Adding `<SOR>BaseUrl`, `<SOR>ResourcePath`, or any SOR URL construction components to Process Layer AppConfigs
- **CORRECT:** Process Layer AppConfigs contains ONLY System Layer Function URLs (complete Azure Function endpoints)
- **Why:** Process Layer calls System Layer Functions via HTTP. System Layer constructs SOR URLs internally using System Layer AppConfigs.

**‚ùå Using .Result or Blocking Async Calls**

- **WRONG:** Using `.Result`, `.Wait()`, or `.GetAwaiter().GetResult()` on async calls
- **CORRECT:** Always use `await` in async methods
- **Why:** Blocking async calls causes deadlocks and thread blocking. Always use `await`.

**‚ùå Manually Adding TestRunId/RequestId Headers**

- **WRONG:** Manually adding `RequestHeaders.TestRunId.Simplify()` and `RequestHeaders.RequestId.Simplify()` to headers
- **CORRECT:** `SendProcessHTTPReqAsync()` extension method automatically adds these headers
- **Why:** Extension method handles technical headers automatically - no need to add them manually.

**‚ùå Not Implementing Interface**

- **WRONG:** Creating System Abstraction without interface
- **CORRECT:** System Abstraction MUST implement interface and be registered with interface
- **Why:** Services inject System Abstractions via interface - interface is mandatory.

**‚ùå Wrong Return Type for Caching**

- **WRONG:** Using `HttpResponseMessage` when caching is needed
- **CORRECT:** Use `HttpResponseSnapshot` for cached methods
- **Why:** Caching interceptor works with `HttpResponseSnapshot`, not `HttpResponseMessage`.

**‚ùå Not Formatting Dates According to SOR Requirements**

- **WRONG:** Sending dates in wrong format without checking Boomi JSON profile
- **CORRECT:** Always check Boomi JSON profile for date format requirements and format dates accordingly
- **Why:** SOR APIs have specific date format requirements - must match exactly.

**‚ùå Assuming Field Mapping Without Verification**

- **WRONG:** Using `dto.<SomeField>` for `<AnotherField>` without verifying from Phase 1
- **CORRECT:** Always verify field sources from Phase 1 document (Section 2: Process Properties Analysis)
- **Why:** Field sources must be verified - cannot assume one field can populate another.

**‚ùå Request Payload Not Aligned with System Layer Function DTO**

- **WRONG:** Dynamic request property names don't match System Layer Function's request DTO property names
- **WRONG:** Missing required fields from System Layer Function's request DTO validation
- **WRONG:** Using Process Layer DTO property names instead of System Layer DTO property names
- **CORRECT:** Dynamic request property names MUST match System Layer Function's request DTO property names exactly
- **CORRECT:** All required fields from System Layer Function's request DTO validation MUST be included
- **CORRECT:** Read System Layer Function's request DTO file to verify property names and required fields before creating dynamic request
- **Why:** System Layer Function deserializes request body into its request DTO. Property name mismatches cause fields to be null/missing, leading to validation failures or incorrect data mapping.

**‚ùå Checking Response Status Codes or Logging Based on Response Status**

- **WRONG:** Checking `response.IsSuccessStatusCode` or extracting error details in System Abstraction
- **WRONG:** Logging based on response status (e.g., `if (response.IsSuccessStatusCode) { _logger.Info(...); } else { _logger.Error(...); }`)
- **CORRECT:** System Abstraction logs at start and end of method (simple logging), returns `HttpResponseMessage` directly
- **Why:** Status checking and error extraction are Service/Function responsibilities. System Abstractions should just make the call and return the response.

---

## 6. Process Abstractions Rules

**üö® CRITICAL:** Process Abstractions handle Process‚ÜíProcess Layer communication via HTTP calls. They are OPTIONAL - only create if you need to call other Process Layer Functions.

### 6.1 Process Abstractions - Pre-Creation Validation

**üõë PRE-CREATION VALIDATION (MANDATORY - STOP IF NOT COMPLETE)**

**üö® YOU CANNOT CREATE Process Abstraction UNTIL:**

1. ‚úÖ **STOP AND VERIFY:** Have I verified that I actually need to call another Process Layer Function?
2. ‚úÖ **STOP AND VERIFY:** Do I understand that Process Abstractions are OPTIONAL (only create if needed)?
3. ‚úÖ **STOP AND VERIFY:** Have I identified which Process Layer Function to call?
4. ‚úÖ **STOP AND VERIFY:** Do I have the Process Layer Function URL in AppConfigs?
5. ‚úÖ **STOP AND VERIFY:** Have I read this section completely?
6. ‚úÖ **STOP AND VERIFY:** Do I know Process Abstractions make HTTP calls (NOT project references)?
7. ‚úÖ **STOP AND VERIFY:** Do I know to use `SendProcessHTTPReqAsync()` extension method for HTTP calls?
8. ‚úÖ **STOP AND VERIFY:** Do I understand the target Process Layer Function's request/response structure?

**üõë IF ANY MISSING ‚Üí STOP ‚Üí Complete verification ‚Üí Then create Process Abstraction**

**üî¥ CRITICAL:** Process Abstractions are **OPTIONAL** - Only create if you actually need to call other Process Layer Functions. If you don't need Process‚ÜíProcess Layer communication, do NOT create Process Abstractions.

### 6.2 Process Abstractions - Structure & Patterns

**Process Abstraction Pattern:**

```csharp
// Interface definition
public interface I<Entity>Proc {
    Task<HttpResponseMessage> Process<Entity>(<Entity>ReqDTO request, string provider, int priority);
}

// Implementation
public class <Entity>Proc : I<Entity>Proc {
    private readonly AppConfigs _options;
    private readonly CustomHTTPClient _customHttpClient;
    private readonly ILogger<<Entity>Proc> _logger;
    
    public <Entity>Proc(IOptions<AppConfigs> o, CustomHTTPClient c, ILogger<<Entity>Proc> l) { 
        _options = o.Value; 
        _customHttpClient = c; 
        _logger = l; 
    }
    
    public async Task<HttpResponseMessage> Process<Entity>(<Entity>ReqDTO request, string provider, int priority) {
        dynamic req = new ExpandoObject();
        req.Code = request.Code;
        req.Config = new { Provider = provider, Priority = priority };
        
        // ‚úÖ Direct call - SendProcessHTTPReqAsync automatically adds TestRunId/RequestId headers
        // No helper methods needed - extension method handles everything
        // ‚úÖ Use await for consistency and proper error handling
        return await _customHttpClient.SendProcessHTTPReqAsync(
            method: HttpMethod.Post, 
            url: _options.<Entity>ProcessLayerUrl, 
            contentType: "application/json", 
            body: (object)req, 
            reqHeaders: null);
    }
}
```

**Key Points:**
- ‚úÖ MUST implement interface
- ‚úÖ MUST inject `CustomHTTPClient` for HTTP calls
- ‚úÖ MUST inject `IOptions<AppConfigs>` for Process Layer Function URLs
- ‚úÖ MUST use `SendProcessHTTPReqAsync()` extension method
- ‚úÖ MUST use `await` (NEVER `.Result`, `.Wait()`, or `.GetAwaiter().GetResult()`)
- ‚úÖ Builds dynamic request using `ExpandoObject`
- ‚úÖ Calls Process Layer Function URL from AppConfigs

### 6.3 Process Abstractions - Header Management

**Header Pattern:**

```csharp
// Process‚ÜíProcess: Technical headers automatically added by extension method + business headers (if needed)
// ‚úÖ Only add business headers if required by target Process Layer
List<Tuple<string, string>> businessHeaders = new List<Tuple<string, string>>();
if (!string.IsNullOrEmpty(_options.AppId)) {
    businessHeaders.Add(Tuple.Create("application-id", _options.AppId));
}

// ‚úÖ Direct call - extension method automatically adds TestRunId/RequestId
return await _customHttpClient.SendProcessHTTPReqAsync(
    method: HttpMethod.Post, 
    url: url, 
    contentType: "application/json", 
    body: (object)req, 
    reqHeaders: businessHeaders);
```

**Key Rules:**
- ‚úÖ Technical headers (TestRunId, RequestId) are automatically added by `SendProcessHTTPReqAsync()` extension method
- ‚úÖ Business headers are optional - only add if required by target Process Layer
- ‚úÖ ‚ùå **NEVER manually add TestRunId/RequestId** - extension method handles this automatically

### 6.4 Process Abstractions - HTTP Call Method

**üî¥ MANDATORY:** Use `SendProcessHTTPReqAsync()` extension method for ALL Process‚ÜíProcess Layer calls (Process Abstractions).

**üî¥ CROSS-REFERENCE:** See Section 5.5 (System Abstractions - HTTP Call Method) for complete details on `SendProcessHTTPReqAsync()` extension method. The same extension method is used for both System Abstractions and Process Abstractions.

**Key Features:**
- ‚úÖ **Automatically adds technical headers:** TestRunId and RequestId are automatically added
- ‚úÖ **JSON serialization:** Automatically serializes body to JSON if provided
- ‚úÖ **Content-Type handling:** Defaults to "application/json" but can be customized
- ‚úÖ **Optional headers:** Can pass additional business headers via `reqHeaders` parameter

**Usage Pattern:**

```csharp
// ‚úÖ CORRECT - Direct call with await (technical headers added automatically)
public async Task<HttpResponseMessage> Process<Entity>(<Entity>ReqDTO request, string provider, int priority) {
    dynamic req = new ExpandoObject();
    req.Code = request.Code;
    req.Config = new { Provider = provider, Priority = priority };

    // ‚úÖ CORRECT - Use await, method must be async
    HttpResponseMessage response = await _customHttpClient.SendProcessHTTPReqAsync(
        method: HttpMethod.Post, 
        url: url, 
        contentType: "application/json", 
        body: (object)req, 
        reqHeaders: null);
    return response;
}

// ‚ùå WRONG - Using .Result causes deadlocks and thread blocking
public Task<HttpResponseMessage> Process<Entity>(<Entity>ReqDTO request) {
    HttpResponseMessage response = _customHttpClient.SendProcessHTTPReqAsync(...).Result;  // ‚ùå PROHIBITED
    return Task.FromResult(response);
}
```

### 6.5 Process Abstractions - Key Rules

**üö® CRITICAL:** Process Abstractions MUST implement interfaces and be injected via interface in Services.

| Component | Pattern | Usage |
|-----------|---------|-------|
| **Interface** | `public interface I<Entity>Proc` | ‚úÖ MANDATORY - All Process Abstractions must have interfaces |
| **Implementation** | `public class <Entity>Proc : I<Entity>Proc` | ‚úÖ MANDATORY - Must implement interface |
| **Injection in Service** | `private readonly I<Entity>Proc _entityProc;` | ‚úÖ MANDATORY - Inject via interface |
| **Registration** | `builder.Services.AddScoped<I<Entity>Proc, <Entity>Proc>();` | ‚úÖ MANDATORY - Register with interface |
| **Method** | `SendProcessHTTPReqAsync()` (extension method) | Process‚ÜíProcess calls - automatically adds TestRunId/RequestId headers |
| **Async Pattern** | **MUST use `await`** - NEVER use `.Result`, `.Wait()`, or `.GetAwaiter().GetResult()` | Prevents deadlocks and thread blocking |
| **Headers** | TestRunId, RequestId (mandatory, automatically added) + business headers (if needed) | Technical + business context |
| **Request Building** | `ExpandoObject` | Dynamic requests |
| **URL Config** | From AppConfigs | Process Layer Function endpoints |
| **Return Type** | `HttpResponseMessage` | Standard response |
| **Optional** | ‚úÖ **OPTIONAL** - Only create if calling other Process Layers | Not all projects need Process Abstractions |

**üî¥ CRITICAL RULES:**

1. ‚úÖ Process Abstractions MUST implement interfaces
2. ‚úÖ Process Abstractions MUST be registered with interface in Program.cs
3. ‚úÖ Process Abstractions MUST use `SendProcessHTTPReqAsync()` extension method
4. ‚úÖ Process Abstractions MUST use `await` (NEVER `.Result`, `.Wait()`, or `.GetAwaiter().GetResult()`)
5. ‚úÖ Process Abstractions are OPTIONAL - only create if needed
6. ‚ùå **NEVER** add project references to other Process Layer projects
7. ‚ùå **NEVER** register other Process Layer services/handlers
8. ‚ùå **NEVER** inject other Process Layer services directly
9. ‚ùå **NEVER** manually add TestRunId/RequestId headers (extension method does this)

### 6.6 Process Abstractions - Post-Creation Validation

**üõë POST-CREATION VALIDATION (MANDATORY - VERIFY BEFORE PROCEEDING)**

**üö® AFTER creating Process Abstraction, you MUST verify:**

1. ‚úÖ **STOP AND VERIFY:** Process Abstraction calls Process Layer Function URL from AppConfigs
2. ‚úÖ **STOP AND VERIFY:** Process Abstraction uses `SendProcessHTTPReqAsync()` extension method (NOT direct HTTP calls)
3. ‚úÖ **STOP AND VERIFY:** Process Abstraction uses `await` (NOT `.Result`, `.Wait()`, or `.GetAwaiter().GetResult()`)
4. ‚úÖ **STOP AND VERIFY:** Process Abstraction implements interface and is registered with interface in Program.cs
5. ‚úÖ **STOP AND VERIFY:** Business headers are only added if required by target Process Layer
6. ‚úÖ **STOP AND VERIFY:** Technical headers (TestRunId/RequestId) are NOT manually added (extension method handles this)

**üõë IF ANY VIOLATION ‚Üí STOP ‚Üí Fix Process Abstraction ‚Üí Then proceed**

### 6.7 Process Abstractions - Common Mistakes

**‚ùå Not Implementing Interface**

- **WRONG:** Creating Process Abstraction without interface
- **CORRECT:** Process Abstraction MUST implement interface and be registered with interface
- **Why:** Services inject Process Abstractions via interface - interface is mandatory.

**‚ùå Using .Result or Blocking Async Calls**

- **WRONG:** Using `.Result`, `.Wait()`, or `.GetAwaiter().GetResult()` on async calls
- **CORRECT:** Always use `await` in async methods
- **Why:** Blocking async calls causes deadlocks and thread blocking. Always use `await`.

**‚ùå Manually Adding TestRunId/RequestId Headers**

- **WRONG:** Manually adding `RequestHeaders.TestRunId.Simplify()` and `RequestHeaders.RequestId.Simplify()` to headers
- **CORRECT:** `SendProcessHTTPReqAsync()` extension method automatically adds these headers
- **Why:** Extension method handles technical headers automatically - no need to add them manually.

**‚ùå Creating Process Abstractions When Not Needed**

- **WRONG:** Creating Process Abstractions "just in case" or when not actually calling other Process Layers
- **CORRECT:** Process Abstractions are OPTIONAL - only create if actually needed
- **Why:** Process Abstractions are for Process‚ÜíProcess Layer communication - only create if this is required.

**‚ùå Not Using SendProcessHTTPReqAsync Extension Method**

- **WRONG:** Using direct HTTP calls or other HTTP client methods
- **CORRECT:** MUST use `SendProcessHTTPReqAsync()` extension method
- **Why:** Extension method automatically adds technical headers and handles JSON serialization.

---

## 7. DTO Rules

**üö® CRITICAL:** DTOs handle request/response data with validation and population logic. DTOs are the contract between Boomi and Process Layer Functions.

### 7.1 DTO Rules - Pre-Creation Validation

**üõë PRE-CREATION VALIDATION (MANDATORY - STOP IF NOT COMPLETE)**

**üö® YOU CANNOT CREATE DTOs UNTIL:**

1. ‚úÖ **STOP AND VERIFY:** Have I read the Phase 1 document completely?
2. ‚úÖ **STOP AND VERIFY:** Have I identified the Request Profile from Phase 1 (Step 1a: Input Structure Analysis)?
3. ‚úÖ **STOP AND VERIFY:** Have I identified the Response Profile from Phase 1 (Step 1b: Response Structure Analysis)?
4. ‚úÖ **STOP AND VERIFY:** Have I reviewed the Boomi JSON profile files for the exact structure?
5. ‚úÖ **STOP AND VERIFY:** Do I understand the exact field names, data types, and mandatory/optional status from Phase 1?
6. ‚úÖ **STOP AND VERIFY:** Have I checked date/datetime field formats from Boomi JSON profile files (especially System Layer output profile for SOR API format requirements)?
7. ‚úÖ **STOP AND VERIFY:** Am I creating DTOs that match EXACTLY the Boomi INPUT profile structure (what Boomi sends to Process Layer), NOT the System Layer API structure?
8. ‚úÖ **STOP AND VERIFY:** Have I checked the Boomi INPUT profile JSON file to see the exact nested structure (including "Object" wrappers if present)?
9. ‚úÖ **STOP AND VERIFY:** Am I creating DTOs that match EXACTLY the Boomi contract (no additional classes, no assumptions, no unnecessary nesting)?
10. ‚úÖ **STOP AND VERIFY:** Have I checked Phase 1 document (Section 2: Process Properties Analysis) for HTTP headers and request parameters required by the Boomi process?
    - **üî¥ CRITICAL CHECKLIST for each property in Phase 1 Section 2:**
      1. Read "Source Type" field for the property
      2. If "Source Type: definedparameter" ‚Üí Add to AppConfigs (configuration), NOT headers/DTO, check component JSON for default value
      3. If "Source Type: trackparameter" with property name containing "inheader_" ‚Üí Read from req.Headers in Function, design it to read it from headers, create it as a part of DTO and pass it to system layer in request DTO
      4. If "Source Type: trackparameter" with property name containing "inquery_" ‚Üí Read from req.Query in Function, design it to read it from query, create it as a part of DTO and pass it to system layer in request DTO
      5. If "Source Type: trackparameter" with property name containing "indocument_" ‚Üí Add to DTO request body
    - **‚ùå COMMON MISTAKE:** Assuming properties are headers when Phase 1 shows "Source Type: definedparameter"
    - **Example Error:** Adding `<ConfigProperty>` to headers when Phase 1 shows `Source Type: definedparameter` ‚Üí Should be in AppConfigs
11. ‚úÖ **STOP AND VERIFY:** Have I verified which fields the System Layer DTO requires by checking the System Layer DTO validation methods (e.g., `ValidateAPIRequestParameters()`, `ValidateDownStreamRequestParameters()`)?
12. ‚úÖ **STOP AND VERIFY:** Have I identified ALL data sources needed (request body, HTTP headers, query parameters, config) to populate System Layer DTO fields?
13. ‚úÖ **STOP AND VERIFY:** Have I read "üî¥ CRITICAL: DTO DESIGN MISTAKES TO AVOID" section (Mistake #1-5)?
14. ‚úÖ **STOP AND VERIFY:** Have I checked if Domain class exists (to determine if DTO needs `IRequestPopulatorDTO<DomainType>`)?
    - **üî¥ CRITICAL:** If Domain exists ‚Üí DTO MUST extend `IRequestPopulatorDTO<DomainType>` - applies to ALL operations (write AND read-only)
    - **üî¥ CRITICAL:** This rule applies even if request DTO only contains query parameters and Domain represents response data
    - **üî¥ CRITICAL:** This rule applies even if `Populate()` method will be empty (must still be implemented)

**üõë IF ANY MISSING ‚Üí STOP ‚Üí Complete verification ‚Üí Then create DTOs**

**üî¥ CRITICAL DISTINCTION:**
- **Process Layer DTOs** = Match Boomi INPUT profile structure (what Boomi sends TO Process Layer Function)
- **System Layer DTOs** = Match external SOR API structure (what System Layer sends TO external system)
- **‚ùå NEVER confuse these two** - They are different structures!

**üî¥ CRITICAL RULES FOR DTO CREATION:**
- **‚ùå NEVER create DTOs based on assumptions or existing code patterns**
- **‚ùå NEVER add fields/classes that don't exist in the Boomi contract**
- **‚ùå NEVER create helper classes (like `AttachmentInfo`) unless they exist in the Boomi profile**
- **‚úÖ ALWAYS create DTOs based EXACTLY on Phase 1 document (Step 1a for Request, Step 1b for Response)**
- **‚úÖ ALWAYS verify field names match Boomi JSON profile files EXACTLY**
- **‚úÖ ALWAYS verify data types match Boomi profile (character = string, datetime = string with format, etc.)**
- **‚úÖ ALWAYS verify mandatory/optional status from Phase 1 document**
- **‚úÖ ALWAYS verify nested structure matches Boomi profile hierarchy EXACTLY**
- **üî¥ CRITICAL: ALWAYS check date/datetime field formats from Boomi JSON profile files** - Check the System Layer output profile (the profile that maps to SOR API) for `ProfileDateFormat` with `dateFormat` attribute (e.g., `"yyyy-MM-dd"`, `"yyyy-MM-dd'T'HH:mm:ss"`). This format MUST be used when System Abstraction sends data to SOR.

**üî¥ MANDATORY VERIFICATION WORKFLOW FOR DTO STRUCTURE:**
1. **‚úÖ PRIMARY SOURCE: Match Boomi Request Payload Structure**
   - Check Phase 1 document (Section 14: Input Structure Analysis) for Boomi input profile structure
   - Verify DTO structure matches Boomi JSON profile hierarchy EXACTLY
   - Verify field names match Boomi field names (with appropriate C# naming conventions)
   - **Example:** If Boomi has `<operationName>` ‚Üí `<entityName>` ‚Üí fields, then DTO should have `<Operation>ReqDTO` ‚Üí `<Entity>DTO` ‚Üí properties

2. **‚úÖ SECONDARY VERIFICATION: Check System Layer Function Request DTO**
   - After creating Process Layer DTO based on Boomi structure, verify System Layer Function's request DTO structure
   - Check System Layer DTO validation methods (`ValidateAPIRequestParameters()`, `ValidateDownStreamRequestParameters()`) to see which fields are REQUIRED
   - Verify that ALL required System Layer DTO fields can be populated from Process Layer DTO (or headers, query params, config)
   - **Purpose:** Ensure Process Layer DTO contains all necessary data to populate System Layer DTO
   - **If mismatch found:** Review Phase 1 document (Section 17: Field Mapping Analysis) to verify correct mapping sources

**Source of Truth Priority:**
1. **Boomi JSON Profile Files** (authoritative structure for Process Layer DTO)
2. **Phase 1 Document** (authoritative field names, types, mandatory/optional, mapping sources)
3. **System Layer DTO Validation Methods** (verification that all required fields can be populated)
4. **Existing code patterns** (reference only, NOT source of truth)

### 7.2 DTO Rules - DTO Design Mistakes (Critical - Read First)

**üö® BEFORE creating ANY DTO, review these common mistakes:**

**Mistake #1: DTO Folder Naming with SOR Name**
- ‚ùå **WRONG:** `DTOs/<Operation><SOR>/` (includes SOR name, e.g., `DTOs/CreateEntityD365/`)
- ‚úÖ **CORRECT:** `DTOs/<Operation>Request/` (operation-based, no SOR name, e.g., `DTOs/CreateEntityRequest/`)
- **Rule:** DTO folder names MUST be based on the operation, NEVER include SOR name. SOR is determined by System Abstraction, not folder name.

**Mistake #2: Using [JsonPropertyName] in Process Layer DTOs**
- ‚ùå **WRONG:** `[JsonPropertyName("<fieldName>")] public string <FieldName> { get; set; }`
- ‚úÖ **CORRECT:** `public string <FieldName> { get; set; } = string.Empty;` (property name matches Boomi field directly)
- **Rule:** Process Layer DTOs receive data from Boomi that already matches the contract. Property names should match Boomi field names directly. JSON serialization/deserialization is handled by the framework automatically. **Note:** `[JsonIgnore]` is allowed for properties that should not be serialized (e.g., `Headers` property).

**Mistake #3: Over-Engineering DTO Structure (Creating Too Many Files)**
- ‚ùå **WRONG:** Creating 9 separate files for nested classes when only a few properties are needed
  - Example: `<Operation>Request.cs`, `<Operation>RequestObject.cs`, `<NestedClass1>.cs`, `<NestedClass2>.cs`, etc.
- ‚úÖ **CORRECT:** Single flat DTO class with direct properties matching Boomi contract exactly
  - Example: `<Operation>ReqDTO.cs` with direct properties: `<FieldName1>`, `<FieldName2>`, `<FieldName3>`, etc.
- **Rule:** DTO structure MUST contain ONLY the essential properties needed. Do NOT create unnecessary nested classes for "Object" wrappers. Create simple DTOs with just the properties required. The System Layer is responsible for mapping to SOR API structure.

**Mistake #4: Unnecessary Helper Methods in DTOs**
- ‚ùå **WRONG:** Adding helper methods like `Get<Field>ValueFromHeader()`, `Extract<Field>()`, field extraction methods
- ‚úÖ **CORRECT:** DTOs should NOT have helper methods - Functions should directly access DTO properties after validation
- **Rule:** DTOs are data containers with validation and population logic only. Business logic and field extraction belong in Functions or Services, not DTOs.

**Mistake #5: Unnecessary Nested Classes in Single File**
- ‚ùå **WRONG:** `<Operation>ReqDTO.cs` containing multiple nested classes (`<NestedClass1>`, `<NestedClass2>`, etc.) all in one file
- ‚úÖ **CORRECT:** Separate files: `<Operation>ReqDTO.cs`, `<NestedClass1>.cs`, `<NestedClass2>.cs`, etc. (ONLY if nested classes are actually required by Boomi contract)
- **Rule:** Each class MUST be in its own separate file. One class per file, following standard C# conventions. However, prefer flat DTOs with direct properties over nested classes unless Boomi contract explicitly requires nesting.

**Mistake #6: Using Misleading External Field Names Directly**
- ‚ùå **WRONG:** Using Boomi's misleading field names directly in Process Layer DTOs (e.g., `{misleading-field-name}` for {actual-meaning}, `{ambiguous-field}` for {entity-details})
- ‚úÖ **CORRECT:** Use meaningful property names internally, map from Boomi's field names in Function layer
- **Rule:** When Boomi uses misleading, ambiguous, or unclear field names, Process Layer DTOs MUST use meaningful property names internally. Mapping from Boomi field names happens in the Function layer (when reading from request body/query params/headers).

### 7.2.1 üî¥ CRITICAL: MEANINGFUL PROPERTY NAMES FOR BOOMI CONTRACTS

**üö® MANDATORY RULE:** When Boomi process uses misleading, ambiguous, or unclear field names, Process Layer DTOs MUST use meaningful property names internally. Mapping from Boomi field names happens at the Function layer (when reading from request body, query parameters, or headers).

### Why This Rule Exists
1. **Code Readability:** Internal code should be self-documenting with clear, meaningful names
2. **Maintainability:** Developers should understand what properties represent without reading Boomi documentation
3. **Consistency:** Internal code follows C# naming conventions and descriptive naming standards
4. **External Contract Preservation:** Boomi may have legacy/misleading names that cannot be changed, but we can use better names internally

### When to Apply This Rule
‚úÖ **USE meaningful internal names when:**
- Boomi uses misleading field names (e.g., `{misleading-field}` for {actual-meaning}, `{ambiguous-field}` for {entity-details})
- Boomi field names are ambiguous (e.g., `value`, `item`, `result`, `temp`)
- Boomi field names don't follow C# naming conventions (e.g., `{field_id}`, `{full_name}`, `@{special-prefix}.{field}`)
- Boomi field names are abbreviations without context (e.g., `id` when it could be `{Entity}Id`, `{User}Id`, `{Order}Id`)
- Boomi field names conflict with C# keywords or reserved words

‚ùå **DON'T use meaningful names when:**
- Boomi field names are already clear and meaningful (e.g., `{Entity}Id`, `{Entity}Name`, `{Start}Date`)
- Boomi field names match C# naming conventions (e.g., `{Company}Code`, `{Driver}Id`)
- No ambiguity or confusion exists

### Where Mapping Happens
**üî¥ CRITICAL:** Mapping from Boomi field names to meaningful internal property names happens at the **Function layer**, NOT in DTOs:

1. **Function Layer (Incoming Requests from Boomi):**
   - For **request body (JSON)**: Function reads from `req.ReadBodyAsync<DTO>()` and manually maps Boomi JSON field names to meaningful DTO properties
   - For **query parameters**: Function extracts from `req.Query` and manually maps Boomi parameter names to meaningful DTO properties
   - For **headers**: Function extracts from `req.Headers` and manually maps Boomi header names to meaningful DTO properties
   - **DTOs use meaningful property names** - no annotations needed for Boomi field name mapping

2. **System Abstraction Layer (Outgoing to System Layer):**
   - System Abstraction reads from Process Layer DTO properties (meaningful names)
   - System Abstraction maps to System Layer DTO structure when building request
   - **This is where System Layer DTO field name mapping happens** - when creating the System Layer request payload

### Implementation Pattern

**‚ùå WRONG - Using Boomi Misleading Name Directly:**
```csharp
public class <Operation>ReqDTO : IRequestBaseDTO
{
    // ‚ùå Misleading name - "{misleading-field-name}" suggests {wrong-meaning}, but it's actually {actual-meaning}
    public string {MisleadingFieldName} { get; set; } = string.Empty;
}
```

**‚úÖ CORRECT - Meaningful Internal Name (Function Maps from Boomi):**
```csharp
// Process Layer DTO - Uses meaningful name internally
public class <Operation>ReqDTO : IRequestBaseDTO
{
    /// <summary>
    /// {Actual meaning/description} (e.g., query string, filter criteria, entity identifier).
    /// This is {mandatory/optional} ({allowEmpty: true/false} in Boomi profile).
    /// Example: "{example-value}"
    /// 
    /// Boomi Contract Mapping:
    /// - Boomi field name: "{misleading-field-name}" (misleading - suggests {wrong-meaning})
    /// - Boomi Input Type: {singlejson/query/header} ({request body/query parameter/header})
    /// - Mapping: Function reads "{misleading-field-name}" from {request body JSON/query parameters/headers} and maps to this meaningful property
    /// </summary>
    public string {MeaningfulPropertyName} { get; set; } = string.Empty;
}

// Function - Manually maps Boomi field name to meaningful property
[Function("<Operation>")]
public async Task<BaseResponseDTO> Run([HttpTrigger(AuthorizationLevel.Anonymous, "post", Route = "{resource}/{operation}")] HttpRequest req)
{
    // Step 1: Deserialize Boomi's JSON structure (with misleading field name)
    // Option 1: Use temporary mapping class with [JsonPropertyName] for Boomi field name
    // Option 2: Read raw JSON and map manually
    // Option 3: Use JsonSerializer with JsonPropertyName in temporary mapping class
    
    <BoomiMappingClass>? boomiRequest = await req.ReadBodyAsync<<BoomiMappingClass>>();
    
    if (boomiRequest == null)
    {
        throw new NoRequestBodyException(...);
    }
    
    // Step 2: Map to meaningful DTO
    <Operation>ReqDTO dto = new <Operation>ReqDTO
    {
        {MeaningfulPropertyName} = boomiRequest.{MisleadingFieldName} ?? string.Empty
    };
    
    dto.Validate();
    // ... rest of function
}

// Temporary class for deserializing Boomi's JSON structure
internal class <BoomiMappingClass>
{
    [JsonPropertyName("{misleading-field-name}")]
    public string? {MisleadingFieldName} { get; set; }
}
```

**‚úÖ CORRECT - System Abstraction Uses Meaningful Names:**
```csharp
// System Abstraction - Uses meaningful property names from Process Layer DTO
public async Task<HttpResponseSnapshot> <Operation>(<Operation>ReqDTO dto)
{
    // ‚úÖ Uses meaningful property name {MeaningfulPropertyName} (not "{misleading-field-name}")
    dynamic dynamicReq = new ExpandoObject();
    dynamicReq.{SystemLayerPropertyName} = dto.{MeaningfulPropertyName}; // Map to System Layer DTO property name
    
    HttpResponseMessage response = await _customHttpClient.SendProcessHTTPReqAsync(
        method: HttpMethod.Post,
        url: _options.{SystemLayerFunctionUrl},
        body: (object)dynamicReq
    );
    
    return HttpResponseSnapshot.FromAsync(response);
}
```

### XML Documentation Requirements
**üî¥ MANDATORY:** When Process Layer DTO property name differs from Boomi field name, XML documentation MUST explain:
1. **What the property represents** (e.g., "{actual-meaning} ({description})")
2. **Why the external name is different/misleading** (e.g., "Boomi field name '{misleading-field-name}' is misleading - suggests {wrong-meaning}")
3. **How the mapping works** (e.g., "Function reads '{misleading-field-name}' from {request body JSON/query parameters/headers} and maps to this property")
4. **Boomi contract details** (e.g., "Boomi Input Type: {singlejson/query/header}", "Boomi field name: {misleading-field-name}")

### Summary
- ‚úÖ **Process Layer DTOs:** Use meaningful property names internally
- ‚úÖ **Function Layer:** Manually maps Boomi field names to meaningful DTO properties
- ‚úÖ **System Abstraction:** Uses meaningful property names from Process Layer DTO
- ‚úÖ **XML Documentation:** Explains property purpose, external name difference, and mapping approach
- ‚ùå **NEVER:** Use Boomi's misleading field names directly in Process Layer DTOs
- ‚ùå **NEVER:** Use `[JsonPropertyName]` in Process Layer DTOs for Boomi field name mapping (mapping happens in Function)

### 7.3 DTO Rules - Structure & Patterns

**Request DTO Pattern:**

```csharp
public class <Operation>ReqDTO : IRequestBaseDTO, IRequestPopulatorDTO<<Entity>Domain> {
    public string Code { get; set; } = string.Empty;
    public string Email { get; set; } = string.Empty;
    public List<ItemDTO> Items { get; set; } = new();
    public Dictionary<string, string> Headers { get; set; } = new();
    
    public void Validate() {
        List<string> errors = new();
        // ‚úÖ ONLY validate MANDATORY fields (from Phase 1 document)
        if (string.IsNullOrWhiteSpace(Code)) errors.Add(nameof(Code) + " is Required.");
        // ‚ùå Do NOT validate optional fields - they default to string.Empty
        if (errors.Any()) throw new RequestValidationFailureException(errorDetails: errors, stepName: "<Operation>ReqDTO.cs / Validate");
    }
    
    public void Populate(<Entity>Domain domain) {
        domain.Code = this.Code;
        domain.Email = this.Email;
        domain.Items = this.Items?.Select(i => new EntityChild { Name = i.Name, Value = i.Value }).ToList() ?? new List<EntityChild>();
    }
}
```

**Request DTO with ServiceLocator (Nested Objects):**

```csharp
public void Populate(<Entity>Domain domain) {
    domain.Code = this.Code;
    if (this.Details != null) {
        <Entity>Details nested = ServiceLocator.ServiceProvider.GetService<<Entity>Details>();
        nested.Name = this.Details.Name;
        domain.Details = nested;
    }
    if (this.ResourceId != null) {
        <Entity>Child child = ServiceLocator.ServiceProvider.GetService<<Entity>Child>();
        child.Id = ResourceId;
        domain.Items.Add(child);
    }
}
```

**Request DTO with Tuple Parameter (Route Parameters):**

**Pattern:** When Function has route parameters that need to be passed to domain during population.

```csharp
// In Function
[Function("GetEntityById")]
public async Task<BaseResponseDTO> Run(
    [HttpTrigger(AuthorizationLevel.Anonymous, "post", Route = "entity/{entityId}")] 
    HttpRequest req, 
    string entityId) {
    <Operation>ReqDTO? dto = await req.ReadBodyAsync<<Operation>ReqDTO>();
    <Entity>Domain domain = new <Entity>Domain();
    dto.Populate(new Tuple<string, <Entity>Domain>(entityId, domain));
    // ... rest of function
}

// In DTO Populate method
public void Populate(Tuple<string, <Entity>Domain> routeParams) {
    (string routeValue, <Entity>Domain domain) = routeParams;
    domain.RouteParameter = routeValue;
    domain.Code = this.Code;
    domain.PropertyA = this.PropertyA;
}
```

**Key Points:**
- Tuple first element: Route parameter value
- Tuple second element: Domain instance to populate
- Useful when route parameters need to be set on domain before other properties

**Response DTO Pattern:**

```csharp
public class <Operation>ResDTO {
    public long Id { get; set; }
    public string Name { get; set; } = string.Empty;
    public string Status { get; set; } = string.Empty;
    public DateTime? CreatedAt { get; set; }
    public List<ItemDTO> Items { get; set; } = new();
}
```

### 7.4 DTO Rules - Property Declaration & Validation Rules

**üö® MANDATORY RULES - NEVER VIOLATE:**

**üî¥ MANDATORY RULE #0: DTO MUST EXTEND `IRequestPopulatorDTO<Domain>` FOR POPULATE FUNCTION**

**üö® CRITICAL: This rule applies to ALL operations, including read-only query operations (Get, List, etc.)**

- **‚úÖ MANDATORY:** If Domain class exists ‚Üí Request DTO class declaration MUST extend `IRequestPopulatorDTO<DomainType>`
  - ‚úÖ **CORRECT:** `public class <Operation>ReqDTO : IRequestDTO, IRequestPopulatorDTO<<Entity>Domain>`
  - ‚úÖ **CORRECT:** `public class <Operation>ReqDTO : IRequestBaseDTO, IRequestPopulatorDTO<<Entity>Domain>`
  - ‚ùå **WRONG:** `public class <Operation>ReqDTO : IRequestDTO` (missing `IRequestPopulatorDTO<DomainType>`)
- **‚úÖ MANDATORY:** DTO MUST implement `public void Populate(DomainType domain)` method
- **‚úÖ MANDATORY:** Populate method MUST map ALL DTO properties to domain properties (or be empty if no mapping needed)
- **üî¥ CRITICAL:** This rule has been missed 3+ times - DO NOT SKIP THIS MANDATORY RULE

**Why Domain Population is Required for Read-Only Operations:**
- **Architectural consistency:** All operations dealing with an entity should follow the same pattern
- **Contract enforcement:** DTO must be able to populate Domain (even if Populate() is empty) - ensures interface contract is maintained
- **Future extensibility:** Domain may be used for validation, caching, or business logic later, even in read-only operations
- **Code maintainability:** Consistent pattern makes code easier to understand and maintain across all operation types
- **Separation of concerns:** Domain represents the business entity, regardless of whether operation is read or write

**üî¥ CRITICAL: No Exceptions**
- This rule applies to **ALL operations** - write operations (Create, Update, Delete) AND read-only operations (Get, List, Query)
- Even if request DTO only contains query parameters (e.g., `ODataQueryString`) and Domain represents response data, the rule still applies
- Even if `Populate()` method is empty (no properties to map), it must still be implemented
- **Example 1: Write Operation (Create, Update) - MANDATORY Pattern:**
  ```csharp
  using Core.ProcessLayer.DTOs;
  using <Project>.Domains.<BusinessDomain>;
  
  public class <Operation>ReqDTO : IRequestDTO, IRequestPopulatorDTO<<Entity>Domain>
  {
      public string Property1 { get; set; } = string.Empty;
      public string Property2 { get; set; } = string.Empty;
      // ... properties ...
      
      public void Populate(<Entity>Domain domain)
      {
          // ‚úÖ CORRECT: Assign directly without null checks
          // Validate() ensures all mandatory properties are non-null/non-empty
          // Populate() is called AFTER Validate() passes, so we can trust the DTO contract
          domain.Property1 = this.Property1!;  // Use null-forgiving operator if property is nullable type
          domain.Property2 = this.Property2!;
          // ... map all properties ...
      }
      
      // ‚ùå WRONG - DO NOT DO THIS:
      // public void Populate(<Entity>Domain domain)
      // {
      //     if (Property1 == null) return;  // ‚ùå Redundant - Validate() already ensures this
      //     if (Property2 != null && Property2.Count > 0)  // ‚ùå Redundant - Validate() already ensures this
      //     {
      //         domain.Property1 = Property2[0];
      //     }
      // }
  }
  ```

- **Example 2: Read-Only Query Operation (Get, List) - MANDATORY Pattern:**
  ```csharp
  using Core.ProcessLayer.DTOs;
  using <Project>.Domains.<BusinessDomain>;
  
  public class Get<Entity>ReqDTO : IRequestBaseDTO, IRequestPopulatorDTO<<Entity>Domain>
  {
      // Read-only operation: Request DTO only contains query parameters
      public string ODataQueryString { get; set; } = string.Empty;
      
      public void Validate()
      {
          // No mandatory fields - ODataQueryString is optional
          // Validation not required for optional fields
      }
      
      public void Populate(<Entity>Domain domain)
      {
          // ‚úÖ CORRECT: Read-only query operation - Request DTO only contains query parameters,
          // not entity data. Domain represents response data (entity records).
          // No properties to populate from request DTO to Domain.
          // This method is required by IRequestPopulatorDTO<<Entity>Domain> interface contract.
          // Even though empty, it must be implemented for architectural consistency.
      }
  }
  ```

- **Example 3: Function Implementation - Read-Only Operation:**
  ```csharp
  [Function("Get<Entity>")]
  public async Task<BaseResponseDTO> Run([HttpTrigger(AuthorizationLevel.Anonymous, "post", Route = "<entity>/details")] HttpRequest req)
  {
      Get<Entity>ReqDTO? dto = await req.ReadBodyAsync<Get<Entity>ReqDTO>();
      
      if (dto == null)
      {
          throw new NoRequestBodyException(...);
      }
      
      dto.Validate();
      
      // ‚úÖ CORRECT: Domain creation and population required for ALL operations, including read-only
      <Entity>Domain domain = new <Entity>Domain();
      dto.Populate(domain);  // Populate() may be empty, but still required
      
      HttpResponseSnapshot response = await _service.Get<Entity>(dto);
      // ... rest of function
  }
  ```

1. **‚úÖ ALL fields (optional and mandatory) MUST use default value `= string.Empty`** - Do NOT use nullable types (`string?`) for any fields
   - ‚úÖ **CORRECT:** `public string <FieldName> { get; set; } = string.Empty;` (both optional and mandatory fields)
   - ‚ùå **WRONG:** `public string? <FieldName> { get; set; }` (fields should not be nullable)
   - **Why:** All fields default to `string.Empty`, eliminating the need for null checks throughout the codebase

2. **‚úÖ Validate() method MUST ONLY validate MANDATORY fields** - Do NOT validate optional fields
   - ‚úÖ **CORRECT:** Only validate fields marked as MANDATORY in Phase 1 document (check that they are not empty)
   - ‚ùå **WRONG:** Validating all fields, including optional ones
   - **Why:** Optional fields are allowed to be empty (they default to `string.Empty`), only mandatory fields need validation

3. **üî¥ CRITICAL: DTO Validation Error Messages MUST use `nameof()` with string interpolation - NEVER use ErrorConstants**
   - ‚úÖ **CORRECT:** `errors.Add($"{nameof(PropertyName)} is required.");`
   - ‚úÖ **CORRECT:** `errors.Add(nameof(PropertyName) + " is not a valid date in format yyyy-MM-dd.");`
   - ‚ùå **WRONG:** `errors.Add(ErrorConstants.PROPERTY_REQUIRED.Message);` - **PROHIBITED**
   - ‚ùå **WRONG:** `errors.Add(ErrorConstants.TYPE_REQUIRED.Message);` - **PROHIBITED**
   - **Why:** DTO validation errors are field-specific and should reference the actual property name using `nameof()`. ErrorConstants are for business logic errors, not DTO validation errors. Using `nameof()` ensures errors are self-documenting and maintainable.
   - **Example (CORRECT Pattern):**
     ```csharp
     public void Validate()
     {
         List<string> errors = new List<string>();
         
         if (string.IsNullOrEmpty(EmployeeUniqueId))
         {
             errors.Add($"{nameof(EmployeeUniqueId)} is required.");
         }
         
         if (string.IsNullOrEmpty(ServiceId))
         {
             errors.Add($"{nameof(ServiceId)} is required.");
         }
         
         if (!DateTime.TryParseExact(LastWorkingDay, "yyyy-MM-dd", null, System.Globalization.DateTimeStyles.None, out var startDate))
         {
             errors.Add(nameof(LastWorkingDay) + " is not a valid date in format yyyy-MM-dd.");
         }
         
         if (errors.Any())
         {
             throw new RequestValidationFailureException(
                 errorDetails: errors,
                 stepName: "<Operation>ReqDTO.cs / Executing Validate"
             );
         }
     }
     ```
   - **Example (WRONG Pattern - PROHIBITED):**
     ```csharp
     // ‚ùå WRONG - Using ErrorConstants for DTO validation
     if (string.IsNullOrWhiteSpace(LeaveRequest.OldLeaveId))
     {
         errors.Add(ErrorConstants.OLD_LEAVE_ID_REQUIRED.Message);  // ‚ùå PROHIBITED
     }
     ```

4. **‚úÖ After Validate() passes, use fields directly** - No need for null coalescing (`??`) since all fields default to `string.Empty` and mandatory fields are validated
   - ‚úÖ **CORRECT (in Function):** `dto.<FieldName>` (after Validate() passes, mandatory fields are guaranteed to be non-empty)
   - ‚ùå **WRONG (in Function):** `dto.<FieldName> ?? string.Empty` (unnecessary - fields already default to string.Empty)
   - **Why:** After validation passes, mandatory fields are guaranteed to be non-empty. Optional fields already default to `string.Empty`. Null coalescing is redundant and shows architectural misunderstanding.

5. **‚úÖ Source of truth for mandatory/optional:** Phase 1 document (Step 1a) - Check `allowEmpty` attribute in Boomi JSON profile files
   - **MANDATORY:** `allowEmpty == "false"` OR `minOccurs > 0`
   - **OPTIONAL:** `allowEmpty == "true"` OR `minOccurs == 0` OR `allowEmpty` not specified (defaults to optional)

**üî¥ ARCHITECTURAL PRINCIPLE:**
- **DTOs handle defaults** - All fields default to `string.Empty` at the DTO level
- **Functions trust DTOs** - After `Validate()` passes, Functions can use DTO properties directly without null checks or null coalescing
- **No defensive coding in Functions** - If `Validate()` passes, the DTO contract is guaranteed. Functions should not add redundant null checks or default value assignments.

**üö® CRITICAL: FUNCTION USAGE OF DTO PROPERTIES - NEVER GET CONFUSED**

**After `dto.Validate()` passes:**
- ‚úÖ **CORRECT:** Use DTO properties directly - `dto.<FieldName>`
- ‚ùå **WRONG:** Using null coalescing - `dto.<FieldName> ?? string.Empty`
- ‚ùå **WRONG:** Using null checks - `if (dto.<FieldName> != null)`
- ‚ùå **WRONG:** Assigning default values - `string value = dto.<FieldName> ?? string.Empty;`

**Why null coalescing is wrong:**
1. All DTO fields default to `string.Empty` at declaration - they are never null
2. `Validate()` ensures mandatory fields are non-empty (throws exception if empty)
3. After validation passes, mandatory fields are guaranteed to be non-empty strings
4. Optional fields already default to `string.Empty`, so they're safe to use directly
5. Adding null coalescing shows misunderstanding of the DTO contract and validation flow

**Example Pattern:**
```csharp
// ‚úÖ CORRECT - Trust the DTO contract after validation
dto.Validate(); // After this passes, all fields are safe to use
await service.Method(dto.FieldName, dto.AnotherField, dto.OptionalField);

// ‚ùå WRONG - Shows architectural misunderstanding
dto.Validate();
await service.Method(
    dto.FieldName ?? string.Empty,      // ‚ùå Unnecessary
    dto.AnotherField ?? string.Empty,   // ‚ùå Unnecessary
    dto.OptionalField ?? string.Empty   // ‚ùå Unnecessary
);
```

### 7.5 DTO Rules - Folder Structure & Naming

**Folder Structure:**
- ‚úÖ **CORRECT:** `DTOs/<Operation>Request/` (operation-based, e.g., `DTOs/CreateEntityRequest/`)
- ‚ùå **WRONG:** `DTOs/<Operation><SOR>/` (includes SOR name, e.g., `DTOs/CreateEntityD365/`)

**File Naming:**
- Request DTO: `<Operation>ReqDTO.cs` (e.g., `CreateEntityReqDTO.cs`)
- Response DTO: `<Operation>ResDTO.cs` (e.g., `CreateEntityResDTO.cs`)
- Nested Classes: `<NestedClass>.cs` (separate file, only if required by Boomi contract)

**Namespace:**
- `<NS>.DTOs.<FeatureName>` (e.g., `ProcAppointmentCreate.DTOs.CreateEntityRequest`)

**Key Rules:**
- ‚úÖ Folder names MUST be operation-based, NEVER include SOR name
- ‚úÖ Each class MUST be in its own separate file (one class per file)
- ‚úÖ Prefer flat DTOs with direct properties over nested classes unless Boomi contract explicitly requires nesting

### 7.6 DTO Rules - Key Rules

| Component | Pattern | Mandatory |
|-----------|---------|-----------|
| **Interface** | `IRequestBaseDTO` or `IRequestDTO` for requests | ‚úÖ Request DTOs |
| **Interface** | `IRequestPopulatorDTO<<Entity>Domain>` - **üî¥ MANDATORY: DTO MUST EXTEND THIS** | ‚úÖ **MANDATORY** - Standard Process Layer (if Domain exists) - **üî¥ CRITICAL: DTO class declaration MUST include this interface - Has been missed 3+ times - DO NOT SKIP** |
| **Validate()** | Throws `RequestValidationFailureException` | ‚úÖ All Request DTOs |
| **Populate()** | Maps DTO ‚Üí Domain - **DTO MUST IMPLEMENT THIS** | ‚úÖ **MANDATORY** - Standard Process Layer (if Domain exists) - **üî¥ CRITICAL: Has been missed 3+ times** - **üî¥ CRITICAL: Applies to ALL operations (write AND read-only) - May be empty for read-only operations but must still be implemented** |
| **Headers** | `Dictionary<string, string> Headers` | ‚ö†Ô∏è **Need-based only** - Only if headers need propagation to System Layer/SOR |
| **Folder** | `DTOs/<OperationName>/` | ‚úÖ Always |
| **Folder Naming** | Based on operation (e.g., `<Operation>Request`, `Get<Entity>`) | ‚úÖ **Operation-based** - **‚ùå NEVER include SOR name** |
| **Folder Naming** | Include SOR name (e.g., `<Operation><SOR>`, `Get<Entity><SOR>`) | ‚ùå **WRONG** - SOR is determined by System Abstraction, not folder name |
| **Property Defaults** | `= string.Empty` for all string properties | ‚úÖ **MANDATORY** - Never use nullable types |
| **Validation** | Only validate MANDATORY fields | ‚úÖ **MANDATORY** - Optional fields default to `string.Empty` |
| **Structure** | Match Boomi INPUT profile EXACTLY | ‚úÖ **MANDATORY** - Source of truth: Boomi JSON profile files |

**üî¥ CRITICAL RULES:**

1. ‚úÖ DTOs MUST match Boomi INPUT profile structure EXACTLY (what Boomi sends TO Process Layer)
2. ‚úÖ DTOs MUST implement `IRequestPopulatorDTO<DomainType>` if Domain exists - **üî¥ CRITICAL: Applies to ALL operations (write AND read-only)**
3. ‚úÖ DTOs MUST have `Populate(DomainType domain)` method if Domain exists - **üî¥ CRITICAL: Applies to ALL operations (write AND read-only) - May be empty for read-only operations but must still be implemented**
4. ‚úÖ All properties MUST use default value `= string.Empty` (not nullable)
5. ‚úÖ Validate() method MUST ONLY validate MANDATORY fields
6. ‚úÖ Folder names MUST be operation-based (NEVER include SOR name)
7. ‚úÖ Each class MUST be in its own separate file
8. ‚úÖ **Response DTOs MUST use `[JsonPropertyName]` attributes** for camelCase serialization (matches Boomi contract)
9. ‚ùå **Request DTOs MUST NOT use `[JsonPropertyName]` attributes** (except `[JsonIgnore]` for non-serialized properties)
9. ‚ùå **NEVER create helper methods in DTOs**
10. ‚ùå **NEVER create unnecessary nested classes**

### 7.7 DTO Rules - Post-Creation Validation

**üõë POST-CREATION VALIDATION FOR REQUEST DTOs (MANDATORY - VERIFY BEFORE PROCEEDING)**

**üö® AFTER creating Request DTO, you MUST verify:**

1. ‚úÖ **STOP AND VERIFY:** DTO implements `IRequestBaseDTO` 
2. ‚úÖ **STOP AND VERIFY:** DTO has `Validate()` method that throws `RequestValidationFailureException`
   - [ ] **BLOCKING:** Run `grep -n "ErrorConstants\." <file>` in Validate() method ‚Üí Document ALL matches found (line numbers)
   - [ ] **BLOCKING:** For EACH match found: Is it used in error message (e.g., `errors.Add(ErrorConstants.XXX.Message)`)? ‚Üí **VIOLATION** ‚Üí Must use `nameof()` with string interpolation ‚Üí Fix ‚Üí Re-run grep
   - [ ] **BLOCKING:** If ANY violations found ‚Üí STOP ‚Üí Replace with `nameof()` pattern ‚Üí Re-run grep ‚Üí Verify zero violations
   - [ ] **BLOCKING:** Verify ALL validation error messages use `nameof()` with string interpolation (e.g., `$"{nameof(PropertyName)} is required."`)
   - ‚úÖ **CORRECT:** `errors.Add($"{nameof(PropertyName)} is required.");`
   - ‚úÖ **CORRECT:** `errors.Add(nameof(PropertyName) + " is not a valid date in format yyyy-MM-dd.");`
   - ‚ùå **WRONG:** `errors.Add(ErrorConstants.PROPERTY_REQUIRED.Message);` - **PROHIBITED**
   - **üî¥ CRITICAL:** DTO validation errors MUST use `nameof()` with string interpolation, NEVER use ErrorConstants
   - **üö® CRITICAL:** You MUST run the grep command and verify no ErrorConstants are used in Validate() method. Do NOT skip this step.
3. ‚úÖ **üî¥ CRITICAL - MANDATORY CHECKPOINT:** DTO MUST extend `IRequestPopulatorDTO<DomainType>` AND implement `Populate(DomainType domain)` method
   - [ ] **STOP:** Check if Domain class exists in `Domains/<BusinessDomain>/` folder
   - [ ] **STOP:** If Domain exists ‚Üí DTO class declaration MUST extend `IRequestPopulatorDTO<DomainType>` - **üî¥ CRITICAL: Applies to ALL operations (write AND read-only)**
   - [ ] **STOP:** **üî¥ CRITICAL:** This rule applies even if request DTO only contains query parameters and Domain represents response data
   - [ ] **STOP:** **üî¥ CRITICAL:** This rule applies even if `Populate()` method will be empty (must still be implemented)
     - **‚úÖ CORRECT:** `public class <Operation>ReqDTO : IRequestDTO, IRequestPopulatorDTO<<Entity>Domain>`
     - **‚úÖ CORRECT:** `public class <Operation>ReqDTO : IRequestBaseDTO, IRequestPopulatorDTO<<Entity>Domain>`
     - **‚úÖ CORRECT:** `public class Get<Entity>ReqDTO : IRequestBaseDTO, IRequestPopulatorDTO<<Entity>Domain>` (read-only operation - still required)
     - **‚ùå WRONG:** `public class <Operation>ReqDTO : IRequestDTO` (missing `IRequestPopulatorDTO<DomainType>`)
     - **‚ùå WRONG:** Assuming read-only operations are exempt from this rule
   - [ ] **STOP:** DTO MUST have `public void Populate(DomainType domain)` method implementation
   - [ ] **STOP:** **üî¥ CRITICAL:** This applies to ALL operations, including read-only query operations (Get, List, etc.)
   - [ ] **STOP:** For read-only operations: Verify `Populate()` method exists (even if empty with explanatory comment)
   - [ ] **STOP:** Populate method MUST map ALL DTO properties to domain properties (or be empty if no mapping needed for read-only operations)
   - [ ] **BLOCKING:** Run `grep -n "\\?\\? string\\.Empty" <file>` in Populate() method ‚Üí If found ‚Üí **VIOLATION** ‚Üí Populate() must NOT use null coalescing ‚Üí Fix ‚Üí Retry
   - [ ] **BLOCKING:** Run `grep -n "if.*null.*return\\|if.*!= null\\|if.*== null" <file>` in Populate() method ‚Üí If found ‚Üí **VIOLATION** ‚Üí Populate() must NOT use null checks ‚Üí Fix ‚Üí Retry
   - [ ] **BLOCKING:** Verify Populate() method assigns directly (e.g., `domain.Property = this.Property;`) without null coalescing OR null checks
   - [ ] **üî¥ CRITICAL:** Populate() is called AFTER Validate() passes, so Validate() guarantees all mandatory properties are non-null/non-empty. Null checks are redundant and violate the architectural principle.
   - [ ] **üî¥ CRITICAL:** This step has been missed 3+ times - DO NOT SKIP THIS CHECKPOINT
4. ‚úÖ **STOP AND VERIFY:** All properties use default value `= string.Empty` (not nullable)
5. ‚úÖ **STOP AND VERIFY:** Validate() method ONLY validates MANDATORY fields (from Phase 1)
6. ‚úÖ **üî¥ CRITICAL - BLOCKING RULE:** If a header/query parameter property in Process Layer DTO is required by System Layer request DTO validation (checked via `ValidateAPIRequestParameters()` or `ValidateDownStreamRequestParameters()`), then it MUST be validated in Process Layer DTO's `Validate()` method
   - [ ] **BLOCKING:** Open System Layer Function's request DTO file
   - [ ] **BLOCKING:** Read System Layer Function's request DTO validation method (`ValidateAPIRequestParameters()` or `ValidateDownStreamRequestParameters()`)
   - [ ] **BLOCKING:** For EACH header/query parameter property in Process Layer DTO: Check if it's validated as required in System Layer DTO validation method
   - [ ] **BLOCKING:** If System Layer DTO validation requires the header/query parameter property ‚Üí MUST add validation in Process Layer DTO's `Validate()` method
   - ‚úÖ **CORRECT:** Process Layer DTO validates `<HeaderProperty>` because System Layer DTO's `ValidateAPIRequestParameters()` requires it
   - ‚ùå **WRONG:** Process Layer DTO does NOT validate `<HeaderProperty>` even though System Layer DTO's `ValidateAPIRequestParameters()` requires it
   - **Why:** Process Layer DTO validation MUST ensure all required fields for System Layer are validated before passing to System Abstraction. This prevents validation failures at System Layer and ensures early error detection.
7. ‚úÖ **STOP AND VERIFY:** DTO structure matches Phase 1 document (Section 14: Input Structure Analysis)
8. ‚úÖ **STOP AND VERIFY:** Folder name is operation-based (NOT including SOR name)
9. ‚úÖ **STOP AND VERIFY:** Each class is in its own separate file
10. ‚úÖ **STOP AND VERIFY:** Response DTOs MUST have `[JsonPropertyName]` attributes for camelCase serialization (matches Boomi contract)
11. ‚úÖ **STOP AND VERIFY:** Request DTOs MUST NOT have `[JsonPropertyName]` attributes (except `[JsonIgnore]` if needed)
12. ‚úÖ **STOP AND VERIFY:** No helper methods in DTO

**üõë IF ANY VIOLATION ‚Üí STOP ‚Üí Fix DTO ‚Üí Then proceed**

### 7.8 DTO Rules - Common Mistakes

**‚ùå Not Implementing IRequestPopulatorDTO<Domain>**

- **WRONG:** Creating Request DTO without `IRequestPopulatorDTO<DomainType>` interface
- **WRONG:** Assuming read-only query operations are exempt from this rule
- **CORRECT:** Request DTO MUST extend `IRequestPopulatorDTO<DomainType>` if Domain exists - **Applies to ALL operations (write AND read-only)**
- **Why:** `Populate()` method is mandatory for mapping DTO properties to Domain (or must be implemented even if empty for read-only operations). This rule has been missed 3+ times. Domain population ensures architectural consistency and contract enforcement across all operation types.

**‚ùå Using Nullable Types for DTO Properties**

- **WRONG:** `public string? <FieldName> { get; set; }`
- **CORRECT:** `public string <FieldName> { get; set; } = string.Empty;`
- **Why:** All DTO fields default to `string.Empty`, eliminating the need for null checks. Nullable types are not needed.

**‚ùå Validating Optional Fields**

- **WRONG:** Validating all fields, including optional ones
- **CORRECT:** Only validate MANDATORY fields (from Phase 1 document)
- **Why:** Optional fields are allowed to be empty (they default to `string.Empty`), only mandatory fields need validation.

**‚ùå Using Null Coalescing After Validation**

- **WRONG:** `dto.<FieldName> ?? string.Empty` (after `dto.Validate()` passes)
- **CORRECT:** `dto.<FieldName>` (use directly after validation)
- **Why:** After validation passes, mandatory fields are guaranteed to be non-empty. Optional fields already default to `string.Empty`. Null coalescing is redundant.

**‚ùå Using Null Checks in Populate() Method**

- **WRONG:** 
  ```csharp
  public void Populate(<Entity>Domain domain)
  {
      if (Property == null) return;  // ‚ùå VIOLATION
      if (Property != null && Property.Count > 0)  // ‚ùå VIOLATION
      {
          domain.Field = Property[0];
      }
  }
  ```
- **CORRECT:**
  ```csharp
  public void Populate(<Entity>Domain domain)
  {
      // Validate() ensures Property is not null and has at least one element
      // So we can assign directly without null checks
      domain.Field = Property![0];  // ‚úÖ Use null-forgiving operator if needed for compiler
      domain.OtherField = Property.OtherProperty!;
  }
  ```
- **Why:** 
  - `Populate()` is called AFTER `Validate()` passes in the Function
  - `Validate()` guarantees all mandatory properties are non-null/non-empty (throws exception if not)
  - After validation passes, the DTO contract is guaranteed - null checks are redundant
  - Adding null checks shows misunderstanding of the Validate() ‚Üí Populate() contract flow
  - **Architectural Principle:** "Functions trust DTOs - After Validate() passes, use properties directly"

**‚ùå Using ErrorConstants for DTO Validation Errors**

- **WRONG:** `errors.Add(ErrorConstants.PROPERTY_REQUIRED.Message);` in `Validate()` method
- **CORRECT:** `errors.Add($"{nameof(PropertyName)} is required.");` using `nameof()` with string interpolation
- **Why:** DTO validation errors are field-specific and should reference the actual property name using `nameof()`. ErrorConstants are for business logic errors (thrown by Services/System Abstractions), not DTO validation errors. Using `nameof()` ensures errors are self-documenting, maintainable, and automatically update if property names change.
- **Example (CORRECT):**
  ```csharp
  if (string.IsNullOrEmpty(EmployeeUniqueId))
  {
      errors.Add($"{nameof(EmployeeUniqueId)} is required.");
  }
  ```
- **Example (WRONG):**
  ```csharp
  if (string.IsNullOrWhiteSpace(LeaveRequest.OldLeaveId))
  {
      errors.Add(ErrorConstants.OLD_LEAVE_ID_REQUIRED.Message);  // ‚ùå PROHIBITED
  }
  ```

**‚ùå DTO Folder Naming with SOR Name**

- **WRONG:** `DTOs/<Operation><SOR>/` (e.g., `DTOs/CreateEntityD365/`)
- **CORRECT:** `DTOs/<Operation>Request/` (e.g., `DTOs/CreateEntityRequest/`)
- **Why:** DTO folder names MUST be operation-based. SOR is determined by System Abstraction, not folder name.

**‚ùå Missing JsonPropertyName Attributes in Response DTOs**

- **WRONG:** Response DTOs without `[JsonPropertyName]` attributes
- **CORRECT:** Response DTOs MUST have `[JsonPropertyName]` attributes for all properties to ensure camelCase JSON serialization matching the Boomi contract
- **Why:** Process Layer response DTOs are serialized directly to HTTP responses. Without `[JsonPropertyName]` attributes, properties serialize as PascalCase (e.g., `"Success"`), but Boomi contract requires camelCase (e.g., `"success"`). The Process Layer is responsible for correct JSON serialization to the client.
- **Example (CORRECT):**
  ```csharp
  public class LateLoginResDTO
  {
      [JsonPropertyName("success")]
      public bool Success { get; set; }
      [JsonPropertyName("message")]
      public string? Message { get; set; }
      [JsonPropertyName("messages")]
      public List<LateLoginMessageDTO>? Messages { get; set; }
  }
  ```

**‚ùå Adding JsonPropertyName Attributes to Request DTOs**

- **WRONG:** Request DTOs with `[JsonPropertyName]` attributes
- **CORRECT:** Request DTOs MUST NOT have `[JsonPropertyName]` attributes (except `[JsonIgnore]` if needed)
- **Why:** Request DTOs are deserialized using `JsonSerializerOptions` with `PropertyNameCaseInsensitive = true` (configured in `HttpRequestExtensions.cs`). This enables case-insensitive property matching, so `[JsonPropertyName]` attributes are NOT needed. Adding them adds unnecessary complexity and violates the established pattern.
- **Exception:** Use `[JsonIgnore]` if a property should not be serialized/deserialized (e.g., computed properties, internal state)

**‚ùå Over-Engineering DTO Structure**

- **WRONG:** Creating 9 separate files for nested classes when only a few properties are needed
- **CORRECT:** Single flat DTO class with direct properties matching Boomi contract exactly
- **Why:** DTO structure MUST contain ONLY the essential properties needed. Do NOT create unnecessary nested classes.

**‚ùå Unnecessary Helper Methods in DTOs**

- **WRONG:** Adding helper methods like `Get<Field>ValueFromHeader()`, `Extract<Field>()`
- **CORRECT:** DTOs should NOT have helper methods - Functions should directly access DTO properties after validation
- **Why:** DTOs are data containers with validation and population logic only. Business logic belongs in Functions or Services.

**‚ùå Multiple Nested Classes in Single File**

- **WRONG:** `<Operation>ReqDTO.cs` containing multiple nested classes all in one file
- **CORRECT:** Separate files: `<Operation>ReqDTO.cs`, `<NestedClass1>.cs`, `<NestedClass2>.cs`, etc. (ONLY if nested classes are actually required by Boomi contract)
- **Why:** Each class MUST be in its own separate file. One class per file, following standard C# conventions.

**‚ùå Creating DTOs Based on Assumptions**

- **WRONG:** Creating DTOs based on existing code patterns or assumptions
- **CORRECT:** ALWAYS create DTOs based EXACTLY on Phase 1 document and Boomi JSON profile files
- **Why:** DTOs MUST match Boomi contract EXACTLY. Assumptions lead to incorrect structures.

---

## 8. Services Rules

**üö® CRITICAL:** Services orchestrate business logic and coordinate abstraction calls. Services are the orchestration layer between Functions and System/Process Abstractions.

**üî¥ CRITICAL: Services DO NOT Orchestrate Cross-Cutting Concerns:**
- ‚úÖ **Services orchestrate:** Business logic operations (multiple System Layer calls for domain operations)
- ‚ùå **Services DO NOT orchestrate:** Cross-cutting concerns (error notifications, logging, security) - These are Function responsibilities
- **Why:** Cross-cutting concerns violate Service Separation Rule (Section 8.2) - Domain Services must not mix with cross-cutting concerns
- **Pattern:** Function orchestrates error handling by calling cross-cutting Services (e.g., `NotificationService`) in error path

**üî¥ CRITICAL: Services DO NOT Extract/Validate Headers or Query Parameters:**
- ‚úÖ **Function responsibility:** Extract headers/query parameters from `HttpRequest`, populate DTO.Headers, validate required headers
- ‚ùå **Service MUST NOT:** Extract headers from DTO.Headers, validate headers, extract query parameters
- **Why:** Header/query parameter extraction and validation are HTTP request concerns, not business logic concerns
- **Pattern:** Function reads headers ‚Üí Populates DTO.Headers ‚Üí Validates required headers ‚Üí Passes DTO to Service (Service uses DTO.Headers if needed for System Layer calls, but does NOT validate)

**üî¥ CRITICAL: Services DO NOT Orchestrate Error Notifications:**
- ‚úÖ **Function responsibility:** Orchestrate error notifications (extract execution ID, serialize request payload, construct attachment filename, call NotificationService)
- ‚ùå **Service MUST NOT:** Call NotificationService, extract execution ID, serialize request payload, construct attachment filenames
- **Why:** Error notification orchestration is a cross-cutting concern, not business logic
- **Pattern:** Service throws exception on failure ‚Üí Function catches failure in error path ‚Üí Function orchestrates error notification ‚Üí Function throws exception

### 8.1 Services Rules - Pre-Creation Validation

**üõë PRE-CREATION VALIDATION (MANDATORY - STOP IF NOT COMPLETE)**

**üö® YOU CANNOT CREATE Services UNTIL:**

1. ‚úÖ **STOP AND VERIFY:** Have I read "üî¥ CRITICAL: COMMON MISTAKES TO AVOID" section?
2. ‚úÖ **STOP AND VERIFY:** Have I completed "üîç MANDATORY FEATURE SEARCH" (search for "service")?
3. ‚úÖ **STOP AND VERIFY:** Have I checked "COMMON MISTAKES" #20 (`internal` keyword), #27 (Extra Parameter)?
4. ‚úÖ **STOP AND VERIFY:** Have I read Section 5 (System Abstractions Rules) - Services call System Abstractions?
5. ‚úÖ **STOP AND VERIFY:** Have I read Section 6 (Process Abstractions Rules) - Services call Process Abstractions?
6. ‚úÖ **STOP AND VERIFY:** Do I understand Services orchestrate, NOT implement business logic?
7. ‚úÖ **STOP AND VERIFY:** Have I verified orchestration requirements (single call vs. multiple calls)?
8. ‚úÖ **STOP AND VERIFY:** Do I understand that Services MUST accept DTOs (not Domain objects, not individual parameters)?
9. ‚úÖ **STOP AND VERIFY:** Do I understand Services MUST NOT extract/validate headers or query parameters (Function responsibility)?
10. ‚úÖ **STOP AND VERIFY:** Do I understand Services MUST NOT orchestrate error notifications (Function responsibility)?

**üõë IF ANY MISSING ‚Üí STOP ‚Üí Complete verification ‚Üí Then create Service**

**üî¥ CRITICAL: DATA PASSING RULE (MANDATORY - NEVER VIOLATE)**

**üö® BEFORE creating any Service method, you MUST verify:**
- ‚úÖ **Service methods MUST accept DTOs** (not Domain objects, not individual parameters)
- ‚úÖ **Domain objects are for internal purposes only** - Created and used within Function for business logic, validation, or other internal purposes
- ‚úÖ **DTOs are the contract between layers** - Function passes DTO to Service, Service passes DTO to System Abstraction
- ‚ùå **NEVER accept Domain objects in Service methods** - This violates the layer separation principle
- ‚ùå **NEVER accept individual parameters** - Always accept the complete DTO object

**Example:**
```csharp
// ‚úÖ CORRECT: Service accepts DTO
public async Task<HttpResponseSnapshot> CreateEntity(EntityReqDTO dto) { ... }

// ‚ùå WRONG: Service accepts Domain
public async Task<HttpResponseSnapshot> CreateEntity(EntityDomain domain) { ... }

// ‚ùå WRONG: Service accepts individual parameters
public async Task<HttpResponseSnapshot> CreateEntity(string id, string name, string code) { ... }
```

**üõë IF YOU ARE ABOUT TO CREATE A SERVICE METHOD THAT ACCEPTS DOMAIN ‚Üí STOP ‚Üí Change it to accept DTO**

**üî¥ CRITICAL: SERVICE RESPONSIBILITY RULE (MANDATORY - NEVER VIOLATE)**

**üö® Services MUST NOT perform HTTP request concerns:**
- ‚ùå **NEVER extract headers from DTO.Headers** - Function already extracted headers before passing DTO to Service
- ‚ùå **NEVER validate headers** - Function validates required headers before calling Service
- ‚ùå **NEVER extract query parameters** - Function extracts query parameters and populates DTO before calling Service
- ‚ùå **NEVER orchestrate error notifications** - Function orchestrates error notifications in error path
- ‚ùå **NEVER extract execution ID** - Function extracts execution ID for error notifications
- ‚ùå **NEVER serialize request payload** - Function serializes request payload for error notification attachments
- ‚ùå **NEVER serialize request payload BEFORE service call** - Request payload serialization MUST be in error path ONLY (when attachment is needed), NOT before service call
- ‚ùå **NEVER construct attachment filenames** - Function constructs attachment filenames for error notifications
- ‚úÖ **Services MAY use DTO.Headers** - If needed for System Layer calls (e.g., passing header values to System Abstraction), but Service does NOT extract or validate
- ‚úÖ **Services orchestrate business logic** - Multiple System Layer calls, business rule validation, data transformation
- ‚úÖ **Services throw exceptions** - On business logic failures or System Layer failures (Function handles error notification orchestration)

**Example - WRONG (Service extracting/validating headers):**
```csharp
// ‚ùå WRONG: Service extracting and validating headers
public class EntityService
{
    public async Task<HttpResponseMessage> CreateEntity(EntityReqDTO dto)
    {
        // ‚ùå WRONG: Service extracting header from DTO
        string headerValue = string.Empty;
        if (dto.Headers.TryGetValue("required-header", out string? headerValueFromDict))
        {
            headerValue = headerValueFromDict ?? string.Empty;
        }
        
        // ‚ùå WRONG: Service validating header
        if (string.IsNullOrWhiteSpace(headerValue))
        {
            throw new RequestValidationFailureException(...);
        }
        
        HttpResponseMessage response = await _entityMgmt.CreateEntity(dto);
        return response;
    }
}
```

**Example - CORRECT (Function extracts/validates, Service uses):**
```csharp
// ‚úÖ CORRECT: Function extracts and validates headers
[Function("CreateEntity")]
public async Task<BaseResponseDTO> Run([HttpTrigger(AuthorizationLevel.Anonymous, "post", Route = "entity")] HttpRequest req)
{
    EntityReqDTO? dto = await req.ReadBodyAsync<EntityReqDTO>();
    if (dto == null) throw new NoRequestBodyException(...);
    
    // ‚úÖ CORRECT: Function extracts headers
    dto.Headers = req.Headers.ToDictionary(h => h.Key.ToLower(), h => h.Value.FirstOrDefault() ?? string.Empty);
    
    // ‚úÖ CORRECT: Function validates required headers
    string requiredHeaderValue = string.Empty;
    if (dto.Headers.TryGetValue(InfoConstants.REQUIRED_HEADER_NAME, out string? headerValue))
    {
        requiredHeaderValue = headerValue ?? string.Empty;
    }
    if (string.IsNullOrWhiteSpace(requiredHeaderValue))
    {
        throw new RequestValidationFailureException(
            errorDetails: [InfoConstants.REQUIRED_HEADER_MISSING],
            stepName: "CreateEntityFunction.cs / Executing Run / RequiredHeaderValidation"
        );
    }
    
    dto.Validate();
    
    // ‚úÖ CORRECT: Function passes DTO to Service (headers already extracted and validated)
    HttpResponseMessage response = await _service.CreateEntity(dto);
    // ... rest of Function code
}

// ‚úÖ CORRECT: Service uses DTO.Headers if needed (but does NOT extract or validate)
public class EntityService
{
    public async Task<HttpResponseMessage> CreateEntity(EntityReqDTO dto)
    {
        // ‚úÖ CORRECT: Service may use DTO.Headers for System Layer calls (already extracted by Function)
        // But Service does NOT extract or validate - Function already did that
        //Add loggin in the start and end of this fucniton
        HttpResponseMessage response = await _entityMgmt.CreateEntity(dto);
        return response;
    }
}
```

### 8.2 Services Rules - Service Separation Rule

**üî¥ CRITICAL: SERVICE SEPARATION RULE (MANDATORY)**

**üö® ALWAYS create separate Services for different domain operations:**

1. ‚úÖ **Domain-specific Services** ‚Üí One Service per business domain (e.g., `EntityService`, `AnotherEntityService`, `ThirdEntityService`)
2. ‚úÖ **Cross-cutting concern Services** ‚Üí Separate Service for shared functionality (e.g., `NotificationService`, `SecurityService`, `ValidationService`)
3. ‚úÖ **Different System Abstractions** ‚Üí If a Service needs to call different System Abstractions for different purposes, consider separating them

**‚ùå WRONG Patterns:**
```csharp
// ‚ùå WRONG: Mixing domain operations with cross-cutting concerns
public class EntityService
{
    public async Task<HttpResponseSnapshot> CreateEntity(...) { ... }
    public async Task SendErrorNotification(...) { ... }  // ‚ùå Cross-cutting concern
}

// ‚ùå WRONG: Service orchestrating error handling (cross-cutting concern)
public class EntityService
{
    public async Task<HttpResponseMessage> CreateEntity(EntityReqDTO dto)
    {
        HttpResponseMessage response = await _entityMgmt.CreateEntity(dto);
        if (!response.IsSuccessStatusCode)
        {
            // ‚ùå WRONG: Service orchestrating error notification
            await _notificationService.SendErrorNotificationEmail(...);
            throw new PassThroughHttpException(...);
        }
        return response;
    }
}

// ‚ùå WRONG: Service extracting/validating headers (HTTP request concern, not business logic)
public class EntityService
{
    public async Task<HttpResponseMessage> CreateEntity(EntityReqDTO dto)
    {
        // ‚ùå WRONG: Service extracting header from DTO
        string headerValue = string.Empty;
        if (dto.Headers.TryGetValue("required-header", out string? headerValueFromDict))
        {
            headerValue = headerValueFromDict ?? string.Empty;
        }
        
        // ‚ùå WRONG: Service validating header
        if (string.IsNullOrWhiteSpace(headerValue))
        {
            throw new RequestValidationFailureException(...);
        }
        
        HttpResponseMessage response = await _entityMgmt.CreateEntity(dto);
        return response;
    }
}

// ‚ùå WRONG: Mixing different domain operations
public class EntityService
{
    public async Task<HttpResponseSnapshot> CreateEntity(...) { ... }
    public async Task<HttpResponseSnapshot> CreateAnotherEntity(...) { ... }  // ‚ùå Different domain
}
```

**‚úÖ CORRECT Patterns:**
```csharp
// ‚úÖ CORRECT: Domain-specific Service (orchestrates business logic only)
public class EntityService
{
    public async Task<HttpResponseMessage> CreateEntity(EntityReqDTO dto)
    {
        // ‚úÖ CORRECT: Service uses DTO.Headers if needed for System Layer calls (but does NOT extract/validate)
        // Function already extracted and validated headers before passing DTO to Service
        HttpResponseMessage response = await _entityMgmt.CreateEntity(dto);
        if (!response.IsSuccessStatusCode)
        {
            // ‚úÖ CORRECT: Service throws exception, does NOT orchestrate error handling
            BaseResponseDTO errorResponse = await response.ExtractBaseResponseAsync();
            throw new PassThroughHttpException(errorResponse, response.StatusCode);
        }
        return response;
    }
    public async Task<HttpResponseSnapshot> UpdateEntity(...) { ... }
}

// ‚úÖ CORRECT: Function extracts/validates headers, then passes DTO to Service
[Function("CreateEntity")]
public async Task<BaseResponseDTO> Run([HttpTrigger(AuthorizationLevel.Anonymous, "post", Route = "entity")] HttpRequest req)
{
    EntityReqDTO? dto = await req.ReadBodyAsync<EntityReqDTO>();
    if (dto == null) throw new NoRequestBodyException(...);
    
    // ‚úÖ CORRECT: Function extracts headers
    dto.Headers = req.Headers.ToDictionary(h => h.Key.ToLower(), h => h.Value.FirstOrDefault() ?? string.Empty);
    
    // ‚úÖ CORRECT: Function validates required headers
    string requiredHeaderValue = string.Empty;
    if (dto.Headers.TryGetValue(InfoConstants.REQUIRED_HEADER_NAME, out string? headerValue))
    {
        requiredHeaderValue = headerValue ?? string.Empty;
    }
    if (string.IsNullOrWhiteSpace(requiredHeaderValue))
    {
        throw new RequestValidationFailureException(
            errorDetails: [InfoConstants.REQUIRED_HEADER_MISSING],
            stepName: "CreateEntityFunction.cs / Executing Run / RequiredHeaderValidation"
        );
    }
    
    dto.Validate();
    
    // ‚úÖ CORRECT: Function passes DTO to Service (headers already extracted and validated)
    HttpResponseMessage response = await _service.CreateEntity(dto);
    
    if (response.IsSuccessStatusCode)
    {
        // Success path
        return new BaseResponseDTO(...);
    }
    else
    {
        // ‚úÖ CORRECT: Function orchestrates error notification (cross-cutting concern)
        string executionId = RequestHeaders.RequestId.Item2.Value?.ToString() ?? string.Empty;
        string requestPayload = JsonSerializer.Serialize(dto);
        string errorMessage = ErrorConstants.CREATE_ENTITY_FAILURE.Message;
        
        BaseResponseDTO errorResponse = await response.ExtractBaseResponseAsync();
        if (errorResponse != null && !string.IsNullOrWhiteSpace(errorResponse.Message))
        {
            errorMessage = errorResponse.Message;
        }
        
        await _notificationService.SendErrorNotificationEmail(
            processName: InfoConstants.PROCESS_NAME,
            environment: _options.Environment,
            executionId: executionId,
            errorMessage: errorMessage,
            attachmentFileName: $"{_options.FileName}{DateTime.UtcNow:yyyy-MM-ddTHH:mm:ss.fffZ}.txt",
            attachmentContent: requestPayload);
        
        throw new PassThroughHttpException(errorResponse, response.StatusCode);
    }
}

// ‚úÖ CORRECT: Separate Service for cross-cutting concerns
public class NotificationService
{
    public async Task SendErrorNotification(...) { ... }
    public async Task SendSuccessNotification(...) { ... }
}

// ‚úÖ CORRECT: Function orchestrates error handling (cross-cutting concern)
[Function("CreateEntity")]
public async Task<BaseResponseDTO> Run(...)
{
    HttpResponseMessage response = await _service.CreateEntity(dto);
    if (response.IsSuccessStatusCode)
    {
        // Success path
        return new BaseResponseDTO(...);
    }
    else
    {
        // ‚úÖ CORRECT: Function orchestrates error notification (cross-cutting concern)
        await _notificationService.SendErrorNotificationEmail(...);
        throw new PassThroughHttpException(...);
    }
}
```

**Key Principles:**
- **Single Responsibility:** Each Service should have one clear purpose
- **Domain Separation:** Different business domains = Different Services
- **Cross-cutting Concerns:** Shared functionality (notifications, security, validation) = Separate Services
- **Reusability:** Cross-cutting Services can be reused across multiple domain Services
- **Orchestration Separation:** Domain Services orchestrate business logic; Functions orchestrate cross-cutting concerns (error handling, notifications)
- **Error Handling:** Services throw exceptions; Functions orchestrate error notifications (call `NotificationService` in error path)
- **Header/Query Parameter Extraction:** Functions extract and validate headers/query parameters; Services use DTO.Headers if needed but do NOT extract or validate
- **Request Validation:** Functions validate HTTP request concerns (headers, query parameters, request body); Services validate business logic concerns only

### 8.3 Services Rules - Structure & Patterns

**Service with System Abstraction (Simple):**

```csharp
// Service implementation (interface optional)
public class <Entity>Service {
    private readonly ILogger<<Entity>Service> _logger; 
    private readonly I<Entity>Mgmt _entityMgmt;  // ‚úÖ System Abstraction injected via interface
    
    public <Entity>Service(ILogger<<Entity>Service> logger, I<Entity>Mgmt entityMgmt) { 
        _logger = logger; 
        _entityMgmt = entityMgmt; 
    }
    
    public async Task<HttpResponseSnapshot> GetData(<Entity>ReqDTO dto) {
        _logger.Info($"[Process Layer]-Initiating GetData for: {dto.Id}");
        HttpResponseSnapshot r = await _entityMgmt.GetDataDetails(dto);
        _logger.Info($"[Process Layer]-Completed GetData"); 
        return r;
    }
}

// Optional: Service with interface (if needed)
public interface I<Entity>Service {
    Task<HttpResponseSnapshot> GetData(<Entity>ReqDTO dto);
}
public class <Entity>Service : I<Entity>Service {
    // Same implementation as above
}
```

**Service with Process Abstraction (Validation & Error Handling):**

```csharp
public class <Entity>Service : I<Entity>Service {
    private readonly I<Entity>Proc _entityProc;  // ‚úÖ Process Abstraction injected via interface
    private readonly ILogger<<Entity>Service> _logger;
    
    public <Entity>Service(I<Entity>Proc entityProc, ILogger<<Entity>Service> logger) { 
        _entityProc = entityProc; 
        _logger = logger; 
    }
    
    public async Task<<Entity>ResDTO> VerifyEntity(<Entity>ReqDTO request) {
        <Entity>ResDTO dto = new <Entity>ResDTO();
        HttpResponseMessage r = await _entityProc.GetEntity(request);
        if (!r.IsSuccessStatusCode) throw new PassThroughHttpException(r.ExtractBaseResponse().Result, r.StatusCode);
        ResponseDTOHelper.PopulateEntity(await r.ExtractDataAsync(), dto);
        if (dto.Items == null || !dto.Items.Any()) throw new BusinessCaseFailureException(ErrorConstants.ENTITY_NOT_FOUND, [ErrorConstants.ENTITY_NOT_FOUND.Message], stepName: "<Entity>Service.cs / VerifyEntity");
        return dto;
    }
}
```

**Service with Repository & Cache (Central Data Layer):**

```csharp
public class <Entity>Service : I<Entity>Service {
    private readonly ILogger<<Entity>Service> _logger;
    private readonly IExternalSys _externalSys;
    private readonly IConfigRepository _configRepo;
    
    public <Entity>Service(ILogger<<Entity>Service> logger, IExternalSys externalSys, IConfigRepository configRepo) { 
        _logger = logger; 
        _externalSys = externalSys; 
        _configRepo = configRepo; 
    }
    
    public async Task<BaseResponseDTO> ProcessData(DataReqDTO req) {
        _logger.Info("[Process Layer]-Initiating ProcessData");
        Config? config = await _configRepo.GetAsync(x => x.Id == Convert.ToInt32(req.Headers["config-id"]));
        if (config == null) throw new HttpBaseServerException(ErrorConstants.CONFIG_NOT_FOUND.Message, ErrorConstants.CONFIG_NOT_FOUND.ErrorCode, HttpStatusCode.InternalServerError, [ErrorConstants.CONFIG_NOT_FOUND.Message], stepName: "<Entity>Service.cs / ProcessData");
        
        CacheKey cacheKey = CacheKey.CreateCacheKey(req.GetCacheKey(), _namespace: "data", _cacheKeySettings: new CacheKeySettings { TimeToLive = TimeSpan.FromMinutes(config.CacheTTL) });
        <Entity>? cachedData = await cacheKey.GetAsync<<Entity>>();
        if (cachedData != null && cachedData.IsValid()) return new BaseResponseDTO("Success", "", new DataResDTO { Id = cachedData.Id });
        
        <Entity> entity = BuildEntity(req.Payload, config);
        HttpResponseSnapshot r = await _externalSys.SendData(req, entity);
        if (!r.IsSuccessStatusCode) { 
            await cacheKey.DeleteAsync(); 
            throw new PassThroughHttpException(r.ExtractBaseResponse().Result, r.StatusCode); 
        }
        await cacheKey.SetAsync(entity);
        _logger.Info("[Process Layer]-Completed ProcessData");
        return new BaseResponseDTO("Success", "", new DataResDTO { Id = entity.Id });
    }
    
    private <Entity> BuildEntity(string payload, Config config) { 
        return new <Entity> { Payload = payload, ConfigId = config.Id, ProcessedAt = DateTime.UtcNow }; 
    }
}
```

**Service with Orchestration (Multiple System Abstractions):**

```csharp
public class <Entity>OrchestrationService {
    private readonly ILogger<<Entity>OrchestrationService> _logger;
    private readonly I<Entity>Mgmt _entityMgmt;
    private readonly IReferenceMgmt _referenceMgmt;
    private readonly IDataMgmt _dataMgmt;
    
    public <Entity>OrchestrationService(ILogger<<Entity>OrchestrationService> logger, I<Entity>Mgmt entityMgmt, IReferenceMgmt referenceMgmt, IDataMgmt dataMgmt) { 
        _logger = logger; 
        _entityMgmt = entityMgmt; 
        _referenceMgmt = referenceMgmt; 
        _dataMgmt = dataMgmt; 
    }
    
    public async Task<<Entity>ResDTO> ProcessEntity(<Entity>ReqDTO dto, string typeFilter) {
        _logger.Info($"[Process Layer]-Initiating ProcessEntity for: {dto.Id}");
        
        HttpResponseSnapshot r1 = await _entityMgmt.GetDetails(dto);
        if (!r1.IsSuccessStatusCode) throw new PassThroughHttpException(r1.ExtractBaseResponse(), (HttpStatusCode)r1.StatusCode);
        
        <Entity>ResDTO entityDto = new <Entity>ResDTO();
        ResponseDTOHelper.PopulateEntity(r1.ExtractData(), entityDto);
        
        HttpResponseSnapshot r2 = await _referenceMgmt.GetLookupValues(new ReferenceReqDTO { Type = typeFilter });
        if (!r2.IsSuccessStatusCode) throw new PassThroughHttpException(r2.ExtractBaseResponse(), (HttpStatusCode)r2.StatusCode);
        
        ReferenceResDTO refData = ResponseDTOHelper.PopulateReference(r2.ExtractData());
        string typeCode = refData.Items?.FirstOrDefault(i => string.Equals(i.Name, entityDto.TypeName))?.Code ?? "";
        if (string.IsNullOrEmpty(typeCode)) throw new BusinessCaseFailureException(ErrorConstants.INVALID_TYPE, [ErrorConstants.INVALID_TYPE.Message], stepName: "<Entity>OrchestrationService.cs / ProcessEntity");
        
        entityDto.TypeCode = typeCode;
        entityDto.TypeDescription = refData.Items?.FirstOrDefault(i => i.Code == typeCode)?.Description;
        _logger.Info($"[Process Layer]-Completed ProcessEntity");
        return entityDto;
    }
}
```

### 8.4 Services Rules - Handling Multiple Failures

**üö® CRITICAL:** When multiple operations fail (e.g., first operation fails AND second operation fails), merge error details from both responses into a single BaseResponseDTO to ensure all failures are reported.

**Pattern:**
1. Extract BaseResponseDTO from each failed response
2. Merge ErrorDetails.Errors from all failed responses
3. Create a new BaseResponseDTO with merged errors
4. Throw PassThroughHttpException with the merged response

**Example - Multiple Operations Fail:**
```csharp
if (!firstResponse.IsSuccessStatusCode)
{
    BaseResponseDTO firstError = firstResponse.ExtractBaseResponse();
    HttpResponseSnapshot secondResponse = await CallSecondOperation(dto);
    
    if (!secondResponse.IsSuccessStatusCode)
    {
        BaseResponseDTO secondError = secondResponse.ExtractBaseResponse();
        List<Step> mergedErrors = new List<Step>();
        mergedErrors.AddRange(firstError.ErrorDetails?.Errors ?? new List<Step> { new Step { StepName = "FirstOperation", StepError = firstError.Message } });
        mergedErrors.AddRange(secondError.ErrorDetails?.Errors ?? new List<Step> { new Step { StepName = "SecondOperation", StepError = secondError.Message } });
        
        throw new PassThroughHttpException(new BaseResponseDTO(
            message: $"Multiple failures: {firstError.Message}; Second operation failed: {secondError.Message}",
            errorCode: firstError.ErrorCode, data: null,
            errorDetails: new ErrorDetails { Errors = mergedErrors }, isDownStreamError: true),
            (HttpStatusCode)firstResponse.StatusCode);
    }
    throw new PassThroughHttpException(firstError, (HttpStatusCode)firstResponse.StatusCode);
}
```

**Why:** When multiple operations fail, all failures must be reported to ensure visibility. Merging error details into a single BaseResponseDTO ensures all failures are captured in the response.

### 8.5 Services Rules - Critical Async Pattern

**üî¥ CRITICAL ASYNC PATTERN - NEVER VIOLATE:**

**‚ùå PROHIBITED PATTERNS:**
- ‚ùå **NEVER use `_ = Task.Run(...)`** - Fire-and-forget pattern is prohibited
- ‚ùå **NEVER use `_ = await ...`** - Discarding task results is prohibited (always store return values)
- ‚ùå **NEVER use `Task.Run(async () => await ...)`** - Background task pattern is prohibited
- ‚ùå **NEVER use `async void`** - Exception handling issues
- ‚ùå **NEVER use `.Result`, `.Wait()`, `.GetAwaiter().GetResult()`** - Blocking calls cause deadlocks
- ‚ùå **NEVER use `try-catch`** - Let exceptions propagate to middleware for proper error handling
- ‚ùå **üî¥ NEVER EVER use `var` keyword** - Always use explicit types for clarity and consistency (MANDATORY - NO EXCEPTIONS)

**‚úÖ CORRECT PATTERNS:**
- ‚úÖ **Always use `await`** for all asynchronous operations
- ‚úÖ **Always store return values** - System/Process Abstraction calls return HttpResponseSnapshot, always store in variable
- ‚úÖ **Always check non-200 responses** - Throw PassThroughHttpException for non-success status codes
- ‚úÖ **Let exceptions propagate** to middleware for proper error handling
- ‚úÖ **Middleware handles all exceptions** - ExceptionHandlerMiddleware normalizes all exceptions to BaseResponseDTO
- ‚úÖ **üî¥ ALWAYS use explicit types** - Never use `var`, always specify type explicitly (MANDATORY - NO EXCEPTIONS)

**Example - Error Notification (CORRECT):**
```csharp
if (!primaryResponse.IsSuccessStatusCode)
{
    // ‚úÖ CORRECT - Store return value (HttpResponseSnapshot) for consistency
    HttpResponseSnapshot notificationResponse = await SendErrorNotification(dto);
    // ‚úÖ CORRECT - Check notification response status and throw exception if not successful
    if (!notificationResponse.IsSuccessStatusCode)
        throw new PassThroughHttpException(notificationResponse.ExtractBaseResponse(), (HttpStatusCode)notificationResponse.StatusCode);
    // Throw PassThroughHttpException to propagate downstream error
    throw new PassThroughHttpException(primaryResponse.ExtractBaseResponse(), (HttpStatusCode)primaryResponse.StatusCode);
}
```

**Example - System Abstraction Call (CORRECT):**
```csharp
// ‚úÖ CORRECT - Explicit type, store return value
HttpResponseSnapshot response = await _systemAbstraction.CallSystemLayer();
if (!response.IsSuccessStatusCode)
    throw new PassThroughHttpException(response.ExtractBaseResponse(), (HttpStatusCode)response.StatusCode);
```

**Example - Error Notification (WRONG):**
```csharp
// ‚ùå WRONG - Task.Run is prohibited
_ = Task.Run(async () => await SendErrorNotification(dto));
// ‚ùå WRONG - try-catch is prohibited (let middleware handle exceptions)
try { await SendErrorNotification(dto); }
catch (Exception notificationEx) { _logger.Error(notificationEx, "Failed to send notification"); }
```

### 8.6 Services Rules - Key Rules

| Rule | Pattern | When to Use |
|------|---------|-------------|
| **Interfaces** | `public class <Entity>Service : I<Entity>Service` | ‚ö†Ô∏è **OPTIONAL** - Services can have interfaces if needed |
| **No Interface** | `public class <Entity>Service` | ‚úÖ **ALLOWED** - Services without interfaces are valid |
| **Method Visibility** | `public` | Methods MUST be public (NEVER `internal`) |
| **Constructor** | Inject: ILogger, Abstractions (via interface), Repositories (via interface), IOptions<Config> | Always inject dependencies, System/Process Abstractions MUST be via interface |
| **System Abstraction Injection** | `private readonly I<Entity>Mgmt _entityMgmt;` | ‚úÖ **MANDATORY** - MUST inject System Abstractions via interface |
| **Process Abstraction Injection** | `private readonly I<Entity>Proc _entityProc;` | ‚úÖ **MANDATORY** - MUST inject Process Abstractions via interface |
| **Function Injection** | `private readonly <Entity>Service _service;` OR `private readonly I<Entity>Service _service;` | ‚úÖ Both patterns allowed - direct injection or via interface |
| **Logging Start** | `_logger.Info("[Process Layer]-Initiating MethodName")` | ALWAYS at method start - **üî¥ REQUIRES `using Core.Extensions;`** |
| **Logging End** | `_logger.Info("[Process Layer]-Completed MethodName")` | ALWAYS before return - **üî¥ REQUIRES `using Core.Extensions;`** |
| **Logging Error** | `_logger.Error("Description")` or `_logger.Warn("Warning")` | Before throwing exceptions or recoverable issues - **üî¥ REQUIRES `using Core.Extensions;`** |
| **‚ùå PROHIBITED** | `_logger.LogInformation()` or `_logger.LogError()` | **NEVER use** - Must use `Info()`/`Error()` extension methods from `Core.Extensions` |
| **Return Type** | `HttpResponseSnapshot` for System Layer calls | When returning cached System Layer response |
| **Return Type** | `BaseResponseDTO` for API responses | When service is called directly from Function |
| **Return Type** | `{Entity}ResDTO` for orchestration | When service is called by other services |
| **Error Handling** | `PassThroughHttpException` for downstream failures | Always wrap downstream HTTP failures |
| **Error Handling** | `BusinessCaseFailureException` for business validation | Always use for domain validation failures |
| **Error Handling** | `HttpBaseServerException` for server errors | Central data layer only - DB/config failures |
| **Error Handling** | `NotFoundException` for not found cases | When expected data is missing |
| **stepName** | `"ClassName.cs / Executing MethodName"` | ALWAYS include in all exceptions |

**üî¥ CRITICAL RULES:**

1. ‚úÖ Services MUST inject System/Process Abstractions via interface
2. ‚úÖ Services can be registered with or without interfaces (interface is optional)
3. ‚úÖ Services MUST accept DTOs (not Domain objects, not individual parameters)
4. ‚úÖ Services MUST use `await` and store return values (NEVER discard task results)
5. ‚úÖ Services MUST check response status and throw exceptions for non-success
6. ‚úÖ Services MUST have logging (entry and exit) using `_logger.Info()`
7. ‚ùå **NEVER use `var` keyword** - Always use explicit types
8. ‚ùå **NEVER use `internal` keyword** - Methods MUST be public
9. ‚ùå **NEVER use `try-catch` blocks** - Let exceptions propagate to middleware
10. ‚ùå **NEVER discard task results** - Always store return values

### 8.7 Services Rules - DI Registration Patterns

**üö® CRITICAL:** Services can be registered with or without interfaces. System/Process Abstractions MUST be registered with interfaces.

```csharp
// ‚úÖ CORRECT - Service without interface (direct injection)
builder.Services.AddScoped<<Entity>Service>();
builder.Services.AddScoped<DataService>();

// ‚úÖ CORRECT - Service with interface (if interface exists)
builder.Services.AddScoped<I<Entity>Service, <Entity>Service>();
builder.Services.AddScoped<IDataService, DataService>();

// ‚úÖ CORRECT - Central Data Layer (typically with interface for public APIs)
builder.Services.AddScoped<ISecurityService, SecurityService>();
builder.Services.AddScoped<IReferenceService, ReferenceService>();

// ‚úÖ CORRECT - Transient for stateless utilities
builder.Services.AddTransient<DataService>();
// OR
builder.Services.AddTransient<IDataService, DataService>();
```

### 8.8 Services Rules - Method Naming Conventions

| Operation | Method Name Pattern | Example |
|-----------|-------------------|---------|
| Create | `Create{Entity}` | `CreateEntity`, `CreateToken` |
| Get Single | `Get{Entity}` | `GetEntity`, `GetDetails` |
| Get List | `Get{Entity}List` or `Retrieve{Entity}` | `GetEntityList`, `RetrieveEntities` |
| Update | `Update{Entity}` | `UpdateEntity`, `UpdateStatus` |
| Delete | `Delete{Entity}` | `DeleteEntity`, `RemoveToken` |
| Validate | `Validate{Entity}` | `ValidateToken`, `ValidateEntity` |
| Verify | `Verify{Entity}` | `VerifyEntity`, `VerifyCredentials` |
| Process | `Process{Entity}` | `ProcessEntity`, `ProcessData` |
| Generate | `Generate{Entity}` | `GenerateToken`, `GenerateCode` |

### 8.9 Services Rules - Post-Creation Validation

**üõë POST-CREATION VALIDATION FOR SERVICES (MANDATORY - VERIFY BEFORE PROCEEDING)**

**üö® AFTER creating Service, you MUST verify (BLOCKING - CANNOT SAVE FILE UNTIL ALL PASS):**

**üî¥ MANDATORY VIOLATION CHECKS (RUN BEFORE SAVING FILE - SYSTEMATIC FILE-BY-FILE VALIDATION):**

**üö® CRITICAL: You MUST systematically review the ENTIRE file line by line against ALL applicable rules. Missing even ONE check is a VIOLATION.**

**üî¥ MANDATORY VALIDATION PROCESS:**
1. **Read the ENTIRE file** from top to bottom (every line, every method, every class)
2. **For EACH line/section**, check against ALL applicable rules below
3. **Document violations** as you find them (file name, line number, rule violated, violation description)
4. **Fix ALL violations** before proceeding
5. **Re-read the ENTIRE file** after fixes to verify all violations are resolved
6. **Complete ALL checkpoints** (Steps 1-9) systematically

**Initial Systematic Checks:**
- [ ] **BLOCKING:** Read the ENTIRE file line by line ‚Üí Look for `LogInformation` or `LogError` ‚Üí If found ‚Üí **VIOLATION** ‚Üí Must use `_logger.Info()` or `_logger.Error()` ‚Üí Document line number ‚Üí Fix ‚Üí Re-read file
- [ ] **BLOCKING:** Read the ENTIRE file line by line ‚Üí Look for `internal async Task` or `internal Task` ‚Üí If found ‚Üí **VIOLATION** ‚Üí Service methods MUST be public ‚Üí Document line number ‚Üí Fix ‚Üí Re-read file
- [ ] **BLOCKING:** Read the ENTIRE file line by line ‚Üí Look for ALL Service method signatures ‚Üí For EACH: Verify it accepts ONLY DTO (not individual parameters) ‚Üí If violation ‚Üí **VIOLATION** ‚Üí Document line number ‚Üí Fix ‚Üí Re-read file
- [ ] **BLOCKING:** Verify file has `using Core.Extensions;` (if using `_logger.Info()` extension method)

1. ‚úÖ **üî¥ CRITICAL - MANDATORY CHECKPOINT:** Service separation rule is followed
   - [ ] **BLOCKING:** Did I list ALL methods in this Service class?
   - [ ] **BLOCKING:** Did I classify EACH method as:
     - Domain operation (e.g., `Create<Entity>`, `Update<Entity>`, `Get<Entity>`)
     - Cross-cutting concern (e.g., `SendErrorNotification`, `SendEmail`, `LogError`)
   - [ ] **BLOCKING:** Does this Service contain BOTH domain operations AND cross-cutting concerns?
   - [ ] **BLOCKING:** If YES ‚Üí **VIOLATION** - Must separate into two Services:
     - Domain Service: `<Entity>Service` (e.g., `Create<Entity>Service`) - for domain operations only
     - Cross-cutting Service: `NotificationService` (or `SecurityService`, `ValidationService`) - for shared functionality
   - [ ] **BLOCKING:** Did I verify NO Service contains both types of methods?
   - [ ] **BLOCKING:** Did I document the separation decision in validation report?
   - ‚úÖ **CORRECT:** `<Entity>Service` contains ONLY domain operations (e.g., `Create<Entity>Documents`)
   - ‚úÖ **CORRECT:** `NotificationService` contains ONLY cross-cutting concerns (e.g., `SendErrorNotificationEmail`)
   - ‚ùå **WRONG:** `<Entity>Service` contains both `Create<Entity>Documents` AND `SendErrorNotificationEmail` - **PROHIBITED**
   - ‚ùå **WRONG:** Mixing domain operations with cross-cutting concerns in same Service - **PROHIBITED**
   - **üî¥ CRITICAL:** This rule has been missed - DO NOT SKIP THIS CHECKPOINT
   - **OUTPUT REQUIRED:** Document Service method classification in validation report. If separation needed ‚Üí Create separate Service classes ‚Üí Re-verify

2. ‚úÖ **üî¥ CRITICAL - MANDATORY CHECKPOINT:** Service methods accept DTOs, NOT Domain objects
   - [ ] **STOP:** Did I verify ALL Service methods accept DTOs (e.g., `<Operation>ReqDTO`)?
   - [ ] **STOP:** Did I verify NO Service methods accept Domain objects (e.g., `<Entity>Domain`)?
   - ‚úÖ **CORRECT:** `public async Task<HttpResponseSnapshot> Create<Entity>Documents(<Entity>ReqDTO request)`
   - ‚ùå **WRONG:** `public async Task<HttpResponseSnapshot> Create<Entity>Documents(<Entity> domain)` - **PROHIBITED**
   - **üî¥ CRITICAL:** Service methods MUST accept DTOs, Domain objects stay in Function for internal use only

3. ‚úÖ **üî¥ CRITICAL - MANDATORY CHECKPOINT:** Service methods do NOT have extra parameters
   - [ ] **BLOCKING:** Read the ENTIRE file line by line ‚Üí Look for ALL Service method signatures
   - [ ] **BLOCKING:** For EACH Service method signature found:
     - [ ] Does it accept ONLY a DTO parameter (e.g., `(<Operation>ReqDTO request)`)? ‚Üí ‚úÖ PASS
     - [ ] Does it accept multiple individual parameters (e.g., `(string param1, string param2, ...)`)? ‚Üí **VIOLATION** ‚Üí Document line number
     - [ ] Does it accept DTO + extra parameters (e.g., `(<Operation>ReqDTO request, string param1)`)? ‚Üí **VIOLATION** ‚Üí Document line number
   - [ ] **BLOCKING:** If ANY violations found ‚Üí STOP ‚Üí Create DTO for all parameters ‚Üí Update Service method signature ‚Üí Re-read file ‚Üí Verify only DTO parameters
   - [ ] **BLOCKING:** Re-read file ‚Üí Verify ALL Service methods accept ONLY DTO parameters (no individual parameters)
   - ‚úÖ **CORRECT:** `public async Task<HttpResponseSnapshot> Create<Entity>Documents(<Entity>ReqDTO request)` - all data in DTO
   - ‚úÖ **CORRECT:** `public async Task<HttpResponseSnapshot> SendErrorNotificationEmail(<ErrorNotificationEmail>ReqDTO request)` - all data in DTO
   - ‚ùå **WRONG:** `public async Task<HttpResponseSnapshot> Create<Entity>Documents(<Entity>ReqDTO request, string <parameter>)` - **PROHIBITED**
   - ‚ùå **WRONG:** `public async Task<HttpResponseSnapshot> SendErrorNotificationEmail(string processName, string environment, string executionId, ...)` - **PROHIBITED**
   - **üî¥ CRITICAL:** All data MUST flow through DTOs, never add extra parameters
   - **üö® CRITICAL:** You MUST read the entire file systematically and verify ALL Service methods accept ONLY DTO parameters. Do NOT skip this step.

4. ‚úÖ **STOP AND VERIFY:** Service injects System/Process Abstractions via interface
   - ‚úÖ **CORRECT:** `private readonly I<Entity>Mgmt _entityMgmt;` (injected via interface)
   - ‚ùå **WRONG:** `private readonly <Entity>MgmtSys _entityMgmt;` (injected as concrete class)

5. ‚úÖ **STOP AND VERIFY:** Service methods use `await` and store return values
   - ‚úÖ **CORRECT:** `HttpResponseSnapshot response = await _entityMgmt.Create<Entity>(request);`
   - ‚ùå **WRONG:** `_ = await _entityMgmt.Create<Entity>(request);` (discarding return value - **PROHIBITED**)

6. ‚úÖ **STOP AND VERIFY:** Service methods check response status and throw exceptions for non-success
   - ‚úÖ **CORRECT:** `if (!response.IsSuccessStatusCode) throw new PassThroughHttpException(...);`
   - ‚ùå **WRONG:** Ignoring response status codes

7. ‚úÖ **STOP AND VERIFY:** Service has logging (entry and exit)
   - [ ] **BLOCKING:** Read the ENTIRE file line by line ‚Üí Verify logging uses `_logger.Info()` (NOT `LogInformation()`) ‚Üí If found ‚Üí **VIOLATION** ‚Üí Document line number ‚Üí Fix ‚Üí Re-read file
   - [ ] **BLOCKING:** Verify file has `using Core.Extensions;` (required for `Info()` extension method)
   - ‚úÖ **CORRECT:** `_logger.Info($"[Process Layer]-{InfoConstants.CREATE_<ENTITY>_STARTED}");` at start
   - ‚úÖ **CORRECT:** `_logger.Info($"[Process Layer]-{InfoConstants.CREATE_<ENTITY>_COMPLETED}");` at end
   - ‚ùå **WRONG:** `_logger.LogInformation(...)` - **VIOLATION** - Must use `_logger.Info()`

8. ‚úÖ **STOP AND VERIFY:** Service is registered in `Program.cs` DI container
   - ‚úÖ **CORRECT:** `builder.Services.AddScoped<<Entity>Service>();`
   - ‚úÖ **CORRECT:** `builder.Services.AddScoped<NotificationService>();` (if cross-cutting service exists)

9. ‚úÖ **üî¥ CRITICAL - MANDATORY CHECKPOINT:** Email template validation (if Service contains email notification methods)
   - [ ] **BLOCKING:** Read the ENTIRE file line by line ‚Üí Check if this Service contains email notification methods (e.g., `SendErrorNotificationEmail`, `SendEmail`, `SendNotification`)
   - [ ] **BLOCKING:** If YES ‚Üí Did I verify email templates are embedded HTML resources (NOT hardcoded strings)?
   - [ ] **BLOCKING:** Read the ENTIRE file line by line ‚Üí Look for email body construction patterns (`emailBody`, `BuildErrorEmailBody`, HTML strings, etc.)
   - [ ] **BLOCKING:** For EACH email body construction found:
     - [ ] Is it calling a helper method that reads embedded template (e.g., `ResponseDTOHelper.ReadEmailTemplate(...)`)? ‚Üí ‚úÖ PASS
     - [ ] Is it a hardcoded HTML string (e.g., `$@"<!DOCTYPE html>..."` or `"<html>..."`)? ‚Üí **VIOLATION** ‚Üí Must use embedded template ‚Üí Document line number ‚Üí Fix ‚Üí Re-read file
     - [ ] Is it a private method that builds email body with hardcoded HTML? ‚Üí **VIOLATION** ‚Üí Must use embedded template ‚Üí Document line number ‚Üí Fix ‚Üí Re-read file
   - [ ] **BLOCKING:** Did I verify `EmailTemplate/<TemplateName>.html` folder and file exist (where `<TemplateName>` is the specific template name for this process)?
   - [ ] **BLOCKING:** Did I verify email template is marked as `EmbeddedResource` in .csproj?
   - [ ] **BLOCKING:** Did I verify email body uses embedded template (via helper method) instead of hardcoded string?
   - [ ] **BLOCKING:** Did I read Boomi subprocess JSON file (subprocess_*.json) to find email template?
   - [ ] **BLOCKING:** Did I locate email template in subprocess JSON (search for "msgTxt" or "MailBody" in message/documentproperties shapes)?
   - [ ] **BLOCKING:** Did I extract EXACT email template HTML from Boomi subprocess JSON (copy entire template including DOCTYPE, html, head, body tags)?
   - [ ] **BLOCKING:** Did I verify email template structure matches Boomi subprocess template EXACTLY (same tags, same structure, same placeholders, same whitespace) by comparing line-by-line?
   - [ ] **BLOCKING:** Did I verify email template placeholders match Boomi subprocess placeholders EXACTLY (e.g., `{1}`, `{2}`, `{3}`, `{4}` - verify order and numbering from msgParameters section)?
   - [ ] **BLOCKING:** Did I verify placeholder order matches Boomi subprocess parameter order (check msgParameters in subprocess JSON to verify key values and their corresponding process properties)?
   - [ ] **BLOCKING:** Did I verify placeholders in email template are populated from correct sources (check Phase 1 Section 9 - Properties Read table and subprocess JSON msgParameters)?
   - [ ] **BLOCKING:** Did I verify placeholder population uses `string.Format()` with correct parameter order matching Boomi subprocess msgParameters key order?
   - [ ] **BLOCKING:** Read the ENTIRE file line by line ‚Üí Verify NO hardcoded email HTML strings in Service code (e.g., `string.Format(InfoConstants.EMAIL_BODY_TEMPLATE, ...)`)
   - [ ] **BLOCKING:** Read InfoConstants.cs and ErrorConstants.cs files ‚Üí Verify NO email HTML constants exist
   - ‚úÖ **CORRECT:** Email notification uses embedded HTML template: `string template = ResponseDTOHelper.ReadEmailTemplate("<ProjectName>.EmailTemplate.<TemplateName>.html"); string emailBody = string.Format(template, processName, environment, executionId, errorMessage);`
   - ‚úÖ **CORRECT:** Email template file exists: `EmailTemplate/<TemplateName>.html` with exact Boomi HTML structure extracted from subprocess JSON msgTxt section
   - ‚úÖ **CORRECT:** Email template marked as embedded resource in .csproj: `<EmbeddedResource Include="EmailTemplate\<TemplateName>.html" />`
   - ‚ùå **WRONG:** Hardcoded email body: `string emailBody = string.Format(InfoConstants.EMAIL_BODY_TEMPLATE, ...);` - **PROHIBITED**
   - ‚ùå **WRONG:** Email HTML hardcoded in constants: `EMAIL_BODY_TEMPLATE = "Process: {0}<br>..."` in `InfoConstants.cs` - **PROHIBITED**
   - ‚ùå **WRONG:** Email template doesn't match Boomi structure from subprocess JSON - **PROHIBITED**
   - ‚ùå **WRONG:** Email template placeholders don't match Boomi subprocess msgParameters numbering - **PROHIBITED**
   - ‚ùå **WRONG:** Placeholder population parameter order doesn't match Boomi subprocess msgParameters key order - **PROHIBITED**
   - **üî¥ CRITICAL:** Email templates MUST be embedded HTML resources matching Boomi subprocess template exactly (see Section 17.4: Email Template Helpers)
   - **üî¥ CRITICAL:** Email template HTML MUST be extracted EXACTLY from Boomi subprocess JSON file (subprocess_*.json) - locate in msgTxt section of message shapes
   - **üî¥ CRITICAL:** Email template placeholders MUST match Boomi subprocess placeholders EXACTLY (verify placeholder numbering and order from msgParameters section in subprocess JSON)
   - **üî¥ CRITICAL:** Placeholder population parameter order MUST match Boomi subprocess msgParameters key order (verify parameter order in string.Format matches msgParameters)
   - **üî¥ CRITICAL:** Each process has different email templates - verify template name and structure from Phase 1 Section 9 or subprocess JSON
   - **üî¥ CRITICAL:** This rule has been missed - DO NOT SKIP THIS CHECKPOINT if Service contains email methods
   - **üö® CRITICAL:** You MUST read the entire file systematically and verify embedded templates are used. Do NOT skip this step.

**üõë IF ANY CHECKPOINT FAILS ‚Üí STOP ‚Üí Fix violation ‚Üí Re-verify ‚Üí Then proceed**

### 8.10 Services Rules - Common Mistakes

**‚ùå Not Separating Domain and Cross-Cutting Concerns**

- **WRONG:** Mixing domain operations with cross-cutting concerns in same Service
- **CORRECT:** Create separate Services - Domain Service for business operations, NotificationService for cross-cutting concerns
- **Why:** Single Responsibility Principle - Each Service should have one clear purpose. Cross-cutting concerns should be reusable across multiple domain Services.

**‚ùå Accepting Domain Objects in Service Methods**

- **WRONG:** `public async Task<HttpResponseSnapshot> Create<Entity>(<Entity>Domain domain)`
- **CORRECT:** `public async Task<HttpResponseSnapshot> Create<Entity>(<Operation>ReqDTO dto)`
- **Why:** DTOs are the contract between layers. Domain objects are for internal use within Functions only.

**‚ùå Adding Extra Parameters to Service Methods**

- **WRONG:** `public async Task<HttpResponseSnapshot> Create<Entity>(<Operation>ReqDTO dto, string headerValue, string configValue)`
- **CORRECT:** `public async Task<HttpResponseSnapshot> Create<Entity>(<Operation>ReqDTO dto)` - All data in DTO
- **Why:** All data MUST flow through DTOs. If data comes from headers/query parameters, populate the DTO property in the Function, then pass the DTO.

**‚ùå Using var Keyword**

- **WRONG:** `var response = await _systemAbstraction.CallSystemLayer();`
- **CORRECT:** `HttpResponseSnapshot response = await _systemAbstraction.CallSystemLayer();`
- **Why:** Explicit types improve code clarity, consistency, and make it easier to understand return types.

**‚ùå Using internal Keyword**

- **WRONG:** `internal async Task<HttpResponseSnapshot> CreateEntity(EntityReqDTO dto)`
- **CORRECT:** `public async Task<HttpResponseSnapshot> CreateEntity(EntityReqDTO dto)`
- **Why:** Service methods MUST be public. The `internal` keyword is prohibited.

**‚ùå Discarding Task Results**

- **WRONG:** `_ = await _systemAbstraction.CallSystemLayer();`
- **CORRECT:** `HttpResponseSnapshot response = await _systemAbstraction.CallSystemLayer();`
- **Why:** Always store return values to check status codes and handle errors properly.

**‚ùå Using try-catch Blocks**

- **WRONG:** `try { await _systemAbstraction.CallSystemLayer(); } catch (Exception ex) { ... }`
- **CORRECT:** Let exceptions propagate to middleware for proper error handling
- **Why:** ExceptionHandlerMiddleware is designed to catch ALL unhandled exceptions and normalize them to BaseResponseDTO.

**‚ùå Using LogInformation/LogError Instead of Extension Methods**

- **WRONG:** `_logger.LogInformation("Message");` or `_logger.LogError("Error");`
- **CORRECT:** `_logger.Info("Message");` or `_logger.Error("Error");` (requires `using Core.Extensions;`)
- **Why:** Extension methods from `Core.Extensions` provide consistent logging patterns across the codebase.

**‚ùå Not Injecting Abstractions via Interface**

- **WRONG:** `private readonly EntityMgmtSys _entityMgmt;` (concrete class)
- **CORRECT:** `private readonly IEntityMgmt _entityMgmt;` (interface)
- **Why:** Services MUST inject System/Process Abstractions via interface. This is mandatory.

---

## 9. Central Data Process Layer Unique Patterns

**üö® CRITICAL DATABASE EXCLUSIVITY:**
- Central Data Layer (Shared Services) is the **ONLY** Process Layer with database access
- Handles **internal application database** (LOVs, configs, app data) via Repository + EF Core
- Handles **3rd party system databases** via dedicated Azure Functions
- **ALL OTHER** Process Layers MUST call Central Data Layer Azure Functions for ANY database operations
- **NEVER** create repositories, DbContext, or database connections in standard Process Layers

### 9.1 Central Data Process Layer - What is Shared Services?

**Purpose:** Centralized database operations and shared business logic for ALL Process Layers

**Repository:** `Shared Services/SharedService/`

**Database Types Handled:**
1. **Internal Application Database:**
   - LOVs (List of Values), configuration values, application settings, security tokens
   - Direct access via Repository<T> pattern + EF Core + Flyway migrations
2. **3rd Party System Databases:**
   - Create Azure Function in Shared Services to connect to 3rd party DB
   - Process Layers call this Azure Function (never direct connection)

**Key Characteristics:**
- **Database Access:** ONLY project with direct DB access (internal OR external databases)
- **Repositories:** Generic Repository<T> with full CRUD + pagination
- **EF Core + Flyway:** Database schema management and migrations (CI/CD integrated)
- **AutoMapper:** Entity-to-DTO mapping
- **KeyVault:** Secret management for connection strings
- **Azure Functions:** HTTP endpoints that other Process Layers call
- **Common Services:** Authentication (OTP, Token), LOVs, Cache management

**When to Use:**
- ‚úÖ Need LOVs or configuration values from internal database
- ‚úÖ Need authentication/authorization services (OTP, Token generation/validation)
- ‚úÖ Need to read/write application data (Applications, Settings)
- ‚úÖ Need to connect to 3rd party system database
- ‚úÖ Need cached data with DB fallback
- ‚úÖ Need cache management operations

**How to Use:**
1. Check if Azure Function already exists in Shared Services (`Functions/` directory)
2. If exists ‚Üí Call it via Process Abstraction (Section 6)
3. If not exists ‚Üí Create new Azure Function in Shared Services, then call it

### 9.2 Central Data Process Layer - Calling Pattern

**Central data layer is called like any other Process Layer:**

```csharp
// In ProcessAbstractions/ or SystemAbstractions/
public class DataServicesProc {
    public async Task<HttpResponseMessage> GetData(DataReqDTO req) {
        dynamic request = new ExpandoObject();
        request.Criteria = req.Criteria;
        // ‚úÖ Build business headers if needed (technical headers added automatically by extension method)
        List<Tuple<string, string>> businessHeaders = new List<Tuple<string, string>>();
        if (req.Headers != null) {
            businessHeaders.AddRange(req.Headers.Select(kvp => Tuple.Create(kvp.Key, kvp.Value)));
        }
            
        // ‚úÖ Direct call - extension method automatically adds TestRunId/RequestId
        // ‚úÖ Use await for consistency and proper error handling
        return await _customHttpClient.SendProcessHTTPReqAsync(
            method: HttpMethod.Post, 
            url: _options.DataServicesUrl, 
            contentType: "application/json", 
            body: request, 
            reqHeaders: businessHeaders);
    }
}
```

**Key Rules:**

| Aspect | Pattern |
|--------|---------|
| Communication | `SendProcessHTTPReqAsync()` (Process-to-Process) |
| Headers | Technical headers + business headers (if function requires) |
| Location | ProcessAbstractions/ OR SystemAbstractions/ |
| Purpose | ALL database operations (internal + 3rd party), shared business logic |
| When to Create New Function | Need new DB operation not covered by existing Azure Functions |

### 9.3 Central Data Process Layer - Repository Pattern

**Location:** `Shared Services/SharedService/Repositories/Repository.cs`

```csharp
public class Repository<T> : IRepository<T> where T : class {
    private readonly AppDbContext _db;
    internal DbSet<T> dbSet;
    
    public Repository(AppDbContext db) { 
        _db = db; 
        dbSet = _db.Set<T>(); 
    }
    
    // Single operations
    public async Task<T?> GetAsync(Expression<Func<T, bool>> f, string? includeProps = null, bool tracked = false) {
        IQueryable<T> q = tracked ? dbSet : dbSet.AsNoTracking();
        if (f != null) q = q.Where(f);
        if (!string.IsNullOrEmpty(includeProps)) {
            foreach (string p in includeProps.Split(',', StringSplitOptions.RemoveEmptyEntries)) {
                q = q.Include(p.Trim());
            }
        }
        return await q.FirstOrDefaultAsync();
    }
    
    public async Task<IEnumerable<T>> GetAllAsync(Expression<Func<T, bool>>? f = null, string? includeProps = null, bool tracked = false) {
        IQueryable<T> q = tracked ? dbSet : dbSet.AsNoTracking();
        if (f != null) q = q.Where(f);
        if (!string.IsNullOrEmpty(includeProps)) {
            foreach (string p in includeProps.Split(',', StringSplitOptions.RemoveEmptyEntries)) {
                q = q.Include(p.Trim());
            }
        }
        return await q.ToListAsync();
    }
    
    public async Task<IEnumerable<T>> GetAllAsync(Expression<Func<T, bool>>? f = null, string? includeProps = null, bool tracked = false, int pageNumber = 1, int pageSize = 10) {
        IQueryable<T> q = tracked ? dbSet : dbSet.AsNoTracking();
        if (f != null) q = q.Where(f);
        if (!string.IsNullOrEmpty(includeProps)) {
            foreach (string p in includeProps.Split(',', StringSplitOptions.RemoveEmptyEntries)) {
                q = q.Include(p.Trim());
            }
        }
        q = q.Skip((pageNumber - 1) * pageSize).Take(pageSize);
        return await q.ToListAsync();
    }
    
    public async Task<bool> AnyAsync(Expression<Func<T, bool>> f) => await dbSet.AnyAsync(f);
    public async Task AddAsync(T entity) => await dbSet.AddAsync(entity);
    public async Task<int> AddAsync(T entity, string ReturnIDName) { 
        await dbSet.AddAsync(entity); 
        await _db.SaveChangesAsync(); 
        return _db.Entry(entity).Property(ReturnIDName).CurrentValue as int? ?? 0; 
    }
    public async Task AddRangeAsync(IEnumerable<T> entities) => await dbSet.AddRangeAsync(entities);
    public async Task UpdateAsync(T entity) { 
        dbSet.Attach(entity); 
        _db.Entry(entity).State = EntityState.Modified; 
        await Task.CompletedTask; 
    }
    public async Task UpdateRangeAsync(IEnumerable<T> entities) { 
        foreach (T e in entities) { 
            dbSet.Attach(e); 
            _db.Entry(e).State = EntityState.Modified; 
        } 
        await Task.CompletedTask; 
    }
    public async Task RemoveAsync(T entity) { 
        dbSet.Remove(entity); 
        await Task.CompletedTask; 
    }
    public async Task RemoveRangeAsync(IEnumerable<T> entities) => await dbSet.RemoveRange(entities);
}
```

**Key Features:**
- Generic CRUD operations for ALL entities
- Supports eager loading via `includeProperties` (comma-separated)
- Pagination support with `pageNumber` and `pageSize`
- Bulk operations: AddRange, UpdateRange, RemoveRange
- Tracked vs AsNoTracking queries for performance
- AddAsync with return ID for auto-increment scenarios

### 9.4 Central Data Process Layer - EF Core DbContext

**Location:** `Shared Services/SharedService/Models/AppDbContext.cs`

```csharp
public partial class AppDbContext : DbContext {
    public AppDbContext(DbContextOptions<AppDbContext> options) : base(options) { }
    
    public virtual DbSet<Application> Applications { get; set; }
    public virtual DbSet<ApplicationOtpSetting> ApplicationOtpSettings { get; set; }
    public virtual DbSet<ApplicationTokenSetting> ApplicationTokenSettings { get; set; }
    public virtual DbSet<Lov> Lovs { get; set; }
    public virtual DbSet<LovLevel1> LovLevel1 { get; set; }
    public virtual DbSet<LovLevel2> LovLevel2 { get; set; }
    
    protected override void OnModelCreating(ModelBuilder m) {
        m.Entity<Application>(e => { 
            e.HasKey(e => e.ApplicationId).HasName("PK__Application"); 
            e.ToTable("Application"); 
            e.Property(e => e.ApplicationId).HasColumnName("ApplicationID"); 
            e.Property(e => e.CreatedAt).HasDefaultValueSql("(getdate())").HasColumnType("datetime"); 
            e.Property(e => e.IsActive).HasDefaultValue(true); 
        });
        m.Entity<Lov>(e => { 
            e.HasKey(e => e.Id).HasName("PK__LOV"); 
            e.ToTable("LOV"); 
            e.Property(e => e.CreatedDate).HasDefaultValueSql("(getdate())").HasColumnType("datetime"); 
        });
        m.Entity<LovLevel1>(e => { 
            e.HasKey(e => e.Id).HasName("PK__LOV_LEVEL1"); 
            e.ToTable("LOV_LEVEL1"); 
            e.HasOne(d => d.Lov).WithMany(p => p.LovLevel1).HasForeignKey(d => d.Lovid).HasConstraintName("FK_LOV_LEVEL1_LOV"); 
        });
        OnModelCreatingPartial(m);
    }
    partial void OnModelCreatingPartial(ModelBuilder m);
}
```

**Key Entities:**
- Application, ApplicationOtpSetting, ApplicationTokenSetting (security config)
- Lov, LovLevel1, LovLevel2 (hierarchical list of values)
- All entities with proper constraints, defaults, and relationships

### 9.5 Central Data Process Layer - AutoMapper Profile

**Location:** `Shared Services/SharedService/AutoMapping/<Entity>Mapping.cs`

```csharp
public class <Entity>Mapping : Profile {
    public <Entity>Mapping() {
        // Simple mapping
        CreateMap<<Entity>Model, <Entity>DTO>()
            .ForMember(d => d.Id, o => o.MapFrom(s => s.EntityId))
            .ForMember(d => d.Name, o => o.MapFrom(s => s.EntityName ?? ""));
        
        // Nested/hierarchical mapping (when entity has child collections)
        CreateMap<ParentModel, ParentDTO>()
            .ForMember(d => d.Id, o => o.MapFrom(s => s.Id))
            .ForMember(d => d.ChildItems, o => o.MapFrom(s => s.ChildEntities));
    }
}
```

**Key Pattern:**
- One Profile class per entity or entity group
- Maps EF Core entities ‚Üí DTOs (one direction only, never reverse for database operations)
- Handles null coalescing with `?? ""` for nullable properties
- Supports nested/hierarchical mappings for related entities
- Use `.ForMember()` when property names differ between source and destination

### 9.6 Central Data Process Layer - KeyVault Reader

**Location:** `Shared Services/SharedService/Helper/KeyVaultReader.cs`

```csharp
public class KeyVaultReader {
    private readonly SecretClient _secretClient;
    private readonly KeyVaultConfigs _kvConfigs;
    private readonly ILogger<KeyVaultReader> _logger;
    
    public KeyVaultReader(IOptions<KeyVaultConfigs> options, ILogger<KeyVaultReader> logger) {
        _logger = logger;
        _kvConfigs = options.Value;
        _kvConfigs.validate();
        _secretClient = new SecretClient(new Uri(_kvConfigs.Url), new DefaultAzureCredential());
    }
    
    public async Task<KeyVaultResponse> GetSecretAsync(string secretName) {
        _logger.Info($"Fetching secret: {secretName} from Key Vault started.");
        KeyVaultResponse kvResponse = new KeyVaultResponse { IsSuccess = false };
        string cleanedSecretName = secretName.RemoveAllWhitespace().ToLowerInvariant();
        KeyVaultSecret secret = await _secretClient.GetSecretAsync(cleanedSecretName);
        if (secret != null && secret.Value != null) {
            kvResponse = new KeyVaultResponse { IsSuccess = true, Secret = secret.Value };
            _logger.Info($"Fetching secret: {secretName} from Key Vault completed.");
            return kvResponse;
        }
        _logger.Info($"Fetching secret: {secretName} from Key Vault couldn't succeed.");
        return kvResponse;
    }
}
```

**Usage:**
- Fetch database connection string: `await kvReader.GetSecretAsync(KeyVaultConfigs.DB_CONNECTION_STRING)`
- Secret names automatically cleaned (whitespace removed, lowercase)
- Returns `KeyVaultResponse` with `IsSuccess` flag and `Secret` value

### 9.7 Central Data Process Layer - Database Connection String Provider

**Location:** `Shared Services/SharedService/Helper/DatabaseConnectionStringProvider.cs`

```csharp
public class DatabaseConnectionStringProvider {
    public string ConnectionString { get; set; } = string.Empty;
}
```

**Usage in Program.cs:**
```csharp
DatabaseConnectionStringProvider dbConnProvider = new DatabaseConnectionStringProvider();
KeyVaultResponse kvResponse = await builder.Services.BuildServiceProvider().GetRequiredService<KeyVaultReader>().GetSecretAsync(KeyVaultConfigs.DB_CONNECTION_STRING);
if (kvResponse.IsSuccess) {
    dbConnProvider.ConnectionString = kvResponse.Secret;
}
builder.Services.AddDbContext<AppDbContext>(o => o.UseSqlServer(dbConnProvider.ConnectionString));
```

### 9.8 Central Data Process Layer - Cache + DB Hybrid Operations

**Pattern:** Central Data Layer combines cache operations with database access.

```csharp
public async Task<BaseResponseDTO> ProcessData(DataReqDTO req) {
    Config? cfg = await _cfgRepo.GetAsync(x => x.Id == Convert.ToInt32(req.Headers["id"]));
    if (cfg == null) throw new HttpBaseServerException(...);
    
    CacheKey key = CacheKey.CreateCacheKey(req.GetCacheKey(), _namespace: "data", _cacheKeySettings: new CacheKeySettings { TimeToLive = TimeSpan.FromMinutes(cfg.TTL) });
    DataEntity? cached = await key.GetAsync<DataEntity>();
    if (cached != null) { 
        if (cached.IsExpired()) throw new BusinessCaseFailureException(...); 
        if (cached.ExpiresAt > DateTimeOffset.UtcNow) throw new BusinessCaseFailureException(...); 
    }
    
    DataEntity entity = GenerateEntity(out string code, req, cfg);
    await key.SetAsync(entity);
    return new BaseResponseDTO("Success", "", new DataResDTO { Id = entity.Id });
}
```

### 9.9 Central Data Process Layer - Key Differences from Standard Process Layer

| Component | Standard Process Layer | Shared Services (Central Data Layer) |
|-----------|------------------------|-------------------------------------|
| **Repositories/** | ‚ùå NEVER exists | ‚úÖ Generic Repository<T> + specific repositories |
| **Models/** | ‚ùå NEVER exists | ‚úÖ EF Core entities (Application, Lov, Settings) |
| **AutoMapping/** | ‚ùå NEVER exists | ‚úÖ AutoMapper profiles (Entity‚ÜíDTO) |
| **DbContext** | ‚ùå NEVER used | ‚úÖ AppDbContext with full entity configurations |
| **Internal DB Access** | ‚ùå MUST call Shared Services Azure Functions | ‚úÖ Direct via Repository<T> + EF Core |
| **3rd Party DB Access** | ‚ùå MUST call Shared Services Azure Functions | ‚úÖ Create Azure Function to connect |
| **Domains** | ‚úÖ IDomain<T> with business logic | ‚úÖ Simple POCOs (e.g., OTP with IsLockout()) |
| **KeyVault** | ‚ùå Not used | ‚úÖ KeyVaultReader for secrets (connection strings) |
| **Flyway** | ‚ùå Not used | ‚úÖ CI/CD pipeline migrations for internal DB |
| **Purpose** | Business logic orchestration | ALL database operations (internal + external) + common services (OTP, Token, LOV, Cache) |
| **Location** | Multiple repos (AGFS, Facilities, HR) | Single repo: `Shared Services/SharedService/` |

**üî¥ CRITICAL RULES:**

1. ‚úÖ **Standard Process Layers MUST call Shared Services Azure Functions** for ANY database operations
2. ‚úÖ **Shared Services is the ONLY Process Layer with database access**
3. ‚úÖ **NEVER create repositories, DbContext, or database connections in standard Process Layers**
4. ‚úÖ **Shared Services uses Repository<T> pattern + EF Core for internal database access**
5. ‚úÖ **Shared Services creates Azure Functions for 3rd party database access**
6. ‚úÖ **Shared Services uses KeyVault for connection string management**
7. ‚úÖ **Shared Services uses AutoMapper for Entity‚ÜíDTO mapping**

### 9.10 Central Data Process Layer - Common Mistakes

**‚ùå Creating Database Access in Standard Process Layers**

- **WRONG:** Creating repositories, DbContext, or database connections in standard Process Layers
- **CORRECT:** Standard Process Layers MUST call Shared Services Azure Functions for ANY database operations
- **Why:** Central Data Layer is the ONLY Process Layer with database access. This ensures centralized data management and consistency.

**‚ùå Direct Database Connections in Standard Process Layers**

- **WRONG:** Creating direct database connections or using Entity Framework in standard Process Layers
- **CORRECT:** Call Shared Services Azure Functions via Process Abstraction
- **Why:** Database access must be centralized in Shared Services for security, consistency, and maintainability.

**‚ùå Missing KeyVault Configuration**

- **WRONG:** Hardcoding connection strings or not using KeyVault for secrets
- **CORRECT:** Use KeyVaultReader to fetch connection strings from Azure Key Vault
- **Why:** Connection strings are sensitive secrets and must be stored securely in Key Vault.

**‚ùå Not Using Repository Pattern**

- **WRONG:** Direct DbContext usage without Repository pattern
- **CORRECT:** Use Generic Repository<T> pattern for all database operations
- **Why:** Repository pattern provides abstraction, testability, and consistent CRUD operations.

**‚ùå Missing AutoMapper Profiles**

- **WRONG:** Manual mapping between entities and DTOs
- **CORRECT:** Use AutoMapper profiles for Entity‚ÜíDTO mapping
- **Why:** AutoMapper provides consistent, maintainable mapping with null handling and nested object support.

---

## 10. Calling Central Data Process Layer

**üö® CRITICAL DATABASE ACCESS RULE:**
- **Shared Services repository** is the **ONLY** Process Layer with database access
- **ALL OTHER** Process Layers **MUST** call Shared Services Azure Functions for ANY database operations
- **NEVER** create repositories, DbContext, or database connections in standard Process Layers

### 10.1 Calling Central Data Process Layer - What is Shared Services?

**Purpose:** Centralized database operations and shared business logic for ALL Process Layers

**Repository:** `Shared Services/SharedService/`

**Database Types Handled:**
1. **Internal Application Database:**
   - LOVs (List of Values), configuration values, application settings, security tokens
   - Direct access via Repository<T> pattern + EF Core + Flyway migrations
2. **3rd Party System Databases:**
   - Create Azure Function in Shared Services to connect to 3rd party DB
   - Process Layers call this Azure Function (never direct connection)

**Key Characteristics:**
- **Database Access:** ONLY project with direct DB access (internal OR external databases)
- **Repositories:** Generic Repository<T> with full CRUD + pagination
- **EF Core + Flyway:** Database schema management and migrations (CI/CD integrated)
- **AutoMapper:** Entity-to-DTO mapping
- **KeyVault:** Secret management for connection strings
- **Azure Functions:** HTTP endpoints that other Process Layers call
- **Common Services:** Authentication (OTP, Token), LOVs, Cache management

**When to Use:**
- ‚úÖ Need LOVs or configuration values from internal database
- ‚úÖ Need authentication/authorization services (OTP, Token generation/validation)
- ‚úÖ Need to read/write application data (Applications, Settings)
- ‚úÖ Need to connect to 3rd party system database
- ‚úÖ Need cached data with DB fallback
- ‚úÖ Need cache management operations

**How to Use:**
1. Check if Azure Function already exists in Shared Services (`Functions/` directory)
2. If exists ‚Üí Call it via Process Abstraction (Section 6)
3. If not exists ‚Üí Create new Azure Function in Shared Services, then call it

### 10.2 Calling Central Data Process Layer - Calling Pattern

**Central data layer is called like any other Process Layer:**

```csharp
// In ProcessAbstractions/ or SystemAbstractions/
public class DataServicesProc : IDataServicesProc {
    private readonly AppConfigs _options;
    private readonly CustomHTTPClient _customHttpClient;
    private readonly ILogger<DataServicesProc> _logger;
    
    public DataServicesProc(IOptions<AppConfigs> o, CustomHTTPClient c, ILogger<DataServicesProc> l) { 
        _options = o.Value; 
        _customHttpClient = c; 
        _logger = l; 
    }
    
    public async Task<HttpResponseMessage> GetData(DataReqDTO req) {
        dynamic request = new ExpandoObject();
        request.Criteria = req.Criteria;
        
        // ‚úÖ Build business headers if needed (technical headers added automatically by extension method)
        List<Tuple<string, string>> businessHeaders = new List<Tuple<string, string>>();
        if (req.Headers != null) {
            businessHeaders.AddRange(req.Headers.Select(kvp => Tuple.Create(kvp.Key, kvp.Value)));
        }
            
        // ‚úÖ Direct call - extension method automatically adds TestRunId/RequestId
        // ‚úÖ Use await for consistency and proper error handling
        return await _customHttpClient.SendProcessHTTPReqAsync(
            method: HttpMethod.Post, 
            url: _options.DataServicesUrl, 
            contentType: "application/json", 
            body: request, 
            reqHeaders: businessHeaders);
    }
}
```

**Key Points:**
- ‚úÖ Use `SendProcessHTTPReqAsync()` extension method (same as Process Abstractions)
- ‚úÖ Technical headers (TestRunId, RequestId) are automatically added
- ‚úÖ Business headers are optional - only add if required by Shared Services Function
- ‚úÖ Build dynamic request using `ExpandoObject`
- ‚úÖ Call Shared Services Function URL from AppConfigs
- ‚úÖ MUST implement interface and be registered with interface in Program.cs

### 10.3 Calling Central Data Process Layer - Key Rules

| Aspect | Pattern |
|--------|---------|
| **Communication** | `SendProcessHTTPReqAsync()` (Process-to-Process) |
| **Headers** | Technical headers (auto-added) + business headers (if function requires) |
| **Location** | ProcessAbstractions/ OR SystemAbstractions/ |
| **Purpose** | ALL database operations (internal + 3rd party), shared business logic |
| **When to Create New Function** | Need new DB operation not covered by existing Azure Functions |
| **Interface** | ‚úÖ **MANDATORY** - Must implement interface (e.g., `IDataServicesProc`) |
| **Registration** | ‚úÖ **MANDATORY** - Must be registered with interface in Program.cs |
| **URL Config** | From AppConfigs (Shared Services Function URL) |
| **Return Type** | `HttpResponseMessage` (standard response) |

**üî¥ CRITICAL RULES:**

1. ‚úÖ **Standard Process Layers MUST call Shared Services Azure Functions** for ANY database operations
2. ‚úÖ **NEVER create repositories, DbContext, or database connections** in standard Process Layers
3. ‚úÖ **Use Process Abstraction pattern** to call Shared Services (same as calling other Process Layers)
4. ‚úÖ **MUST implement interface** and be registered with interface in Program.cs
5. ‚úÖ **Use `SendProcessHTTPReqAsync()` extension method** for HTTP calls
6. ‚úÖ **Technical headers are automatically added** - no need to add TestRunId/RequestId manually
7. ‚úÖ **Business headers are optional** - only add if required by Shared Services Function

### 10.4 Calling Central Data Process Layer - When to Call Shared Services

**‚úÖ Call Shared Services When You Need:**

1. **LOVs (List of Values):**
   - Reference data from internal database
   - Hierarchical lookup values (Lov, LovLevel1, LovLevel2)
   - Configuration values

2. **Authentication Services:**
   - OTP generation/validation
   - Token generation/validation
   - Application settings for security

3. **Application Data:**
   - Read/write application settings
   - Read/write application configurations
   - Application metadata

4. **3rd Party Database Access:**
   - Connect to external system databases
   - Query external databases
   - Write to external databases

5. **Cache Management:**
   - Cache operations with DB fallback
   - Cache invalidation
   - Cache configuration

**‚ùå Do NOT Call Shared Services For:**
- Business logic orchestration (use Services)
- System Layer calls (use System Abstractions)
- Other Process Layer calls (use Process Abstractions)
- Direct database access (NEVER in standard Process Layers)

### 10.5 Calling Central Data Process Layer - Pre-Creation Validation

**üõë PRE-CREATION VALIDATION (MANDATORY - STOP IF NOT COMPLETE)**

**üö® BEFORE creating Process Abstraction to call Shared Services, you MUST verify:**

1. ‚úÖ **STOP AND VERIFY:** Do I actually need database access or Shared Services functionality?
2. ‚úÖ **STOP AND VERIFY:** Have I checked if Shared Services Azure Function already exists?
3. ‚úÖ **STOP AND VERIFY:** Do I have the Shared Services Function URL in AppConfigs?
4. ‚úÖ **STOP AND VERIFY:** Have I read Section 6 (Process Abstractions Rules)?
5. ‚úÖ **STOP AND VERIFY:** Do I understand that Shared Services is called like any other Process Layer?
6. ‚úÖ **STOP AND VERIFY:** Do I know to use `SendProcessHTTPReqAsync()` extension method?
7. ‚úÖ **STOP AND VERIFY:** Do I understand the Shared Services Function's request/response structure?

**üõë IF ANY MISSING ‚Üí STOP ‚Üí Complete verification ‚Üí Then create Process Abstraction**

### 10.6 Calling Central Data Process Layer - Post-Creation Validation

**üõë POST-CREATION VALIDATION (MANDATORY - VERIFY BEFORE PROCEEDING)**

**üö® AFTER creating Process Abstraction to call Shared Services, you MUST verify:**

1. ‚úÖ **STOP AND VERIFY:** Process Abstraction calls Shared Services Function URL from AppConfigs
2. ‚úÖ **STOP AND VERIFY:** Process Abstraction uses `SendProcessHTTPReqAsync()` extension method (NOT direct HTTP calls)
3. ‚úÖ **STOP AND VERIFY:** Process Abstraction uses `await` (NOT `.Result`, `.Wait()`, or `.GetAwaiter().GetResult()`)
4. ‚úÖ **STOP AND VERIFY:** Process Abstraction implements interface and is registered with interface in Program.cs
5. ‚úÖ **STOP AND VERIFY:** Business headers are only added if required by Shared Services Function
6. ‚úÖ **STOP AND VERIFY:** Technical headers (TestRunId/RequestId) are NOT manually added (extension method handles this)

**üõë IF ANY VIOLATION ‚Üí STOP ‚Üí Fix Process Abstraction ‚Üí Then proceed**

### 10.7 Calling Central Data Process Layer - Common Mistakes

**‚ùå Creating Database Access in Standard Process Layers**

- **WRONG:** Creating repositories, DbContext, or database connections in standard Process Layers
- **CORRECT:** Standard Process Layers MUST call Shared Services Azure Functions for ANY database operations
- **Why:** Central Data Layer is the ONLY Process Layer with database access. This ensures centralized data management and consistency.

**‚ùå Not Using Process Abstraction Pattern**

- **WRONG:** Creating direct HTTP calls to Shared Services without Process Abstraction
- **CORRECT:** Use Process Abstraction pattern (same as calling other Process Layers)
- **Why:** Process Abstraction pattern provides consistency, proper header handling, and maintainability.

**‚ùå Not Implementing Interface**

- **WRONG:** Creating Process Abstraction without interface
- **CORRECT:** Process Abstraction MUST implement interface and be registered with interface
- **Why:** Services inject Process Abstractions via interface - interface is mandatory.

**‚ùå Manually Adding Technical Headers**

- **WRONG:** Manually adding `RequestHeaders.TestRunId.Simplify()` and `RequestHeaders.RequestId.Simplify()` to headers
- **CORRECT:** `SendProcessHTTPReqAsync()` extension method automatically adds these headers
- **Why:** Extension method handles technical headers automatically - no need to add them manually.

**‚ùå Not Checking if Function Exists**

- **WRONG:** Creating new Shared Services Function without checking if it already exists
- **CORRECT:** First check if Azure Function already exists in Shared Services, then call it
- **Why:** Avoids duplicate functionality and maintains consistency across Process Layers.

---

## 11. Middleware Rules

**üö® CRITICAL:** Process Layer uses ONLY Framework middlewares. NO custom middlewares are allowed.

### 11.1 Middleware Rules - Middleware Order (Non-Negotiable)

**üî¥ CRITICAL:** Middleware order is STRICT and NON-NEGOTIABLE. The order MUST be exactly as specified.

```csharp
builder.ConfigureFunctionsWebApplication(app => {
    app.UseMiddleware<ExecutionTimingMiddleware>();    // 1. FIRST - timing
    app.UseMiddleware<ExceptionHandlerMiddleware>();   // 2. SECOND - exception handling
    // ‚ùå NO CustomAuthenticationMiddleware - System Layer concept
});
```

**Why This Order:**

1. **ExecutionTimingMiddleware** - Wraps all requests, measures total execution time
   - Must be FIRST to capture timing for entire request pipeline
   - Tracks performance metrics for all requests

2. **ExceptionHandlerMiddleware** - Catches all exceptions, normalizes to BaseResponseDTO
   - Must be SECOND to catch exceptions from all downstream components
   - Converts all exceptions to standardized BaseResponseDTO format
   - Ensures consistent error response structure

**‚ùå PROHIBITED:**
- ‚ùå **NO CustomAuthenticationMiddleware** - This is a System Layer concept, NOT Process Layer
- ‚ùå **NO custom middlewares** - Use Framework middlewares only
- ‚ùå **NO middleware order changes** - Order is non-negotiable

### 11.2 Middleware Rules - Key Rules

| Middleware | Source | Purpose | Order |
|------------|--------|---------|-------|
| **ExecutionTimingMiddleware** | Framework | Performance tracking | 1 (FIRST) |
| **ExceptionHandlerMiddleware** | Framework | Error normalization | 2 (SECOND) |
| **CustomAuthenticationMiddleware** | ‚ùå NOT IN PROCESS LAYER | System Layer only | N/A |

**üî¥ CRITICAL RULES:**

1. ‚úÖ **ONLY Framework middlewares** - Use ExecutionTimingMiddleware and ExceptionHandlerMiddleware from Framework
2. ‚úÖ **Strict order** - ExecutionTimingMiddleware FIRST, ExceptionHandlerMiddleware SECOND
3. ‚úÖ **NO custom middlewares** - Do NOT create custom middleware classes
4. ‚úÖ **NO CustomAuthenticationMiddleware** - This is System Layer only, NOT Process Layer
5. ‚úÖ **Let exceptions propagate** - Functions/Services should NOT use try-catch blocks - let ExceptionHandlerMiddleware handle all exceptions

### 11.3 Middleware Rules - ExecutionTimingMiddleware

**Purpose:** Tracks execution time for all requests

**Location:** Framework (`Core/Middlewares/ExecutionTimingMiddleware.cs`)

**Key Features:**
- Wraps entire request pipeline
- Measures total execution time
- Logs timing information
- Must be registered FIRST in middleware pipeline

**Usage:**
```csharp
builder.ConfigureFunctionsWebApplication(app => {
    app.UseMiddleware<ExecutionTimingMiddleware>();    // 1. FIRST
    // ... other middlewares
});
```

### 11.4 Middleware Rules - ExceptionHandlerMiddleware

**Purpose:** Catches all unhandled exceptions and normalizes them to BaseResponseDTO

**Location:** Framework (`Core/Middlewares/ExceptionHandlerMiddleware.cs`)

**Key Features:**
- Catches ALL unhandled exceptions from Functions, Services, and Abstractions
- Normalizes exceptions to BaseResponseDTO format
- Ensures consistent error response structure
- Must be registered SECOND in middleware pipeline

**Why Functions/Services Should NOT Use try-catch:**
- ExceptionHandlerMiddleware is designed to catch ALL unhandled exceptions
- Using try-catch blocks prevents proper exception handling and error response formatting
- ExceptionHandlerMiddleware automatically normalizes all exceptions to BaseResponseDTO
- Let exceptions propagate to middleware for proper error handling

**Usage:**
```csharp
builder.ConfigureFunctionsWebApplication(app => {
    app.UseMiddleware<ExecutionTimingMiddleware>();    // 1. FIRST
    app.UseMiddleware<ExceptionHandlerMiddleware>();   // 2. SECOND
});
```

**Exception Handling Pattern:**
```csharp
// ‚úÖ CORRECT - Let exceptions propagate to middleware
public async Task<BaseResponseDTO> Run([HttpTrigger(...)] HttpRequest req) {
    // No try-catch - let ExceptionHandlerMiddleware handle exceptions
    <Operation>ReqDTO? dto = await req.ReadBodyAsync<<Operation>ReqDTO>();
    if (dto == null) throw new NoRequestBodyException(...);
    // ... rest of function
    // If exception occurs, ExceptionHandlerMiddleware will catch and normalize it
}

// ‚ùå WRONG - try-catch prevents proper exception handling
public async Task<BaseResponseDTO> Run([HttpTrigger(...)] HttpRequest req) {
    try {
        // ... function code
    } catch (Exception ex) {
        // ‚ùå WRONG - ExceptionHandlerMiddleware should handle this
        return new BaseResponseDTO("Error", ex.Message, null);
    }
}
```

### 11.5 Middleware Rules - Pre-Creation Validation

**üõë PRE-CREATION VALIDATION (MANDATORY - STOP IF NOT COMPLETE)**

**üö® BEFORE registering middleware in Program.cs, you MUST verify:**

1. ‚úÖ **STOP AND VERIFY:** Have I read this section completely?
2. ‚úÖ **STOP AND VERIFY:** Do I understand that ONLY Framework middlewares are allowed?
3. ‚úÖ **STOP AND VERIFY:** Do I understand the strict middleware order requirement?
4. ‚úÖ **STOP AND VERIFY:** Do I know that CustomAuthenticationMiddleware is NOT allowed in Process Layer?
5. ‚úÖ **STOP AND VERIFY:** Do I understand that Functions/Services should NOT use try-catch blocks?

**üõë IF ANY MISSING ‚Üí STOP ‚Üí Complete verification ‚Üí Then register middleware**

### 11.6 Middleware Rules - Post-Creation Validation

**üõë POST-CREATION VALIDATION (MANDATORY - VERIFY BEFORE PROCEEDING)**

**üö® AFTER registering middleware in Program.cs, you MUST verify:**

1. ‚úÖ **STOP AND VERIFY:** ExecutionTimingMiddleware is registered FIRST
2. ‚úÖ **STOP AND VERIFY:** ExceptionHandlerMiddleware is registered SECOND
3. ‚úÖ **STOP AND VERIFY:** NO CustomAuthenticationMiddleware is registered
4. ‚úÖ **STOP AND VERIFY:** NO custom middlewares are registered
5. ‚úÖ **STOP AND VERIFY:** Middleware order is exactly: ExecutionTiming ‚Üí ExceptionHandler

**üõë IF ANY VIOLATION ‚Üí STOP ‚Üí Fix Program.cs ‚Üí Then proceed**

### 11.7 Middleware Rules - Common Mistakes

**‚ùå Using CustomAuthenticationMiddleware**

- **WRONG:** Registering CustomAuthenticationMiddleware in Process Layer
- **CORRECT:** CustomAuthenticationMiddleware is System Layer only - NOT in Process Layer
- **Why:** Authentication is handled at System Layer, not Process Layer. Process Layer Functions use `AuthorizationLevel.Anonymous`.

**‚ùå Creating Custom Middleware**

- **WRONG:** Creating custom middleware classes in Process Layer
- **CORRECT:** Use ONLY Framework middlewares (ExecutionTimingMiddleware, ExceptionHandlerMiddleware)
- **Why:** Framework middlewares provide all necessary functionality. Custom middlewares add unnecessary complexity.

**‚ùå Wrong Middleware Order**

- **WRONG:** Registering ExceptionHandlerMiddleware before ExecutionTimingMiddleware
- **CORRECT:** ExecutionTimingMiddleware FIRST, ExceptionHandlerMiddleware SECOND
- **Why:** ExecutionTimingMiddleware must wrap the entire pipeline to measure total time. ExceptionHandlerMiddleware must be second to catch all exceptions.

**‚ùå Using try-catch Blocks in Functions/Services**

- **WRONG:** Using try-catch blocks in Functions or Services to handle exceptions
- **CORRECT:** Let exceptions propagate to ExceptionHandlerMiddleware
- **Why:** ExceptionHandlerMiddleware is designed to catch ALL unhandled exceptions and normalize them to BaseResponseDTO. Using try-catch prevents proper exception handling.

**‚ùå Not Registering Middleware**

- **WRONG:** Not registering ExecutionTimingMiddleware or ExceptionHandlerMiddleware
- **CORRECT:** Register both middlewares in strict order
- **Why:** ExecutionTimingMiddleware provides performance tracking. ExceptionHandlerMiddleware ensures consistent error responses.

---

## 12. Response DTO Helper Rules

**üö® CRITICAL:** ResponseDTOHelper provides standardized JSON‚ÜíDTO mapping. ResponseDTOHelper is MANDATORY for ALL Process Layers.

### 12.1 Response DTO Helper Rules - Pre-Creation Validation

**üõë PRE-CREATION VALIDATION (MANDATORY - STOP IF NOT COMPLETE)**

**üö® BEFORE creating ResponseDTOHelper methods, you MUST verify:**

1. ‚úÖ **STOP AND VERIFY:** Have I reviewed the System Layer Function's Handler to understand what `BaseResponseDTO` structure it returns?
2. ‚úÖ **STOP AND VERIFY:** Have I reviewed the System Layer Function's response DTOs to understand the `data` property structure?
3. ‚úÖ **STOP AND VERIFY:** Do I understand how the System Layer maps downstream API responses to its response DTOs?
4. ‚úÖ **STOP AND VERIFY:** Have I read this section completely?
5. ‚úÖ **STOP AND VERIFY:** Do I understand that ALL response mapping logic MUST be in `Helper/ResponseDTOHelper.cs`?

**üõë IF ANY MISSING ‚Üí STOP ‚Üí Complete verification ‚Üí Then create ResponseDTOHelper methods**

**üî¥ CRITICAL:** Before implementing Process Layer response mapping, you MUST:
- Review the System Layer Function's Handler to understand what `BaseResponseDTO` structure it returns
- Review the System Layer Function's response DTOs to understand the `data` property structure
- Understand how the System Layer maps downstream API responses to its response DTOs
- This knowledge is REQUIRED to correctly implement `ResponseDTOHelper.Populate*()` methods in Process Layer

### 12.2 Response DTO Helper Rules - Structure & Location

**Location:** `Helper/ResponseDTOHelper.cs`

**Structure:**
```csharp
public static class ResponseDTOHelper {
    // All methods are public static
    public static <Entity>ResDTO PopulateEntity(string json, <Entity>ResDTO dto) { /* ... */ }
    public static ReferenceResDTO PopulateReference(string json) { /* ... */ }
    // ... other Populate methods
}
```

**Key Requirements:**
- ‚úÖ **MANDATORY:** ResponseDTOHelper MUST exist in ALL Process Layers
- ‚úÖ **Location:** `Helper/ResponseDTOHelper.cs` (exact location)
- ‚úÖ **Class:** `public static class ResponseDTOHelper`
- ‚úÖ **Methods:** All methods MUST be `public static`
- ‚úÖ **Purpose:** Standardized JSON‚ÜíDTO mapping for all System Layer and Process Layer responses

### 12.3 Response DTO Helper Rules - Direct Deserialization Pattern

**Pattern:** Use when JSON structure matches DTO structure exactly.

```csharp
public static <Entity>ResDTO PopulateEntity(string json, <Entity>ResDTO dto) {
    JsonSerializerOptions opts = new JsonSerializerOptions { PropertyNameCaseInsensitive = true };
    <Entity>ResDTO? apiRes = JsonSerializer.Deserialize<<Entity>ResDTO>(json, opts);
    if (apiRes != null) { 
        dto.Id = apiRes.Id; 
        dto.Name = apiRes.Name; 
        dto.Items = apiRes.Items; 
    }
    return dto;
}
```

**When to Use:**
- JSON structure matches DTO structure exactly
- Simple, flat DTOs with direct property mapping
- No complex transformations needed

### 12.4 Response DTO Helper Rules - Dictionary Extraction Pattern

**üî¥ MANDATORY PATTERN - ALWAYS USE THIS APPROACH**

**Pattern:** Use Dictionary<string, object> deserialization with Framework extension methods. This is the ONLY allowed pattern for ResponseDTOHelper methods.

```csharp
public static void Populate<Entity>Res(string json, <Entity>ResDTO dto) {
    Dictionary<string, object> docDict = JsonSerializer.Deserialize<Dictionary<string, object>>(json)!;
    
    if (docDict != null) {
        // Use extension methods from Core.Extensions
        dto.<Property1> = docDict.ToIntValue("<SystemLayerProperty1>");
        dto.<Property2> = docDict.ToStringValue("<SystemLayerProperty2>");
        dto.<Property3> = docDict.ToDecimalValue("<SystemLayerProperty3>");
        dto.<Property4> = docDict.ToDateTimeValue("<SystemLayerProperty4>");
        dto.<Property5> = docDict.ToBoolValue("<SystemLayerProperty5>");
        
        // For nested arrays
        if (docDict.TryGetValue("<SystemLayerArrayProperty>", out object? listObj)) {
            List<Dictionary<string, object>>? list =
                JsonSerializer.Deserialize<List<Dictionary<string, object>>>(listObj.ToString() ?? string.Empty);
            
            if (list?.Any() == true) {
                dto.<ArrayProperty> = new List<<ItemDTO>>();
                foreach (Dictionary<string, object> itemDict in list) {
                    <ItemDTO> item = new <ItemDTO> {
                        <ItemProperty1> = itemDict.ToStringValue("<SystemLayerItemProperty1>"),
                        <ItemProperty2> = itemDict.ToStringValue("<SystemLayerItemProperty2>")
                    };
                    dto.<ArrayProperty>.Add(item);
                }
            }
        }
    }
}
```

**üî¥ CRITICAL RULES - NEVER VIOLATE:**

1. ‚úÖ **MANDATORY:** ALWAYS use `Dictionary<string, object>` deserialization pattern
2. ‚úÖ **MANDATORY:** ALWAYS use Framework extension methods (`ToStringValue()`, `ToIntValue()`, `ToDateTimeValue()`, `ToBoolValue()`, `ToDecimalValue()`, `ToLongValue()`)
3. ‚úÖ **MANDATORY:** Use property names from System Layer DTO (PascalCase: `"<SystemLayerProperty>"`, `"<PropertyName>"`, etc.) - NOT from Process Layer DTO
4. ‚ùå **PROHIBITED:** NEVER create private classes inside ResponseDTOHelper for deserialization
5. ‚ùå **PROHIBITED:** NEVER use `JsonSerializer.Deserialize<T>()` with custom classes in ResponseDTOHelper
6. ‚ùå **PROHIBITED:** NEVER create temporary mapping classes (e.g., `private class <SystemLayerResDTO>`)
7. ‚ùå **PROHIBITED:** NEVER use `JsonSerializerOptions` with `PropertyNameCaseInsensitive` for deserializing to custom classes

**Why This Pattern:**
- **Consistency:** All ResponseDTOHelper methods follow the same pattern
- **Maintainability:** No need to create and maintain private classes for each function
- **Flexibility:** Dictionary approach handles any JSON structure without creating new classes
- **Framework Integration:** Uses Framework extension methods that are already available
- **Type Safety:** Extension methods handle type conversions safely

**When to Use:**
- ‚úÖ **ALWAYS** - This is the ONLY allowed pattern for ResponseDTOHelper methods
- Use for ALL response mapping scenarios (simple, complex, nested)
- Use for ALL System Layer response deserialization

**Key Points:**
- Use `DictionaryExtensions` from Framework (`Core.Extensions`)
- Methods: `ToIntValue()`, `ToStringValue()`, `ToDecimalValue()`, `ToDateTimeValue()`, `ToBoolValue()`, `ToLongValue()`
- Use System Layer DTO property names (PascalCase) as dictionary keys (e.g., `"<SystemLayerProperty>"`, `"<PropertyName>"`)
- For boolean values: Use `JsonElement.GetBoolean()` directly (e.g., `JsonElement <property>Element = (JsonElement)<property>Obj; <property> = <property>Element.GetBoolean();`)
- For nested arrays: Deserialize to `List<Dictionary<string, object>>` and iterate

### 12.5 Response DTO Helper Rules - Complex Nested Pattern

**Pattern:** Use when JSON contains nested objects or arrays.

```csharp
public static void PopulateEntity(string json, <Entity>ResDTO dto) {
    Dictionary<string, object>? dict = JsonSerializer.Deserialize<Dictionary<string, object>>(json);
    if (dict == null) return;
    
    if (dict.TryGetValue(nameof(dto.Items), out object? obj)) {
        List<Dictionary<string, object>>? list = JsonSerializer.Deserialize<List<Dictionary<string, object>>>(obj.ToString() ?? "");
        if (list?.Any() == true) {
            dto.Items = new List<ItemDTO>();
            foreach (Dictionary<string, object> item in list) { 
                dto.Items.Add(new ItemDTO { 
                    Name = item.ToStringValue(nameof(ItemDTO.Name)), 
                    Value = item.ToIntValue(nameof(ItemDTO.Value)) 
                }); 
            }
        }
    }
}
```

**When to Use:**
- JSON contains nested objects or arrays
- Complex response structure with multiple levels
- Need to map nested collections to DTO collections

### 12.6 Response DTO Helper Rules - Response Enrichment Pattern

**Pattern:** Use when combining data from multiple sources (e.g., System Layer response + Reference data).

```csharp
public static <Entity>ResDTO PopulateEntity(string json, <Entity>ResDTO dto, ReferenceResDTO refData) {
    Dictionary<string, object>? dict = JsonSerializer.Deserialize<Dictionary<string, object>>(json);
    if (dict == null) return dto;
    
    dto.Id = dict.ToLongValue(nameof(dto.Id));
    dto.TypeName = refData?.Items?.FirstOrDefault(i => i?.Code == dict.ToStringValue(nameof(dto.TypeName)))?.Name ?? "";
    return dto;
}
```

**When to Use:**
- Need to enrich response with reference data (LOVs, lookup values)
- Combining data from multiple System Layer calls
- Adding computed or derived properties based on multiple sources

**Example Usage:**
```csharp
// In Function or Service
HttpResponseSnapshot entityResponse = await _entityMgmt.GetEntity(dto);
HttpResponseSnapshot referenceResponse = await _referenceMgmt.GetLookupValues(new ReferenceReqDTO { Type = typeFilter });

<Entity>ResDTO entityDto = new <Entity>ResDTO();
ResponseDTOHelper.PopulateEntity(entityResponse.ExtractData(), entityDto);

ReferenceResDTO refData = ResponseDTOHelper.PopulateReference(referenceResponse.ExtractData());

// Enrich entity with reference data
ResponseDTOHelper.PopulateEntity(entityResponse.ExtractData(), entityDto, refData);
```

### 12.7 Response DTO Helper Rules - Key Rules

| Pattern | Usage | When |
|---------|-------|------|
| **Direct Deserialization** | Simple DTO matching | JSON matches DTO structure |
| **Dictionary Extraction** | Flexible mapping | JSON doesn't match DTO |
| **Complex Nested** | Arrays/nested objects | Complex response structure |
| **Response Enrichment** | Combine multiple sources | Reference data lookup |
| **Static Methods** | `public static` | Always |
| **Location** | `Helper/ResponseDTOHelper.cs` | Mandatory |

**üî¥ CRITICAL RULES:**

1. ‚úÖ **ALL response mapping logic MUST be in `Helper/ResponseDTOHelper.cs`** - Functions/Services MUST NOT contain mapping logic
2. ‚úÖ **All methods MUST be `public static`** - ResponseDTOHelper is a static utility class
3. ‚úÖ **Use appropriate pattern** - Choose pattern based on JSON structure complexity
4. ‚úÖ **Use DictionaryExtensions** - For flexible mapping, use Framework DictionaryExtensions (ToIntValue, ToStringValue, etc.)
5. ‚úÖ **Use `nameof()` for property names** - Ensures type safety and refactoring support
6. ‚úÖ **Handle null cases** - Always check for null before accessing dictionary values
7. ‚ùå **NEVER put mapping logic in Functions** - All mapping must be in ResponseDTOHelper
8. ‚ùå **NEVER use manual JSON parsing in Functions** - Use ResponseDTOHelper methods

### 12.8 Response DTO Helper Rules - Post-Creation Validation

**üõë POST-CREATION VALIDATION (MANDATORY - VERIFY BEFORE PROCEEDING)**

**üö® AFTER creating ResponseDTOHelper methods, you MUST verify:**

1. ‚úÖ **STOP AND VERIFY:** ResponseDTOHelper is located in `Helper/ResponseDTOHelper.cs`
2. ‚úÖ **STOP AND VERIFY:** All methods are `public static`
3. ‚úÖ **STOP AND VERIFY:** Methods use appropriate pattern (Direct Deserialization, Dictionary Extraction, Complex Nested, or Response Enrichment)
4. ‚úÖ **STOP AND VERIFY:** Methods handle null cases properly
5. ‚úÖ **STOP AND VERIFY:** Methods use `nameof()` for property names (if using Dictionary pattern)
6. ‚úÖ **STOP AND VERIFY:** Methods use DictionaryExtensions from Framework (if using Dictionary pattern)
7. ‚úÖ **STOP AND VERIFY:** Functions/Services use ResponseDTOHelper methods (NOT manual JSON parsing)

**üõë IF ANY VIOLATION ‚Üí STOP ‚Üí Fix ResponseDTOHelper ‚Üí Then proceed**

### 12.9 Response DTO Helper Rules - Common Mistakes

**‚ùå Putting Mapping Logic in Functions**

- **WRONG:** Private mapping method in Function class (e.g., `private <Operation>ResDTO Map<SOR>ResponseTo<Operation>Response(...)`)
- **CORRECT:** ALL response mapping logic MUST be in `Helper/ResponseDTOHelper.cs` as `public static` methods
- **Why:** Functions are thin orchestrators. All mapping/transformation logic belongs in ResponseDTOHelper for reusability and maintainability.

**‚ùå Manual JSON Parsing in Functions**

- **WRONG:** Manual JSON parsing with `JsonDocument` or `JsonElement` in Function class
- **CORRECT:** Use ResponseDTOHelper methods (e.g., `ResponseDTOHelper.PopulateEntity(responseContent, resDto)`)
- **Why:** ResponseDTOHelper provides standardized, reusable mapping patterns. Manual parsing is error-prone and violates separation of concerns.

**‚ùå Not Using DictionaryExtensions**

- **WRONG:** Manual type conversion in ResponseDTOHelper (e.g., `Convert.ToInt32(dict["Id"])`)
- **CORRECT:** Use DictionaryExtensions from Framework (e.g., `dict.ToIntValue(nameof(dto.Id))`)
- **Why:** DictionaryExtensions provide safe, null-aware type conversions with proper error handling.

**‚ùå Not Using nameof() for Property Names**

- **WRONG:** Hardcoded property names (e.g., `dict["Id"]`, `dict["Name"]`)
- **CORRECT:** Use `nameof()` for property names (e.g., `dict.ToIntValue(nameof(dto.Id))`)
- **Why:** `nameof()` ensures type safety, refactoring support, and compile-time checking.

**‚ùå Not Handling Null Cases**

- **WRONG:** Accessing dictionary values without null checks
- **CORRECT:** Always check for null before accessing dictionary values
- **Why:** JSON responses may have missing or null properties. Null checks prevent runtime exceptions.

**‚ùå Using Wrong Pattern**

- **WRONG:** Using Direct Deserialization for complex nested structures
- **CORRECT:** Use appropriate pattern based on JSON structure complexity
- **Why:** Each pattern is optimized for specific use cases. Using the wrong pattern leads to incorrect mapping or unnecessary complexity.

**‚ùå Not Understanding System Layer Response Structure**

- **WRONG:** Creating ResponseDTOHelper methods without understanding System Layer response structure
- **CORRECT:** Review System Layer Function's Handler and response DTOs before creating mapping methods
- **Why:** Understanding the source structure is REQUIRED to correctly map to Process Layer DTOs.

---

## 13. Config Models Rules

**üö® CRITICAL:** AppConfigs centralize all configuration values. ALL configuration values MUST be in AppConfigs, NEVER hardcoded.

**üî¥ MANDATORY CODE GENERATION CHECKLIST - APPsettings UPDATES (BLOCKING):**

**üö® THIS IS STEP 8 OF THE MANDATORY CODE GENERATION WORKFLOW (SEE TOP OF DOCUMENT)**

**When you reach this step in code generation, you MUST:**

1. **MANDATORY:** Read AppConfigs.cs ‚Üí List ALL new properties added
2. **MANDATORY:** For EACH new property in AppConfigs.cs:
   - [ ] Update `appsettings.dev.json` ‚Üí Add property with value/placeholder
   - [ ] Update `appsettings.qa.json` ‚Üí Add property with value/placeholder
   - [ ] Update `appsettings.stg.json` ‚Üí Add property with value/placeholder
   - [ ] Update `appsettings.prod.json` ‚Üí Add property with value/placeholder
   - [ ] Update `appsettings.dr.json` ‚Üí Add property with value/placeholder
3. **MANDATORY:** Verify ALL appsettings files have ALL properties from AppConfigs.cs
4. **üî¥ CRITICAL - BLOCKING:** Verify ALL appsettings VALUES against Boomi JSON files (source of truth):
   - [ ] **BLOCKING:** For EACH property in appsettings that has a known value (not TODO placeholder):
     - Identify which Boomi process/operation this property belongs to
     - Read Phase 1 document Section 2 (Process Properties Analysis) OR Section 22 (Process-Level Configuration) to find source
     - Read Boomi component JSON file (component_*.json) ‚Üí Locate `DefinedProcessProperties/definedProcessProperty[]/defaultValue/_` field
     - Compare appsettings value with Boomi component JSON defaultValue EXACTLY (case-sensitive, character-by-character)
     - If values don't match ‚Üí **VIOLATION** ‚Üí Fix appsettings value to match Boomi JSON ‚Üí Re-verify
   - [ ] **BLOCKING:** For error email configuration properties (File_Name prefix, HasAttachment):
     - File_Name prefix: Verify against Phase 1 Section 2 (defined parameter value) OR Boomi component JSON `defaultValue/_` field
     - HasAttachment: Verify against Boomi component JSON `defaultValue/_` field (must be exact match: "Y" or "N")
     - If File_Name is constructed (Process Name + Date pattern): Verify prefix matches Phase 1 documented pattern
   - [ ] **BLOCKING:** Document verification results: For EACH property, document:
     - Boomi component JSON file path
     - Phase 1 document section reference
     - Expected value from Boomi JSON
     - Actual value in appsettings
     - Match status (‚úÖ MATCH / ‚ùå MISMATCH)
5. **BLOCKING:** Code generation is INCOMPLETE until ALL appsettings files are updated AND all values verified against Boomi JSON

**üö® CRITICAL:** This step is BLOCKING - you CANNOT complete code generation without updating ALL appsettings files. This is NOT optional.

**üî¥ CROSS-REFERENCE:** This is part of the complete workflow. See "MANDATORY CODE GENERATION WORKFLOW" at the top of this document for the full sequence.

**üö® CRITICAL RULE - NO HARDCODED VALUES:**
- **ANY property that needs to be sent in downstream requests (System Layer calls) MUST NOT be hardcoded**
- **ALL values MUST be set in AppConfig (appsettings.json)**
- **For fixed/hardcoded values found in contracts or Boomi JSON files:**
  1. **FIRST:** Check Phase 1 Section 2 (Process Properties Analysis) for the property value
  2. **IF value exists in Phase 1 Section 2:** Use that ACTUAL value (NOT placeholder) in ALL AppConfig files - ‚ùå **NEVER use placeholder if value is known**
  3. **IF value does NOT exist in Phase 1 Section 2:** Check Boomi component JSON file (`component_*.json`) for default value
  4. **IF value exists in component JSON:** Use that ACTUAL value (NOT placeholder) in ALL AppConfig files - ‚ùå **NEVER use placeholder if value is known**
  5. **IF value does NOT exist in Phase 1 OR component JSON:** Add placeholder in ALL AppConfig files (e.g., `"TODO_REPLACE_WITH_<PROPERTY_NAME>"` or `"TODO_REPLACE_WITH_EMAIL"` for email properties) - ‚úÖ **Placeholders are ONLY for unknown values**

**üî¥ CRITICAL: Value vs Placeholder Decision:**
- **Value exists in Phase 1 OR component JSON?** ‚Üí Use ACTUAL value in all files (e.g., `"BoomiIntegrationTeam@al-ghurair.com"`)
- **Value does NOT exist in Phase 1 AND component JSON?** ‚Üí Use placeholder in all files (e.g., `"TODO_REPLACE_WITH_EMAIL"`)
- **Example:** Phase 1 shows `To_Email: "BoomiIntegrationTeam@al-ghurair.com"` ‚Üí Use `"BoomiIntegrationTeam@al-ghurair.com"` in all files, NOT `"TODO_REPLACE_WITH_EMAIL"`

**NEVER hardcode values in:**
- System Layer Function calls (request payloads, headers, query parameters)
- Business logic (company codes, organization units, business units)
- Configuration values (timeouts, retry counts, feature flags)
- Any properties sent to downstream systems

**ALWAYS use AppConfig properties:** All values must come from `_appConfigs` injected via `IOptions<AppConfigs>`

### 13.1 Config Models Rules - Pre-Creation Validation

**üõë PRE-CREATION VALIDATION (MANDATORY - STOP IF NOT COMPLETE)**

**üö® BEFORE creating AppConfigs, you MUST verify:**

1. ‚úÖ **STOP AND VERIFY:** Have I read this section completely?
2. ‚úÖ **STOP AND VERIFY:** Have I checked Phase 1 document (Section 2: Process Properties Analysis) for all configuration properties?
3. ‚úÖ **STOP AND VERIFY:** Have I checked Boomi component JSON files for default values?
4. ‚úÖ **STOP AND VERIFY:** Have I verified which layer needs each configuration (Process Layer vs System Layer)?
5. ‚úÖ **STOP AND VERIFY:** Do I understand the Decision Framework (AppConfigs vs Request DTO)?
6. ‚úÖ **STOP AND VERIFY:** Have I verified I'm NOT adding SOR base URLs or resource paths to Process Layer AppConfigs?
7. ‚úÖ **üî¥ CRITICAL - STOP AND VERIFY:** Do I understand that `appsettings.json` must be kept EMPTY because the pipeline fills it during deployment?

**üõë IF ANY MISSING ‚Üí STOP ‚Üí Complete verification ‚Üí Then create AppConfigs**

### 13.2 Config Models Rules - Decision Framework: AppConfigs vs Request DTO

**üî¥ CRITICAL:** Use this decision framework to determine if a value should be in AppConfigs (static configuration) or Request DTO (user-provided data).

**üö® PRIMARY RULE - BOOMI PARITY (MANDATORY):**

**The decision MUST be based on what Boomi does to maintain 1:1 behavioral parity:**

1. **‚úÖ AppConfigs:** If Boomi stores the value in:
   - **Defined Process Properties (DPP)** - `component_*.json` with `DefinedProcessProperties`
   - **Connection Properties** - `connection_*.json` with connection-specific config
   - **Process Properties** - Referenced via `processproperty` or `definedprocessparameter`
   - **KeyVault/Secrets** - Encrypted or sensitive values

2. **‚úÖ Request DTO:** If Boomi has the value in:
   - **Request Profile** - `profile_*.json` (input JSON profile)
   - **Dynamic Document Properties** - Set from request data
   - **User Input** - Values provided by API consumer in request body

**üî¥ MANDATORY VERIFICATION STEPS:**

1. **Check Request Profile:** Search `profile_*.json` files for the field name
   - ‚úÖ **Found in Request Profile** ‚Üí Request DTO
   - ‚ùå **NOT in Request Profile** ‚Üí Continue to step 2

2. **Check Defined Process Properties:** Search `component_*.json` files for `DefinedProcessProperties`
   - ‚úÖ **Found as Defined Process Property** ‚Üí AppConfigs
   - ‚ùå **NOT found** ‚Üí Continue to step 3

3. **Check Connection Properties:** Search `connection_*.json` files
   - ‚úÖ **Found in Connection** ‚Üí AppConfigs
   - ‚ùå **NOT found** ‚Üí Continue to step 4

4. **Check Process Usage:** Search for `processproperty` or `definedprocessparameter` references
   - ‚úÖ **Referenced as process property** ‚Üí AppConfigs
   - ‚ùå **NOT referenced** ‚Üí Re-evaluate (may be dynamic or computed)

**Decision Criteria (Secondary - Use if Boomi source unclear):**

| Criteria | AppConfigs (Config) | Request DTO (User Input) |
|----------|---------------------|--------------------------|
| **Scope** | Same for ALL requests | Different per request |
| **Source** | System/operational setting | Business data from user/client |
| **Environment** | Changes per environment (dev/qa/prod) | Same across environments |
| **Security** | Sensitive (credentials, admin emails) | Public business data |
| **Type** | Operational/administrative | Business transaction data |
| **Frequency** | Rarely changes (deployment-time) | Changes with every request |
| **Control** | Controlled by DevOps/Admin | Controlled by API consumer |

**Examples:**

**‚úÖ AppConfigs (Static Configuration):**
- **System Layer URLs:** `SystemLayerUrl`, `NotificationSystemLayerUrl`
- **Error Notification Emails:** `<FromEmailProperty>`, `<ToEmailProperty>` (admin notifications)
- **Timeouts:** `TimeoutSeconds` (system-level timeout)
- **Retry Counts:** `RetryCount` (system-level retry policy)
- **API Keys:** `ApiKey` (if same for all requests)
- **Business Context:** `OrganizationUnit`, `BusinessUnit` (if same for all requests)
- **Connection Strings:** Database, external service URLs
- **Feature Flags:** `EnableFeatureX`, `DisableFeatureY`

**‚úÖ Request DTO (User-Provided Data):**
- **Business Transaction Data:** `EntityId`, `EntityName`, `EntityDate`, `LocationId`
- **User-Specific Values:** `CustomerEmail`, `CustomerPhone` (if different per request)
- **Request-Specific Options:** `IsRequired`, `TagNames`, `ItemNumbers`
- **Optional Parameters:** `ReferenceNumber`, `Attachment` (optional fields)
- **Dynamic Headers:** Headers that change per request (if needed for downstream propagation)

**Special Cases:**

1. **Email Addresses:**
   - **AppConfigs:** Admin emails, support emails, system notification emails (operational)
   - **Request DTO:** Customer emails, recipient emails (business data)

2. **API Keys/Credentials:**
   - **AppConfigs:** If same for all requests (system-level authentication)
   - **Request DTO:** If per-request authentication (rare, usually in headers)

3. **URLs/Endpoints:**
   - **AppConfigs:** System Layer Function URLs, Process Layer Function URLs
   - **Request DTO:** Never (URLs are always system configuration)

4. **Business Context:**
   - **AppConfigs:** If same for all requests (e.g., single tenant, single organization)
   - **Request DTO:** If different per request (e.g., multi-tenant, user-specific organization)

5. **üî¥ CRITICAL: Defined Parameters Used for Runtime Decisions (Decision Shapes):**
   - **Code Logic (NOT AppConfigs):** If Phase 1 Section 3 (Decision Shape Analysis) or subprocess JSON shows the property is used in a **decision shape** to make runtime decisions
   - **Example:** `<DecisionProperty>` used in decision shape `if (<DecisionProperty> == "<Value>")` ‚Üí use "<OperationA>", else ‚Üí use "<OperationB>"
   - **Rule:** Even though `Source Type: definedparameter`, if it's used in a **decision shape** for runtime logic, determine it via **code logic** (e.g., `bool <decisionProperty> = !string.IsNullOrWhiteSpace(<dataField1>) && !string.IsNullOrWhiteSpace(<dataField2>);`)
   - **Why:** Decision shapes represent runtime conditional logic, not static configuration. The decision should be made by code based on actual data availability, not from configuration.
   - **Verification:** Check Phase 1 Section 3 (Decision Shape Analysis) or subprocess JSON files for `shapetype: "decision"` that uses the property
   - **‚ùå WRONG:** Adding `<DecisionProperty>` to AppConfigs when it's used in a decision shape
   - **‚úÖ CORRECT:** Determine `<decisionProperty>` via code logic: `bool <decisionProperty> = !string.IsNullOrWhiteSpace(<dataField1>) && !string.IsNullOrWhiteSpace(<dataField2>);`

### 13.3 Config Models Rules - AppConfigs Structure

**Standard Process Layer AppConfigs:**

```csharp
public class AppConfigs {
    public static string SectionName = "AppVariables";
    public string ASPNETCORE_ENVIRONMENT { get; set; }
    public string CreateEntityUrl { get; set; }  // System Layer URLs
    public string UpdateEntityUrl { get; set; }
    public string AuthProcessLayerUrl { get; set; }  // Process Layer URLs
    public string OrganizationUnit { get; set; }  // Business context
    public string BusinessUnit { get; set; }
    public ConnectionStrings ConnectionStrings { get; set; }
    public ExternalConfiguration ExternalConfig { get; set; }  // Nested configs
    public Dictionary<string, List<string>> StatusMap { get; set; } = new(StringComparer.OrdinalIgnoreCase);
    public Dictionary<string, string> ApiKeys { get; set; }
}

public class ExternalConfiguration {
    public string Provider { get; set; } = string.Empty;
    public string Template { get; set; } = string.Empty;
    public Dictionary<string, string> Headers { get; set; } = new();
    public Dictionary<string, string> Links { get; set; } = new();
}
```

**Central Data Layer AppConfigs (Shared Services):**

```csharp
public class AppConfigs { 
    public static string SectionName = "AppVariables"; 
    public string? ASPNETCORE_ENVIRONMENT { get; set; } 
    public string? ExternalUrl { get; set; } 
    public string Separator { get; set; } = "|@#$|"; 
}

public class JwtOptions { 
    public static string SectionName = "JwtOptions"; 
    public string Issuer { get; set; } = string.Empty; 
}

public class KeyVaultConfigs { 
    public static string SectionName = "KeyVaultConfigs"; 
    public const string DB_CONNECTION_STRING = "db-connection-string"; 
    public string Url { get; set; } = string.Empty; 
    public void validate() { 
        if (string.IsNullOrWhiteSpace(Url)) throw new ArgumentNullException(nameof(Url)); 
    } 
}
```

**Key Requirements:**
- ‚úÖ **SectionName:** MUST be `public static string SectionName = "AppVariables";`
- ‚úÖ **Properties:** Use appropriate types (string, int, Dictionary, nested classes)
- ‚úÖ **Nested Configs:** Use separate classes for complex configurations
- ‚úÖ **Default Values:** Use default values for optional properties (e.g., `= string.Empty`, `= new()`)

### 13.4 Config Models Rules - Critical URL Rule

**üî¥ CRITICAL URL RULE - NEVER VIOLATE:**

**Process Layer AppConfigs URLs MUST ONLY contain:**
- ‚úÖ **System Layer Function URLs** - URLs pointing to System Layer Azure Functions (e.g., `SystemLayerUrl`, `NotificationSystemLayerUrl`)
- ‚úÖ **Process Layer Function URLs** - URLs pointing to other Process Layer Azure Functions (e.g., `AuthProcessLayerUrl`, `DataProcessLayerUrl`)

**Process Layer AppConfigs URLs MUST NEVER contain:**
- ‚ùå **SOR (System of Record) URLs** - Direct URLs to external systems/APIs (e.g., `https://api.example.com`, `https://smtp.example.com`)
- ‚ùå **Downstream API URLs** - Direct URLs to third-party services
- ‚ùå **SOR base URLs** - Base URLs for external systems
- ‚ùå **SOR resource paths** - Resource paths for external systems
- ‚ùå **Any SOR URL construction components** - Any values used to construct SOR URLs

**Why:** Process Layer calls System Layer Functions via HTTP. System Layer Functions handle SOR communication. Process Layer should NEVER directly call SORs.

**Naming Convention:**
- System Layer URLs: `{SystemName}SystemLayerUrl` or `{SystemName}SystemLayer{Operation}Url`
- Process Layer URLs: `{ProcessName}ProcessLayerUrl` or `{ProcessName}ProcessLayer{Operation}Url`
- ‚ùå **WRONG:** `SystemApiUrl`, `NotificationSmtpUrl`, `SORUrl` (these suggest SOR URLs)
- ‚úÖ **CORRECT:** `SystemSystemLayerUrl`, `NotificationSystemLayerUrl` (these indicate System Layer Functions)

**Example:**
- ‚úÖ **Process Layer AppConfigs:** `<Operation>Url = "https://<system-layer-function-url>/api/<operation>"` (System Layer Function URL)
- ‚ùå **Process Layer AppConfigs:** `<SOR>BaseUrl`, `<SOR>ResourcePath` (SOR URL construction - belongs in System Layer AppConfigs)
- ‚úÖ **System Layer AppConfigs:** `<SOR>BaseUrl = "https://<sor-base-url>"`, `<SOR>ResourcePath = "/api/services/..."` (SOR URL construction)

### 13.5 Config Models Rules - Operation-Specific Error Email Configuration (MANDATORY)

**üî¥ CRITICAL: Operation-Specific Error Email Configuration Rule**

**üö® MANDATORY RULE:** When multiple operations in the same Process Layer have different error email configuration values (file name prefix, has attachment flag) from Phase 1, these MUST be operation-specific properties in AppConfigs, NOT generic properties.

**Rule:**
- **If Phase 1 shows different values per operation:** Each operation MUST have its own dedicated error email configuration properties
- **Naming Pattern:** `<Operation>ErrorEmailFileNamePrefix`, `<Operation>ErrorEmailHasAttachment`
- **Generic properties are PROHIBITED:** When operations have different values, generic `ErrorEmailFileNamePrefix` and `ErrorEmailHasAttachment` are WRONG

**How to Determine:**
1. **Check Phase 1 Section 2 (Process Properties Analysis)** for each operation's error email properties:
   - `process.DPP_File_Name` source and value
   - `process.DPP_HasAttachment` source and value
2. **Compare values across operations:**
   - If values are different ‚Üí Operation-specific properties REQUIRED
   - If values are identical ‚Üí Generic properties allowed (but operation-specific is still preferred for clarity)
3. **Check Phase 1 Section 9 (Subprocess Analysis)** for error handling subprocess properties:
   - Verify which properties are used in error email subprocess
   - Verify if properties differ per operation

**Implementation Pattern:**
```csharp
// ‚úÖ CORRECT: Operation-specific properties (when values differ)
public class AppConfigs {
    public static string SectionName = "AppVariables";
    public string ErrorEmailRecipient { get; set; } // Shared across operations
    
    // <Operation1> operation-specific error email config (from Phase 1 <Operation1>)
    public string <Operation1>ErrorEmailFileNamePrefix { get; set; } // From Phase 1 <Operation1> process.DPP_File_Name
    public string <Operation1>ErrorEmailHasAttachment { get; set; } // From Phase 1 <Operation1> process.DPP_HasAttachment
    
    // <Operation2> operation-specific error email config (from Phase 1 <Operation2>)
    public string <Operation2>ErrorEmailFileNamePrefix { get; set; } // From Phase 1 <Operation2> process.DPP_File_Name
    public string <Operation2>ErrorEmailHasAttachment { get; set; } // From Phase 1 <Operation2> process.DPP_HasAttachment
}
```

**Function Usage Pattern:**
```csharp
// ‚úÖ CORRECT: Use operation-specific config in Function
bool hasAttachment = _options.<Operation>ErrorEmailHasAttachment.Equals(InfoConstants.YES_VALUE, StringComparison.OrdinalIgnoreCase);
if (hasAttachment)
{
    attachmentFileName = $"{_options.<Operation>ErrorEmailFileNamePrefix}{DateTime.UtcNow:yyyy-MM-ddTHH:mm:ss.fffZ}{InfoConstants.TEXT_FILE_EXTENSION}";
    attachmentContent = JsonSerializer.Serialize(dto);
}
```

**Example Violations:**
- ‚ùå **WRONG:** Generic `ErrorEmailFileNamePrefix` and `ErrorEmailHasAttachment` when operations have different values from Phase 1
- ‚ùå **WRONG:** Using same generic property for multiple operations with different Phase 1 values
- ‚ùå **WRONG:** Not checking Phase 1 Section 2 for operation-specific values
- ‚úÖ **CORRECT:** Operation-specific properties when Phase 1 shows different values per operation

**Why This Rule Exists:**
1. **Boomi Parity:** Each Boomi process may have different error email configuration (file name prefix, has attachment flag) - must match exactly
2. **Maintainability:** Operation-specific properties make it clear which configuration applies to which operation
3. **Clarity:** Prevents confusion when multiple operations have different error email settings
4. **Phase 1 Compliance:** Ensures configuration matches Phase 1 documentation exactly

**Verification Steps:**
1. ‚úÖ Check Phase 1 Section 2 for each operation's `process.DPP_File_Name` and `process.DPP_HasAttachment` values
2. ‚úÖ Compare values across operations - if different, operation-specific properties REQUIRED
3. ‚úÖ Verify AppConfigs has operation-specific properties (not generic) when values differ
4. ‚úÖ Verify Functions use operation-specific properties (not generic) when values differ
5. ‚úÖ Verify all appsettings files have operation-specific values populated from Phase 1

### 13.6 Config Models Rules - Configuration Loading

**Location:** `Program.cs`

**Pattern:**
```csharp
// 1. Environment & Configuration Loading
string environment = Environment.GetEnvironmentVariable("ENVIRONMENT") ?? Environment.GetEnvironmentVariable("ASPNETCORE_ENVIRONMENT") ?? "dev";
builder.Configuration.AddJsonFile("appsettings.json", optional: true, reloadOnChange: true)
    .AddJsonFile($"appsettings.{environment}.json", optional: true, reloadOnChange: true)
    .AddEnvironmentVariables();

// 2. Configuration Binding
builder.Services.Configure<AppConfigs>(builder.Configuration.GetSection(AppConfigs.SectionName));
builder.Services.Configure<JwtOptions>(builder.Configuration.GetSection(JwtOptions.SectionName));  // Central Data Layer only
builder.Services.Configure<KeyVaultConfigs>(builder.Configuration.GetSection(KeyVaultConfigs.SectionName));  // Central Data Layer only
```

**Key Points:**
- ‚úÖ Load `appsettings.json` first (base/fallback values)
- ‚úÖ Load environment-specific file second (`appsettings.{environment}.json`)
- ‚úÖ Add environment variables last (override config files)
- ‚úÖ Use `Configure<T>()` to bind configuration sections
- ‚úÖ Use `SectionName` static property for section name

**Injection Pattern:**
```csharp
// In Function/Service/Abstraction
private readonly AppConfigs _appConfigs;

public <ClassName>(IOptions<AppConfigs> appConfigs, ...) {
    _appConfigs = appConfigs.Value;
}

// Usage
string url = _appConfigs.CreateEntityUrl;
string email = _appConfigs.ToEmail;
```

### 13.7 Config Models Rules - Environment Files

**üî¥ CRITICAL: Deployment Pipeline Behavior:**
- **`appsettings.json`** - **üî¥ KEEP EMPTY** - Runtime file used by Azure Function App after deployment. The deployment pipeline automatically copies environment-specific appsettings into this file during deployment. Do NOT add values or placeholders to this file - the pipeline will overwrite them.
- **`appsettings.dev.json`** - Source file for development environment - Pipeline merges/copies this into `appsettings.json` for dev deployments
- **`appsettings.qa.json`** - Source file for QA/Testing environment - Pipeline merges/copies this into `appsettings.json` for QA deployments
- **`appsettings.stg.json`** - Source file for Staging environment - Pipeline merges/copies this into `appsettings.json` for staging deployments
- **`appsettings.prod.json`** - Source file for Production environment - Pipeline merges/copies this into `appsettings.json` for production deployments
- **`appsettings.dr.json`** - Source file for Disaster Recovery environment - Pipeline merges/copies this into `appsettings.json` for DR deployments

**Key Principles:**
- **`appsettings.json`** - **üî¥ CRITICAL: Keep this file EMPTY or with minimal structure only** - The deployment pipeline automatically fills this file from environment-specific files during deployment. Do NOT add values or placeholders to `appsettings.json` - the pipeline will overwrite them.
- **Environment-specific files** (`appsettings.dev.json`, `appsettings.qa.json`, etc.) contain actual environment values - These are source files that the pipeline uses to populate `appsettings.json` during deployment
- **All properties must exist in ALL environment-specific files** - Same structure in all environment-specific files (`appsettings.dev.json`, `appsettings.qa.json`, `appsettings.stg.json`, `appsettings.prod.json`, `appsettings.dr.json`), but values may differ per environment

**File Structure:**
```json
// appsettings.json (KEEP EMPTY - Pipeline fills during deployment)
{
  "AppVariables": {
  }
}

// appsettings.dev.json (dev values)
{
  "AppVariables": {
    "CreateEntityUrl": "https://dev-system-layer-function.azurewebsites.net/api/createentity",
    "ToEmail": "dev-admin@example.com"
  }
}

// appsettings.qa.json (QA values)
{
  "AppVariables": {
    "CreateEntityUrl": "https://qa-system-layer-function.azurewebsites.net/api/createentity",
    "ToEmail": "qa-admin@example.com"
  }
}

// appsettings.stg.json (staging values)
{
  "AppVariables": {
    "CreateEntityUrl": "https://stg-system-layer-function.azurewebsites.net/api/createentity",
    "ToEmail": "stg-admin@example.com"
  }
}

// appsettings.prod.json (prod values)
{
  "AppVariables": {
    "CreateEntityUrl": "https://prod-system-layer-function.azurewebsites.net/api/createentity",
    "ToEmail": "prod-admin@example.com"
  }
}

// appsettings.dr.json (DR values)
{
  "AppVariables": {
    "CreateEntityUrl": "https://dr-system-layer-function.azurewebsites.net/api/createentity",
    "ToEmail": "dr-admin@example.com"
  }
}
```

### 13.8 Config Models Rules - Cache Settings (TTL Configuration)

**Pattern:** Cache settings can be configured in AppConfigs for TTL management.

```json
{
  "CacheSettings": {
    "DefaultTTL": 15,
    "TTLsInMinutes": {
      "GetEntityDetails": 120,
      "GetDataInfo": 120,
      "GetLookupValues": 1440,
      "GetReferenceData": 120
    }
  }
}
```

```csharp
public class CacheSettings {
    public int DefaultTTL { get; set; } = 15;
    public Dictionary<string, int> TTLsInMinutes { get; set; } = new();
    public int GetTTLForMethod(string methodName) {
        if (TTLsInMinutes != null && TTLsInMinutes.TryGetValue(methodName, out int ttl) && ttl > 0) return ttl;
        return DefaultTTL;
    }
}
```

**Usage:**
```csharp
// In Program.cs
builder.Services.Configure<CacheSettings>(builder.Configuration.GetSection("CacheSettings"));

// In Service
private readonly CacheSettings _cacheSettings;
public <Entity>Service(IOptions<CacheSettings> cacheSettings, ...) {
    _cacheSettings = cacheSettings.Value;
}

// Usage
int ttl = _cacheSettings.GetTTLForMethod(nameof(GetEntityDetails));
CacheKey cacheKey = CacheKey.CreateCacheKey(..., _cacheKeySettings: new CacheKeySettings { TimeToLive = TimeSpan.FromMinutes(ttl) });
```

### 13.9 Config Models Rules - Key Rules

| Component | Pattern | Mandatory |
|-----------|---------|-----------|
| **SectionName** | `public static string SectionName = "AppVariables";` | ‚úÖ Always |
| **Class Name** | `AppConfigs` | ‚úÖ Standard Process Layer |
| **Nested Configs** | Separate classes (e.g., `JwtOptions`, `KeyVaultConfigs`) | ‚ö†Ô∏è Central Data Layer only |
| **Injection** | `IOptions<AppConfigs>` | ‚úÖ Always |
| **Registration** | `builder.Services.Configure<AppConfigs>(...)` | ‚úÖ Always |
| **Environment Files** | `appsettings.json` (keep empty), `appsettings.dev.json`, `appsettings.qa.json`, `appsettings.stg.json`, `appsettings.prod.json`, `appsettings.dr.json` | ‚úÖ All must exist |
| **URL Rule** | ONLY System Layer Function URLs, NEVER SOR URLs | ‚úÖ **CRITICAL** |
| **Value vs Placeholder** | Use actual value if exists in Phase 1/component JSON, placeholder if unknown | ‚úÖ **CRITICAL** |

**üî¥ CRITICAL RULES:**

1. ‚úÖ **ALL configuration values MUST be in AppConfigs** - NEVER hardcode values
2. ‚úÖ **Use actual values if they exist in Phase 1 or component JSON** - NEVER use placeholder if value is known
3. ‚úÖ **Process Layer AppConfigs URLs MUST ONLY contain System Layer Function URLs** - NEVER SOR URLs
4. ‚úÖ **üî¥ CRITICAL: Keep `appsettings.json` EMPTY** - Pipeline fills it during deployment. Add all values to environment-specific files (`appsettings.dev.json`, `appsettings.qa.json`, `appsettings.stg.json`, `appsettings.prod.json`, `appsettings.dr.json`)
5. ‚úÖ **All properties must exist in ALL environment-specific files** - Same structure in all environment-specific files, different values per environment
6. ‚úÖ **Inject via `IOptions<AppConfigs>`** - Always use dependency injection
7. ‚úÖ **Use Decision Framework** - AppConfigs vs Request DTO based on Boomi parity
8. ‚úÖ **Verify which layer needs configuration** - Process Layer vs System Layer

### 13.10 Config Models Rules - Post-Creation Validation

**üõë POST-CREATION VALIDATION (MANDATORY - VERIFY BEFORE PROCEEDING)**

**üö® AFTER creating AppConfigs, you MUST verify:**

1. ‚úÖ **STOP AND VERIFY:** AppConfigs class has `public static string SectionName = "AppVariables";`
2. ‚úÖ **STOP AND VERIFY:** AppConfigs properties match Phase 1 Section 2 (defined parameters)
3. ‚úÖ **üî¥ CRITICAL - STOP AND VERIFY:** `appsettings.json` is kept EMPTY (or minimal structure only) - Pipeline fills it during deployment
4. ‚úÖ **STOP AND VERIFY:** All properties are added to ALL environment-specific files (`appsettings.dev.json`, `appsettings.qa.json`, `appsettings.stg.json`, `appsettings.prod.json`, `appsettings.dr.json`)
5. ‚úÖ **üî¥ CRITICAL - BLOCKING:** Verify ALL appsettings VALUES against Boomi JSON files (source of truth):
   - [ ] **BLOCKING:** For EACH property in appsettings that has a known value (not TODO placeholder):
     - Identify which Boomi process/operation this property belongs to
     - Read Phase 1 document Section 2 (Process Properties Analysis) OR Section 22 (Process-Level Configuration) to find source
     - Read Boomi component JSON file (component_*.json) ‚Üí Locate `DefinedProcessProperties/definedProcessProperty[]/defaultValue/_` field
     - Compare appsettings value with Boomi component JSON defaultValue EXACTLY (case-sensitive, character-by-character)
     - If values don't match ‚Üí **VIOLATION** ‚Üí Fix appsettings value to match Boomi JSON ‚Üí Re-verify
   - [ ] **BLOCKING:** For error email configuration properties (File_Name prefix, HasAttachment):
     - File_Name prefix: Verify against Phase 1 Section 2 (defined parameter value) OR Boomi component JSON `defaultValue/_` field
     - HasAttachment: Verify against Boomi component JSON `defaultValue/_` field (must be exact match: "Y" or "N")
     - If File_Name is constructed (Process Name + Date pattern): Verify prefix matches Phase 1 documented pattern
   - [ ] **BLOCKING:** Document verification results: For EACH property, document:
     - Boomi component JSON file path
     - Phase 1 document section reference
     - Expected value from Boomi JSON
     - Actual value in appsettings
     - Match status (‚úÖ MATCH / ‚ùå MISMATCH)
   - ‚úÖ **CORRECT:** All appsettings values match Boomi component JSON defaultValue fields exactly (verified character-by-character)
   - ‚ùå **WRONG:** Appsettings values don't match Boomi component JSON values (even if close or similar)
6. ‚úÖ **üî¥ CRITICAL - MANDATORY CHECKPOINT:** Have I verified I'm NOT adding SOR base URLs, SOR resource paths, or any SOR URL construction components to Process Layer AppConfigs?
   - ‚úÖ **CORRECT:** Process Layer AppConfigs contains ONLY System Layer Function URLs
   - ‚ùå **WRONG:** Process Layer AppConfigs contains SOR URLs, SOR base URLs, or SOR resource paths
7. ‚úÖ **STOP AND VERIFY:** Values use actual values (if exists in Phase 1/component JSON) or placeholders (if unknown)
8. ‚úÖ **üî¥ CRITICAL - STOP AND VERIFY:** If value is unknown, placeholder string MUST be added (NOT empty string) - Empty values are NOT allowed for unknown configuration
9. ‚úÖ **STOP AND VERIFY:** AppConfigs is registered in Program.cs: `builder.Services.Configure<AppConfigs>(...)`
10. ‚úÖ **STOP AND VERIFY:** AppConfigs is injected via `IOptions<AppConfigs>` in Functions/Services/Abstractions
11. ‚úÖ **STOP AND VERIFY:** All configuration values are read from `_appConfigs` (NOT hardcoded)
12. ‚úÖ **STOP AND VERIFY:** `HttpClientPolicy.RetryCount` is `0` (not `1`) in all environment files unless explicitly required

**üõë IF ANY VIOLATION ‚Üí STOP ‚Üí Fix AppConfigs ‚Üí Then proceed**

### 13.11 Config Models Rules - Common Mistakes

**‚ùå Hardcoding Configuration Values**

- **WRONG:** Hardcoded email address, URL, timeout, or API key in code
- **CORRECT:** ALL values MUST be in AppConfigs and read from `_appConfigs`
- **Why:** Configuration values must be environment-specific and maintainable. Hardcoding breaks environment separation and makes changes difficult.

**‚ùå Adding SOR URL Construction Components to Process Layer AppConfigs**

- **WRONG:** Adding `<SOR>BaseUrl`, `<SOR>ResourcePath`, or any SOR URL construction components to Process Layer AppConfigs
- **CORRECT:** Process Layer AppConfigs contains ONLY System Layer Function URLs. SOR URL construction belongs in System Layer AppConfigs.
- **Why:** Process Layer calls System Layer Functions via HTTP. System Layer constructs SOR URLs internally. This separation maintains proper architecture boundaries.

**‚ùå Adding Values to appsettings.json**

- **WRONG:** Adding values or placeholders to `appsettings.json` (e.g., `"CreateEntityUrl": "TODO_REPLACE_WITH_CREATE_ENTITY_URL"`)
- **CORRECT:** Keep `appsettings.json` EMPTY (or minimal structure only). Add all values to environment-specific files (`appsettings.dev.json`, `appsettings.qa.json`, `appsettings.stg.json`, `appsettings.prod.json`, `appsettings.dr.json`)
- **Why:** The deployment pipeline automatically fills `appsettings.json` from environment-specific files during deployment. Adding values to `appsettings.json` will be overwritten by the pipeline.

**‚ùå Using Placeholders When Actual Value Exists**

- **WRONG:** Using `"TODO_REPLACE_WITH_EMAIL"` when Phase 1 shows actual email value
- **CORRECT:** Use actual value from Phase 1 or component JSON in ALL environment-specific files (`appsettings.dev.json`, `appsettings.qa.json`, `appsettings.stg.json`, `appsettings.prod.json`, `appsettings.dr.json`)
- **Why:** If value is known, use it. Placeholders are ONLY for unknown values.

**‚ùå Using Empty String for Unknown Values**

- **WRONG:** Using empty string `""` for unknown configuration values
- **CORRECT:** Use placeholder string (e.g., `"TODO_REPLACE_WITH_URL"`, `"TODO_REPLACE_WITH_EMAIL"`) for unknown values
- **Why:** Empty strings make it unclear if the value is intentionally empty or missing. Placeholders clearly indicate the value needs to be provided.

**‚ùå Not Adding Properties to All Environment Files**

- **WRONG:** Adding property only to `appsettings.dev.json`
- **CORRECT:** Add property to ALL environment-specific files (`appsettings.dev.json`, `appsettings.qa.json`, `appsettings.stg.json`, `appsettings.prod.json`, `appsettings.dr.json`)
- **Why:** All properties must exist in all environment-specific files with same structure. Values may differ per environment.

**‚ùå Not Using Decision Framework**

- **WRONG:** Adding user-provided data to AppConfigs or adding configuration to Request DTO
- **CORRECT:** Use Decision Framework (AppConfigs vs Request DTO) based on Boomi parity
- **Why:** Decision must be based on what Boomi does to maintain 1:1 behavioral parity.

**‚ùå Not Verifying Which Layer Needs Configuration**

- **WRONG:** Adding SOR URL construction components to Process Layer AppConfigs
- **CORRECT:** Verify which layer needs configuration (Process Layer vs System Layer) before adding
- **Why:** SOR URL construction belongs in System Layer AppConfigs, NOT Process Layer AppConfigs.

**‚ùå Not Injecting via IOptions**

- **WRONG:** Reading configuration directly from `IConfiguration` or hardcoding values
- **CORRECT:** Inject `IOptions<AppConfigs>` and use `_appConfigs.PropertyName`
- **Why:** Dependency injection provides type safety, testability, and proper configuration management.

**‚ùå Using Generic Error Email Configuration When Operations Have Different Values**

- **WRONG:** Using generic `ErrorEmailFileNamePrefix` and `ErrorEmailHasAttachment` when Phase 1 shows different values per operation
- **CORRECT:** Use operation-specific properties: `<Operation>ErrorEmailFileNamePrefix`, `<Operation>ErrorEmailHasAttachment`
- **Why:** Each operation may have different error email configuration from Phase 1. Operation-specific properties ensure correct values are used per operation and maintain Boomi parity.
- **Verification:** Check Phase 1 Section 2 (Process Properties Analysis) for each operation's `process.DPP_File_Name` and `process.DPP_HasAttachment` values. If values differ, operation-specific properties are REQUIRED.

**üî¥ CRITICAL RULE: NO Hardcoded Values in Downstream Requests**

**MANDATORY:** ALL properties sent in downstream requests (System Layer or Process Layer calls) MUST be configured in AppConfigs/appsettings.json - NEVER hardcode values in code. If a value is found hardcoded (e.g., ContractId = "1"), first check Boomi JSON files (operation/map/profile) to extract the actual value, then add it to AppConfigs with the extracted value. If value doesn't exist in Boomi files, add placeholder in AppConfigs (e.g., ContractId = "") for environment-specific configuration. This ensures environment-specific values can be configured without code changes.

---

## 14. Constants Rules

**üö® CRITICAL:** Constants use standardized formats for error codes and string literals. Business logic string literals MUST use constants, NEVER hardcode strings. Exceptions: Function attribute names, stepName values, and logging messages are allowed as literal strings.

### 14.1 Constants Rules - Pre-Creation Validation

**üõë PRE-CREATION VALIDATION (MANDATORY - STOP IF NOT COMPLETE)**

**üö® BEFORE creating Constants, you MUST verify:**

1. ‚úÖ **STOP AND VERIFY:** Have I read this section completely?
2. ‚úÖ **STOP AND VERIFY:** Have I identified all operations that need error constants?
3. ‚úÖ **STOP AND VERIFY:** Do I know the BusinessDomain abbreviation (3 uppercase chars, e.g., PRP for Properties, FCL for Facilities, AUT for Automotive, HRM for HumanResource)?
4. ‚úÖ **STOP AND VERIFY:** Have I identified all string literals that need constants (process names, messages, email subjects, default values)?
5. ‚úÖ **STOP AND VERIFY:** Do I understand the difference between ErrorConstants (error codes) and InfoConstants (string literals)?

**üõë IF ANY MISSING ‚Üí STOP ‚Üí Complete verification ‚Üí Then create Constants**

### 14.2 Constants Rules - Error Constants Format

**üî¥ CRITICAL: Error Constants Format**

Error constants use standardized tuple format with specific error code structure.

**Format:**
```csharp
public static class ErrorConstants {
    public static readonly (string ErrorCode, string Message) ERROR_NAME =
        ("AAA_AAAAAA_DDDD", "Human-readable error message");
}
```

**Format Breakdown:**
- **AAA**: 3-character BusinessDomain abbreviation (e.g., PRP for Properties, FCL for Facilities, AUT for Automotive, HRM for HumanResource, KAB for KABITaxi)
- **AAAAAA**: 6-character operation name abbreviation (e.g., GETENT, CRTENT, UPDENT, DELENT)
- **DDDD**: 4-digit error series number (0001, 0002, 0003, ...)

**Total Length:** 15 characters (3 + 1 + 6 + 1 + 4)

**üî¥ CRITICAL: Process Layer vs System Layer Format:**
- **System Layer:** Uses `AAA_AAAAAA_DDDD` format where AAA = 3-char SOR abbreviation (e.g., SYS, EXT, API)
- **Process Layer:** Uses `AAA_AAAAAA_DDDD` format where AAA = 3-char BusinessDomain abbreviation (e.g., PRP, FCL, AUT, HRM, KAB)
- **Both layers:** Use 6-character operation abbreviation and 4-digit number

**Examples:**
```csharp
// Properties BusinessDomain (PRP)
public static readonly (string ErrorCode, string Message) GET_ENTITY_DETAILS_FAILURE =
    ("PRP_GETENT_0001", "Failure to get entity details");

public static readonly (string ErrorCode, string Message) CREATE_RECORD_FAILURE =
    ("PRP_CRTENT_0001", "Failed to create record");

// Facilities BusinessDomain (FCL)
public static readonly (string ErrorCode, string Message) UPDATE_DATA_FAILURE =
    ("FCL_UPDENT_0001", "Failure to update data");

// Automotive BusinessDomain (AUT)
public static readonly (string ErrorCode, string Message) DELETE_ENTITY_FAILURE =
    ("AUT_DELENT_0001", "Failed to delete entity");
```

**Usage:**
```csharp
throw new BusinessCaseFailureException(
    ErrorConstants.GET_ENTITY_DETAILS_FAILURE, 
    [ErrorConstants.GET_ENTITY_DETAILS_FAILURE.Message], 
    stepName: "EntityService.cs / VerifyEntity");

// Accessing parts
string code = ErrorConstants.GET_ENTITY_DETAILS_FAILURE.ErrorCode;  // "PRP_GETENT_0001"
string msg = ErrorConstants.GET_ENTITY_DETAILS_FAILURE.Message;      // "Failure to get entity details"
```

**‚ùå WRONG FORMATS (NEVER USE):**
```csharp
// ‚ùå WRONG: Missing operation part
("PRP_001", ...)

// ‚ùå WRONG: Lowercase
("prp_crtent_0001", ...)

// ‚ùå WRONG: Operation too long (CREATEENTITY = 12 chars, max 6)
("PRP_CREATEENTITY_0001", ...)

// ‚ùå WRONG: BusinessDomain too long (PRPC = 4 chars, max 3)
("PRPC_CRTENT_0001", ...)

// ‚ùå WRONG: BusinessDomain too short (PR = 2 chars, must be 3)
("PR_CRTENT_0001", ...)

// ‚ùå WRONG: Wrong tuple format
(string Code, string Message)  // Should be (string ErrorCode, string Message)
```

### 14.3 Constants Rules - Info Constants Format

**üî¥ CRITICAL: Info Constants Format**

Info constants use `public const string` for string literals (process names, messages, email subjects, default values).

**Format:**
```csharp
public static class InfoConstants {
    // Success messages
    public const string <OPERATION>_SUCCESS = "<Operation> completed successfully";
    
    // Default values
    public const string DEFAULT_PROCESS_NAME = "<Operation>Function";
    public const string DEFAULT_ENVIRONMENT = "dev";
    public const string DEFAULT_EXECUTION_ID = "N/A";
    
    // Email subjects
    public const string ERROR_EMAIL_SUBJECT = "<Operation> API has errors to report";
    
    // Note: Log messages are NOT constants - use direct string literals in logging calls
}
```

**üî¥ CRITICAL: Logging Message Pattern (MANDATORY)**

**üö® MANDATORY RULE:** Logging messages MUST use literal strings, NEVER constants.

**Rule:**
- ‚úÖ **CORRECT:** Use direct string literals in logging calls (e.g., `_logger.Error($"Operation failed: {errorMessage}")`)
- ‚ùå **WRONG:** Use constants in logging calls (e.g., `_logger.Error($"{InfoConstants.OPERATION_FAILED}: {errorMessage}")`)

**Why:**
- Logging messages are operational/debugging information, not business logic
- Literal strings in logging provide immediate context without needing to look up constants
- Logging messages are allowed as literal strings per validation rules (Step 4: "Is it logging message? ‚Üí **ALLOWED** (literal string)")

**Examples:**
```csharp
// ‚úÖ CORRECT: Literal strings in logging
_logger.Info("HTTP Request received for CreateLeave.");
_logger.Error($"D365 call failed: {errorFromD365.Message}");
_logger.Error($"Failed to send error notification email. Status: {emailResponse.StatusCode}. Error: {emailErrorMessage}");

// ‚ùå WRONG: Constants in logging
_logger.Info(InfoConstants.HTTP_REQUEST_RECEIVED);
_logger.Error($"{InfoConstants.D365_CALL_FAILED}: {errorFromD365.Message}");
_logger.Error($"{InfoConstants.EMAIL_SEND_FAILED}: {emailErrorMessage}");
```

**What Goes in Constants vs Logging:**
- ‚úÖ **Constants (InfoConstants.cs):** Business logic strings (process names, success messages, email subjects, default values)
- ‚úÖ **Literal Strings (Logging):** All logging messages (`_logger.Info()`, `_logger.Error()`)

**üî¥ MANDATORY: String Literals That MUST Be Constants:**
- ‚úÖ **Process names** - Default process names used in email templates or logging
- ‚úÖ **Default environment values** - Fallback environment names (e.g., "dev", "qa", "prod")
- ‚úÖ **Default execution IDs** - Fallback values for execution IDs (e.g., "N/A")
- ‚úÖ **Success messages** - All success messages returned in BaseResponseDTO
- ‚úÖ **Email subjects** - Email subject lines for notifications
- ‚úÖ **Email body placeholders** - Placeholder values used in email templates
- ‚úÖ **Default values** - Any hardcoded default/fallback values
- ‚úÖ **Step names** - Standardized step names for exceptions (if reused)
- ‚ùå **Log messages** - **NEVER create constants for logging string literals** - Use direct string literals in logging calls (e.g., `_logger.Info("Error notification email sent successfully.")`)

### 14.4 Constants Rules - Usage Patterns

**üî¥ CRITICAL: Use Constants Instead of Hardcoded Strings (MANDATORY)**

**üö® ALWAYS use constants files (InfoConstants.cs, ErrorConstants.cs) for string literals, NEVER hardcode strings directly in code.**

**‚ùå WRONG Patterns:**
```csharp
// ‚ùå WRONG: Hardcoded process name
string processName = Environment.GetEnvironmentVariable("PROCESS_NAME") ?? "<Operation>Function";

// ‚ùå WRONG: Hardcoded default environment
string environment = Environment.GetEnvironmentVariable("ATOM_NAME") ?? Environment.GetEnvironmentVariable("ASPNETCORE_ENVIRONMENT") ?? "dev";

// ‚ùå WRONG: Hardcoded default value
string executionId = RequestHeaders.RequestId.Item2.Value?.ToString() ?? "N/A";

// ‚ùå WRONG: Hardcoded success message
return new BaseResponseDTO("<Operation> completed successfully", string.Empty, <Operation>Res);

// ‚ùå WRONG: Hardcoded email subject
Subject = $"<Operation> API has errors to report";

// ‚ùå WRONG: Hardcoded header name
dto.Headers.TryGetValue("request-id", out string? requestId);

// ‚ùå WRONG: Hardcoded step name
stepName: "CreateEntityFunction.cs / Executing Run"
```

**‚úÖ CORRECT Patterns:**
```csharp
// ‚úÖ CORRECT: Use constants for default values
string processName = Environment.GetEnvironmentVariable("PROCESS_NAME") ?? InfoConstants.DEFAULT_PROCESS_NAME;
string environment = Environment.GetEnvironmentVariable("ATOM_NAME") ?? Environment.GetEnvironmentVariable("ASPNETCORE_ENVIRONMENT") ?? InfoConstants.DEFAULT_ENVIRONMENT;
string executionId = RequestHeaders.RequestId.Item2.Value?.ToString() ?? InfoConstants.DEFAULT_EXECUTION_ID;

// ‚úÖ CORRECT: Use constants for success messages
return new BaseResponseDTO(InfoConstants.<OPERATION>_SUCCESS, string.Empty, <Operation>Res);

// ‚úÖ CORRECT: Use constants for email subjects
Subject = InfoConstants.ERROR_EMAIL_SUBJECT;

// ‚úÖ CORRECT: Use RequestHeaders class for header names (NOT hardcoded)
RequestHeaders.RequestId.Item2.Value?.ToString()

// ‚úÖ CORRECT: Use direct string literals for log messages (NEVER create constants for logging)
_logger.Info("HTTP Request received for CreateEntity.");
_logger.Info("Error notification email sent successfully.");
_logger.Error($"Failed to send error notification email. Status: {statusCode}, Message: {message}");
```

**Key Principles:**
- **Maintainability:** String literals in constants are easier to update and maintain
- **Consistency:** Constants ensure consistent messaging across the application
- **Reusability:** Constants can be reused across multiple Functions/Services
- **Type safety:** Constants provide compile-time checking and IntelliSense support
- **Single source of truth:** All string values defined in one place

### 14.5 Constants Rules - Folder Structure & Naming

**Location:**
- `Constants/ErrorConstants.cs` - Error constants with tuple format
- `Constants/InfoConstants.cs` - Info constants with string format

**Namespace:**
- `<ProjectName>.Constants`

**File Structure:**
```
<ProjectName>/
‚îú‚îÄ‚îÄ Constants/
‚îÇ   ‚îú‚îÄ‚îÄ ErrorConstants.cs
‚îÇ   ‚îî‚îÄ‚îÄ InfoConstants.cs
```

### 14.6 Constants Rules - Key Rules

| Component | Pattern | Mandatory |
|-----------|---------|-----------|
| **Error Constants Format** | `(string ErrorCode, string Message)` tuple | ‚úÖ Always |
| **Error Code Format** | `AAA_AAAAAA_DDDD` (BusinessDomain_Operation_Number) | ‚úÖ Always |
| **BusinessDomain** | 3 uppercase chars (PRP, FCL, AUT, HRM, KAB) | ‚úÖ Always |
| **Operation** | 6 uppercase chars (GETENT, CRTENT, UPDENT) | ‚úÖ Always |
| **Number** | 4 digits (0001, 0002, 0003, ...) | ‚úÖ Always |
| **Info Constants Format** | `public const string` | ‚úÖ Always |
| **String Literals** | MUST use constants, NEVER hardcode | ‚úÖ **CRITICAL** |
| **Header Names** | Use `RequestHeaders` class or constants, NEVER hardcoded | ‚úÖ **CRITICAL** |

**üî¥ CRITICAL RULES:**

1. ‚úÖ **Business logic string literals MUST use constants** - NEVER hardcode strings in Functions, Services, or any code. Exceptions: Function attribute names, stepName values, and logging messages are allowed as literal strings.
2. ‚úÖ **Error constants MUST use tuple format** - `(string ErrorCode, string Message)` NOT `(string Code, string Message)`
3. ‚úÖ **Error code format MUST be `AAA_AAAAAA_DDDD`** - BusinessDomain (3 chars) + Operation (6 chars) + Number (4 digits)
4. ‚úÖ **BusinessDomain abbreviation MUST be 3 uppercase characters** - Exactly 3 chars, no more, no less
5. ‚úÖ **Operation abbreviation MUST be 6 uppercase characters** - Exactly 6 chars, no more, no less
6. ‚úÖ **Error number MUST be 4 digits** - Sequential numbering (0001, 0002, 0003, ...)
7. ‚úÖ **Header names MUST use `RequestHeaders` class or constants** - NEVER hardcoded header names
8. ‚úÖ **Process names, messages, email subjects MUST use InfoConstants** - NEVER hardcode these values

### 14.7 Constants Rules - Post-Creation Validation

**üõë POST-CREATION VALIDATION (MANDATORY - VERIFY BEFORE PROCEEDING)**

**üö® AFTER creating Constants, you MUST verify:**

**ErrorConstants.cs Validation:**
1. ‚úÖ **STOP AND VERIFY:** Tuple format is `(string ErrorCode, string Message)` NOT `(string Code, string Message)`
2. ‚úÖ **STOP AND VERIFY:** Error code format is `AAA_AAAAAA_DDDD` (exactly this pattern)
3. ‚úÖ **STOP AND VERIFY:** AAA is exactly 3 chars - BusinessDomain abbreviation (e.g., PRP, FCL, AUT, HRM, KAB)
4. ‚úÖ **STOP AND VERIFY:** AAAAAA is exactly 6 chars - Operation name abbreviation (e.g., GETENT, CRTENT, UPDENT)
5. ‚úÖ **STOP AND VERIFY:** DDDD is exactly 4 digits (0001, 0002, etc.)
6. ‚úÖ **STOP AND VERIFY:** All error codes are uppercase
7. ‚úÖ **STOP AND VERIFY:** All constants use `readonly (string ErrorCode, string Message)`

**InfoConstants.cs Validation:**
8. ‚úÖ **STOP AND VERIFY:** Business logic string literals use constants from InfoConstants.cs (exceptions: Function attribute names, stepName, logging messages)
9. ‚úÖ **STOP AND VERIFY:** Process names use constants (NOT hardcoded)
10. ‚úÖ **STOP AND VERIFY:** Default values use constants (NOT hardcoded)
11. ‚úÖ **STOP AND VERIFY:** Success messages use constants (NOT hardcoded)
12. ‚úÖ **STOP AND VERIFY:** Email subjects use constants (NOT hardcoded)
    13. ‚úÖ **STOP AND VERIFY:** Log messages use direct string literals (NOT constants) - Logging string literals should NOT be in InfoConstants.cs

**Code Validation:**
14. ‚úÖ **STOP AND VERIFY:** Run `grep -n "\"[A-Za-z]" <file>` ‚Üí For EACH string literal found, verify it uses a constant
15. ‚úÖ **STOP AND VERIFY:** Verify NO hardcoded header names (use `RequestHeaders` class or constants)
16. ‚úÖ **STOP AND VERIFY:** Verify NO hardcoded process names, messages, or default values

**üõë IF ANY VIOLATION ‚Üí STOP ‚Üí Fix Constants ‚Üí Then proceed**

### 14.8 Constants Rules - Common Mistakes

**‚ùå Using Wrong Tuple Format**

- **WRONG:** `(string Code, string Message)` - Wrong tuple field names
- **CORRECT:** `(string ErrorCode, string Message)` - Correct tuple format
- **Why:** The tuple format must match exactly for proper error handling and code consistency.

**‚ùå Wrong Error Code Format**

- **WRONG:** `"PRP_001"` - Missing operation part
- **WRONG:** `"prp_crtent_0001"` - Lowercase (must be uppercase)
- **WRONG:** `"PRP_CREATEENTITY_0001"` - Operation too long (CREATEENTITY = 12 chars, max 6)
- **WRONG:** `"PRPC_CRTENT_0001"` - BusinessDomain too long (PRPC = 4 chars, max 3)
- **WRONG:** `"PR_CRTENT_0001"` - BusinessDomain too short (PR = 2 chars, must be 3)
- **CORRECT:** `"PRP_CRTENT_0001"` - Correct format (3 + 6 + 4 = 15 chars)
- **Why:** Error code format must be exactly `AAA_AAAAAA_DDDD` for consistency and standardization.

**‚ùå Hardcoding String Literals**

- **WRONG:** `string processName = "<Operation>Function";` - Hardcoded process name
- **WRONG:** `return new BaseResponseDTO("Success", ...);` - Hardcoded success message
- **WRONG:** `Subject = $"<Operation> API has errors";` - Hardcoded email subject
- **WRONG:** `string executionId = "N/A";` - Hardcoded default value
- **CORRECT:** Use constants from InfoConstants.cs for business logic string literals (exceptions: Function attribute names, stepName, logging messages)
- **Why:** Constants provide maintainability, consistency, reusability, and single source of truth.

**‚ùå Hardcoding Header Names**

- **WRONG:** `dto.Headers.TryGetValue("request-id", out string? requestId)` - Hardcoded header name
- **WRONG:** `dto.Headers.TryGetValue("<header-name>", out string? headerValue)` - Hardcoded header name
- **CORRECT:** Use `RequestHeaders.RequestId.Item2.Value?.ToString()` or constants for header names
- **Why:** Header names should use `RequestHeaders` class or constants to avoid typos and ensure consistency.

**‚ùå Confusing ErrorConstants with InfoConstants**

- **WRONG:** Using ErrorConstants for success messages or default values
- **WRONG:** Using InfoConstants for error codes
- **CORRECT:** ErrorConstants for error codes (tuple format), InfoConstants for string literals (const string)
- **Why:** Each constant type has a specific purpose and format. Mixing them causes confusion and errors.

**‚ùå Not Using Constants for Step Names**

- **WRONG:** Hardcoding step names in exceptions: `stepName: "CreateEntityFunction.cs / Executing Run"`
- **CORRECT:** Use constants for reusable step names: `stepName: InfoConstants.STEP_NAME_CREATE_ENTITY`
- **Why:** Step names should be consistent and maintainable. If a step name is reused, it should be a constant.

---

## 15. Enums Rules

**üö® CRITICAL:** Enums use `[StringValue]` attribute for external values. Enums are used when values need to map to external string representations (e.g., SOR API values, Boomi contract values).

### 15.1 Enums Rules - Pre-Creation Validation

**üõë PRE-CREATION VALIDATION (MANDATORY - STOP IF NOT COMPLETE)**

**üö® BEFORE creating Enums, you MUST verify:**

1. ‚úÖ **STOP AND VERIFY:** Have I read this section completely?
2. ‚úÖ **STOP AND VERIFY:** Do I need an enum (does the value need to map to an external string representation)?
3. ‚úÖ **STOP AND VERIFY:** Have I checked if Framework already provides the enum I need?
4. ‚úÖ **STOP AND VERIFY:** Do I know the exact external string values that need to be mapped?
5. ‚úÖ **STOP AND VERIFY:** Have I verified the external string values from Phase 1 document or Boomi JSON profile?

**üõë IF ANY MISSING ‚Üí STOP ‚Üí Complete verification ‚Üí Then create Enum**

### 15.2 Enums Rules - Structure & Pattern

**üî¥ CRITICAL: Enum Pattern with StringValue Attribute**

Enums MUST use `[StringValue]` attribute to map enum values to external string representations.

**Format:**
```csharp
public enum DataType {
    [StringValue("PRIMARY")]
    Primary,
    [StringValue("SECONDARY")]
    Secondary,
    [StringValue("TERTIARY")]
    Tertiary
}
```

**Key Rules:**
- ‚úÖ **ALWAYS use `[StringValue]` attribute** for enum values that map to external strings
- ‚úÖ **Enum name** uses PascalCase (e.g., `Primary`, `Secondary`)
- ‚úÖ **StringValue** matches external string representation exactly (e.g., `"PRIMARY"`, `"SECONDARY"`)
- ‚úÖ **StringValue values** are case-sensitive and must match external system values exactly

**When to Use Enums:**
- ‚úÖ When values need to map to external string representations (SOR API values, Boomi contract values)
- ‚úÖ When values are fixed/known and need type safety
- ‚úÖ When values are reused across multiple operations

**When NOT to Use Enums:**
- ‚ùå For user-provided values (use string properties in DTOs)
- ‚ùå For configuration values (use AppConfigs)
- ‚ùå For values that change frequently (use string properties)

### 15.3 Enums Rules - Enum Extension Method

**üî¥ CRITICAL: GetStringValue() Extension Method**

Framework provides `EnumExtensions.GetStringValue()` method to extract string values from enums.

**Framework Extension (Core/Extensions/EnumExtensions.cs):**
```csharp
public static class EnumExtensions {
    public static string GetStringValue(this Enum value) {
        Type type = value.GetType();
        FieldInfo? fieldInfo = type.GetField(value.ToString());
        StringValueAttribute[]? attrs = fieldInfo?.GetCustomAttributes(typeof(StringValueAttribute), false) as StringValueAttribute[];
        return attrs?.Length > 0 ? attrs[0].Value : value.ToString();
    }
}
```

**Usage:**
```csharp
using Core.Extensions;

// Get string value from enum
string type = DataType.Primary.GetStringValue();  // Returns "PRIMARY"
string secondary = DataType.Secondary.GetStringValue();  // Returns "SECONDARY"

// Use in DTO mapping
dto.Type = DataType.Primary.GetStringValue();  // Maps enum to external string value
```

**Key Rules:**
- ‚úÖ **ALWAYS use `GetStringValue()` extension method** to get string value from enum
- ‚úÖ **ALWAYS add `using Core.Extensions;`** to access `GetStringValue()` method
- ‚úÖ **If StringValue attribute is missing**, method returns `value.ToString()` as fallback

### 15.4 Enums Rules - Folder Structure & Naming

**Location:**
- `Enums/<EnumName>.cs` - One enum per file

**Namespace:**
- `<ProjectName>.Enums`

**File Structure:**
```
<ProjectName>/
‚îú‚îÄ‚îÄ Enums/
‚îÇ   ‚îú‚îÄ‚îÄ DataType.cs
‚îÇ   ‚îú‚îÄ‚îÄ StatusType.cs
‚îÇ   ‚îî‚îÄ‚îÄ <EnumName>.cs
```

**Naming Conventions:**
- **File Name:** `<EnumName>.cs` (e.g., `DataType.cs`, `StatusType.cs`)
- **Enum Name:** PascalCase (e.g., `DataType`, `StatusType`)
- **Enum Values:** PascalCase (e.g., `Primary`, `Secondary`, `Active`, `Inactive`)
- **StringValue:** Match external string representation exactly (e.g., `"PRIMARY"`, `"ACTIVE"`)

### 15.5 Enums Rules - Key Rules

| Component | Pattern | Mandatory |
|-----------|---------|-----------|
| **StringValue Attribute** | `[StringValue("EXTERNAL_VALUE")]` | ‚úÖ Always |
| **Enum Extension** | `GetStringValue()` from `Core.Extensions` | ‚úÖ Always |
| **File Location** | `Enums/<EnumName>.cs` | ‚úÖ Always |
| **Namespace** | `<ProjectName>.Enums` | ‚úÖ Always |
| **StringValue Matching** | Must match external string exactly (case-sensitive) | ‚úÖ **CRITICAL** |
| **Framework Extension** | Use Framework `EnumExtensions.GetStringValue()` | ‚úÖ Always |

**üî¥ CRITICAL RULES:**

1. ‚úÖ **ALL enums MUST use `[StringValue]` attribute** - For mapping to external string representations
2. ‚úÖ **ALWAYS use `GetStringValue()` extension method** - From `Core.Extensions.EnumExtensions`
3. ‚úÖ **StringValue values MUST match external strings exactly** - Case-sensitive, must match SOR API or Boomi contract values
4. ‚úÖ **One enum per file** - Standard C# convention, one enum class per file
5. ‚úÖ **Use Framework extensions** - Do NOT create custom enum extension methods, use Framework `GetStringValue()`
6. ‚úÖ **Verify external string values** - Check Phase 1 document or Boomi JSON profile for exact string values

### 15.6 Enums Rules - Post-Creation Validation

**üõë POST-CREATION VALIDATION (MANDATORY - VERIFY BEFORE PROCEEDING)**

**üö® AFTER creating Enum, you MUST verify:**

1. ‚úÖ **STOP AND VERIFY:** All enum values have `[StringValue]` attribute
2. ‚úÖ **STOP AND VERIFY:** StringValue values match external string representations exactly (case-sensitive)
3. ‚úÖ **STOP AND VERIFY:** Enum file is in `Enums/` folder with correct naming (`<EnumName>.cs`)
4. ‚úÖ **STOP AND VERIFY:** Enum uses correct namespace (`<ProjectName>.Enums`)
5. ‚úÖ **STOP AND VERIFY:** Code uses `GetStringValue()` extension method (NOT manual string conversion)
6. ‚úÖ **STOP AND VERIFY:** Code includes `using Core.Extensions;` to access `GetStringValue()` method
7. ‚úÖ **STOP AND VERIFY:** StringValue values are verified against Phase 1 document or Boomi JSON profile

**üõë IF ANY VIOLATION ‚Üí STOP ‚Üí Fix Enum ‚Üí Then proceed**

### 15.7 Enums Rules - Common Mistakes

**‚ùå Missing StringValue Attribute**

- **WRONG:** Enum without `[StringValue]` attribute
```csharp
public enum DataType {
    Primary,  // ‚ùå Missing [StringValue] attribute
    Secondary
}
```
- **CORRECT:** Enum with `[StringValue]` attribute
```csharp
public enum DataType {
    [StringValue("PRIMARY")]
    Primary,
    [StringValue("SECONDARY")]
    Secondary
}
```
- **Why:** `[StringValue]` attribute is required to map enum values to external string representations.

**‚ùå Wrong StringValue Case or Value**

- **WRONG:** `[StringValue("primary")]` when external system expects `"PRIMARY"` (case mismatch)
- **WRONG:** `[StringValue("PRIM")]` when external system expects `"PRIMARY"` (value mismatch)
- **CORRECT:** `[StringValue("PRIMARY")]` - Matches external string exactly
- **Why:** StringValue values are case-sensitive and must match external system values exactly.

**‚ùå Not Using GetStringValue() Extension Method**

- **WRONG:** Manual string conversion: `DataType.Primary.ToString()` or `"PRIMARY"` (hardcoded)
- **CORRECT:** Use extension method: `DataType.Primary.GetStringValue()`
- **Why:** `GetStringValue()` extracts the correct string value from `[StringValue]` attribute. Manual conversion or hardcoding breaks the mapping.

**‚ùå Missing Using Statement**

- **WRONG:** Using `GetStringValue()` without `using Core.Extensions;`
- **CORRECT:** Add `using Core.Extensions;` at the top of the file
- **Why:** `GetStringValue()` is an extension method from `Core.Extensions.EnumExtensions` namespace.

**‚ùå Creating Custom Enum Extension Methods**

- **WRONG:** Creating custom `GetStringValue()` method in project
- **CORRECT:** Use Framework `EnumExtensions.GetStringValue()` from `Core.Extensions`
- **Why:** Framework provides the extension method. Creating custom versions causes inconsistency and maintenance issues.

**‚ùå Using Enums for User-Provided Values**

- **WRONG:** Using enum for values that come from user input or request
- **CORRECT:** Use string properties in DTOs for user-provided values
- **Why:** Enums are for fixed/known values that map to external systems. User-provided values should be strings.

**‚ùå Using Enums for Configuration Values**

- **WRONG:** Using enum for configuration values (e.g., environment names, URLs)
- **CORRECT:** Use AppConfigs for configuration values
- **Why:** Configuration values belong in AppConfigs, not enums. Enums are for business logic values that map to external systems.

---

## 16. Extensions Rules

**üö® CRITICAL:** Use Framework extensions; create project-specific extensions only if needed. Framework extensions are mandatory and must be used instead of direct API calls.

### 16.1 Extensions Rules - Pre-Creation Validation

**üõë PRE-CREATION VALIDATION (MANDATORY - STOP IF NOT COMPLETE)**

**üö® BEFORE creating Project-Specific Extensions, you MUST verify:**

1. ‚úÖ **STOP AND VERIFY:** Have I read this section completely?
2. ‚úÖ **STOP AND VERIFY:** Have I checked if Framework already provides this extension functionality?
3. ‚úÖ **STOP AND VERIFY:** Is this extension truly domain-specific and not available in Framework?
4. ‚úÖ **STOP AND VERIFY:** Do I understand the difference between Framework extensions (mandatory) and project-specific extensions (optional)?
5. ‚úÖ **STOP AND VERIFY:** Am I using all required Framework extensions (LoggerExtensions, HttpRequestExtensions, HttpResponseExtensions)?

**üõë IF ANY MISSING ‚Üí STOP ‚Üí Complete verification ‚Üí Then create Extension**

**Note:** Framework extensions are MANDATORY and must be used. Project-specific extensions are OPTIONAL and should only be created if Framework doesn't provide the needed functionality.

### 16.2 Extensions Rules - Framework Extensions (Mandatory Use)

**üî¥ CRITICAL: Framework Extensions are MANDATORY**

Framework provides extensions that MUST be used. Never use direct API calls when Framework extensions are available.

**Required Using Statement:**
```csharp
using Core.Extensions;  // Required for all Framework extensions
```

**Framework Extensions:**

**1. LoggerExtensions (MANDATORY)**
```csharp
// ‚úÖ CORRECT: Use extension methods
_logger.Info("message");
_logger.Error(ex, "message");
_logger.Warn("message");
_logger.Debug("message");

// ‚ùå WRONG: Never use ILogger directly
_logger.LogInformation("message");  // PROHIBITED
_logger.LogError(ex, "message");     // PROHIBITED
```
- **Location:** `Core/Extensions/LoggerExtensions.cs`
- **Usage:** ALWAYS use `Info()`, `Error()`, `Warn()`, `Debug()` extension methods
- **Mandatory:** ‚úÖ YES - Never use `ILogger` directly

**2. HttpRequestExtensions (MANDATORY)**
```csharp
// ‚úÖ CORRECT: Use extension method
<Operation>ReqDTO? dto = await req.ReadBodyAsync<<Operation>ReqDTO>();

// ‚ùå WRONG: Manual body reading
// Manual JSON deserialization - PROHIBITED
```
- **Location:** `Core/Extensions/HttpRequestExtensions.cs`
- **Usage:** ALWAYS use `ReadBodyAsync<T>()` for reading request body
- **Mandatory:** ‚úÖ YES - Must use for all request body reading

**3. HttpResponseExtensions (MANDATORY)**
```csharp
// ‚úÖ CORRECT: Use extension methods
string data = await response.ExtractDataAsync();
BaseResponseDTO baseRes = response.ExtractBaseResponse().Result;

// ‚ùå WRONG: Manual response extraction
// Manual JSON parsing - PROHIBITED
```
- **Location:** `Core/Extensions/HttpResponseExtensions.cs`
- **Usage:** ALWAYS use `ExtractDataAsync()` and `ExtractBaseResponse()` for response handling
- **Mandatory:** ‚úÖ YES - Must use for all response data extraction

**4. StringExtensions (Use Framework Version)**
```csharp
// ‚úÖ CORRECT: Use Framework extension methods
string clean = value.RemoveAllWhitespace();
bool valid = email.IsValidEmail();

// ‚ùå WRONG: Custom string manipulation
// Manual string operations - Use Framework extensions instead
```
- **Location:** `Core/Extensions/StringExtensions.cs`
- **Usage:** Use Framework version for string operations
- **Mandatory:** ‚úÖ YES - Use Framework version, don't create custom string extensions

**5. DictionaryExtensions (Use Framework Version)**
```csharp
// ‚úÖ CORRECT: Use Framework extension methods (used in ResponseDTOHelper)
int val = dict.ToIntValue(nameof(dto.Id));
string str = dict.ToStringValue(nameof(dto.Name));
DateTime? dt = dict.ToDateTimeValue(nameof(dto.CreatedAt));
```
- **Location:** `Core/Extensions/DictionaryExtensions.cs`
- **Usage:** Used in ResponseDTOHelper for dictionary value extraction
- **Mandatory:** ‚úÖ YES - Use Framework version for dictionary operations

**6. EnumExtensions (Use Framework Version)**
```csharp
// ‚úÖ CORRECT: Use Framework extension method
string type = DataType.Primary.GetStringValue();  // Returns "PRIMARY"
```
- **Location:** `Core/Extensions/EnumExtensions.cs`
- **Usage:** Use `GetStringValue()` for enum string value extraction
- **Mandatory:** ‚úÖ YES - Use Framework version (see Section 15: Enums Rules)

**7. TupleExtension (Framework Internal)**
```csharp
// Framework internal extension
// .Simplify() converts Tuple<string, AsyncLocal<StringBuilder>> to Tuple<string, string>
// Used internally by SendProcessHTTPReqAsync() extension method
```
- **Location:** `Core/Extensions/TupleExtension.cs`
- **Usage:** Internal Framework extension, used by `SendProcessHTTPReqAsync()`
- **Mandatory:** ‚úÖ Internal use only

**8. CustomHttpClientExtensions (MANDATORY)**
```csharp
// ‚úÖ CORRECT: Use extension method for HTTP calls
HttpResponseMessage response = await _customHttpClient.SendProcessHTTPReqAsync(
    method: HttpMethod.Post,
    url: _appConfigs.SystemLayerUrl,
    contentType: "application/json",
    body: request,
    reqHeaders: businessHeaders);

// ‚ùå WRONG: Direct HTTP calls
// Manual HttpClient calls - PROHIBITED
```
- **Location:** `Framework/Core/Core/ProcessLayer/Extensions/CustomHttpClientExtensions.cs`
- **Usage:** ALWAYS use `SendProcessHTTPReqAsync()` for Process‚ÜíSystem and Process‚ÜíProcess HTTP calls
- **Mandatory:** ‚úÖ YES - Must use for all HTTP calls (see Sections 5 and 6)
- **Features:** Automatically adds TestRunId/RequestId headers, handles JSON serialization

### 16.3 Extensions Rules - Project-Specific Extensions (Optional)

**‚ö†Ô∏è OPTIONAL: Project-Specific Extensions**

Project-specific extensions should ONLY be created if Framework doesn't provide the needed functionality and the extension is truly domain-specific.

**When to Create Project-Specific Extensions:**
- ‚úÖ Domain-specific business logic that cannot be generalized
- ‚úÖ Project-specific data transformations not available in Framework
- ‚úÖ Custom validation logic specific to the project

**When NOT to Create Project-Specific Extensions:**
- ‚ùå If Framework already provides similar functionality
- ‚ùå For general-purpose utilities (use Framework extensions)
- ‚ùå For operations that could be in Services or Helpers

**Format:**
```csharp
// Project/Extensions/CustomExtensions.cs
namespace <ProjectName>.Extensions;

public static class CustomExtensions {
    // Only create if domain-specific need
    public static string NormalizeValue(this string val) => 
        val.RemoveAllWhitespace().ToLowerInvariant();
    
    // Domain-specific business logic extension
    public static bool IsValidBusinessRule(this string value) {
        // Project-specific validation logic
        return /* validation */;
    }
}
```

**Location:**
- `Extensions/<ExtensionName>Extensions.cs` - One extension class per file

**Namespace:**
- `<ProjectName>.Extensions`

### 16.4 Extensions Rules - Folder Structure & Naming

**Framework Extensions:**
- **Location:** Framework Core (not in project)
- **Namespace:** `Core.Extensions`
- **Access:** Via `using Core.Extensions;`

**Project-Specific Extensions:**
- **Location:** `Extensions/<ExtensionName>Extensions.cs`
- **Namespace:** `<ProjectName>.Extensions`
- **Naming:** `<Purpose>Extensions` (e.g., `CustomExtensions`, `BusinessExtensions`)

**File Structure:**
```
<ProjectName>/
‚îú‚îÄ‚îÄ Extensions/                    # Project-specific extensions (optional)
‚îÇ   ‚îî‚îÄ‚îÄ <ExtensionName>Extensions.cs
```

### 16.5 Extensions Rules - Key Rules

| Extension | Source | Usage | Mandatory |
|-----------|--------|-------|-----------|
| **LoggerExtensions** | Framework Core | `_logger.Info()`, `_logger.Error()`, `_logger.Warn()`, `_logger.Debug()` | ‚úÖ **MANDATORY** - Never use ILogger directly |
| **HttpRequestExtensions** | Framework Core | `await req.ReadBodyAsync<T>()` | ‚úÖ **MANDATORY** - Must use for request body reading |
| **HttpResponseExtensions** | Framework Core | `await response.ExtractDataAsync()`, `response.ExtractBaseResponse()` | ‚úÖ **MANDATORY** - Must use for response extraction |
| **StringExtensions** | Framework Core | `RemoveAllWhitespace()`, `IsValidEmail()` | ‚úÖ **MANDATORY** - Use Framework version |
| **DictionaryExtensions** | Framework Core | `ToIntValue()`, `ToStringValue()`, `ToDateTimeValue()` | ‚úÖ **MANDATORY** - Use Framework version |
| **EnumExtensions** | Framework Core | `GetStringValue()` | ‚úÖ **MANDATORY** - Use Framework version |
| **CustomHttpClientExtensions** | Framework Core | `SendProcessHTTPReqAsync()` | ‚úÖ **MANDATORY** - Must use for HTTP calls |
| **Project Extensions** | Project/Extensions/ | Domain-specific extensions | ‚ö†Ô∏è **OPTIONAL** - Only if domain-specific need |

**üî¥ CRITICAL RULES:**

1. ‚úÖ **ALWAYS use Framework extensions** - Never use direct API calls when Framework extensions are available
2. ‚úÖ **ALWAYS add `using Core.Extensions;`** - Required for all Framework extensions
3. ‚úÖ **NEVER use ILogger directly** - Always use `Info()`, `Error()`, `Warn()`, `Debug()` extension methods
4. ‚úÖ **NEVER manually read request body** - Always use `ReadBodyAsync<T>()` extension method
5. ‚úÖ **NEVER manually extract response data** - Always use `ExtractDataAsync()` and `ExtractBaseResponse()` extension methods
6. ‚úÖ **NEVER create custom extensions for Framework functionality** - Use Framework extensions instead
7. ‚úÖ **Project-specific extensions are OPTIONAL** - Only create if Framework doesn't provide the functionality and it's domain-specific
8. ‚úÖ **ALWAYS use `SendProcessHTTPReqAsync()`** - For all Process‚ÜíSystem and Process‚ÜíProcess HTTP calls

### 16.6 Extensions Rules - Post-Creation Validation

**üõë POST-CREATION VALIDATION (MANDATORY - VERIFY BEFORE PROCEEDING)**

**üö® AFTER using Extensions, you MUST verify:**

**Framework Extensions Validation:**
1. ‚úÖ **STOP AND VERIFY:** File has `using Core.Extensions;` statement
2. ‚úÖ **STOP AND VERIFY:** Using `_logger.Info()`, `_logger.Error()`, etc. (NOT `LogInformation()`, `LogError()`)
3. ‚úÖ **STOP AND VERIFY:** Using `await req.ReadBodyAsync<T>()` for request body reading
4. ‚úÖ **STOP AND VERIFY:** Using `await response.ExtractDataAsync()` and `response.ExtractBaseResponse()` for response handling
5. ‚úÖ **STOP AND VERIFY:** Using `SendProcessHTTPReqAsync()` for HTTP calls (NOT direct HttpClient calls)
6. ‚úÖ **STOP AND VERIFY:** Using Framework StringExtensions, DictionaryExtensions, EnumExtensions (NOT custom versions)

**Project-Specific Extensions Validation (if created):**
7. ‚úÖ **STOP AND VERIFY:** Extension is truly domain-specific and not available in Framework
8. ‚úÖ **STOP AND VERIFY:** Extension file is in `Extensions/` folder with correct naming
9. ‚úÖ **STOP AND VERIFY:** Extension uses correct namespace (`<ProjectName>.Extensions`)
10. ‚úÖ **STOP AND VERIFY:** Extension follows Framework extension patterns (static class, extension methods)

**üõë IF ANY VIOLATION ‚Üí STOP ‚Üí Fix Extensions ‚Üí Then proceed**

### 16.7 Extensions Rules - Common Mistakes

**‚ùå Not Using Framework Extensions**

- **WRONG:** Using `_logger.LogInformation()` instead of `_logger.Info()`
- **WRONG:** Manual JSON deserialization instead of `await req.ReadBodyAsync<T>()`
- **WRONG:** Manual response parsing instead of `await response.ExtractDataAsync()`
- **WRONG:** Direct HttpClient calls instead of `SendProcessHTTPReqAsync()`
- **CORRECT:** Always use Framework extension methods
- **Why:** Framework extensions provide consistent behavior, error handling, and automatic header management.

**‚ùå Missing Using Statement**

- **WRONG:** Using extension methods without `using Core.Extensions;`
- **CORRECT:** Add `using Core.Extensions;` at the top of the file
- **Why:** Extension methods require the namespace to be imported.

**‚ùå Creating Custom Extensions for Framework Functionality**

- **WRONG:** Creating custom `ReadBodyAsync()` method when Framework provides it
- **WRONG:** Creating custom logging extensions when Framework provides LoggerExtensions
- **CORRECT:** Use Framework extensions, don't create custom versions
- **Why:** Framework extensions are tested, maintained, and provide consistent behavior across projects.

**‚ùå Creating Project Extensions for General-Purpose Operations**

- **WRONG:** Creating project extension for general string operations (Framework provides StringExtensions)
- **WRONG:** Creating project extension for dictionary operations (Framework provides DictionaryExtensions)
- **CORRECT:** Only create project extensions for truly domain-specific operations
- **Why:** General-purpose operations should use Framework extensions for consistency and maintainability.

**‚ùå Not Using SendProcessHTTPReqAsync() for HTTP Calls**

- **WRONG:** Direct HttpClient calls without extension method
- **WRONG:** Manually adding TestRunId/RequestId headers (extension method does this automatically)
- **CORRECT:** Always use `SendProcessHTTPReqAsync()` extension method
- **Why:** Extension method automatically adds technical headers, handles JSON serialization, and provides consistent error handling.

**‚ùå Using Direct ILogger Methods**

- **WRONG:** `_logger.LogInformation("message")` - Direct ILogger method
- **WRONG:** `_logger.LogError(ex, "message")` - Direct ILogger method
- **CORRECT:** `_logger.Info("message")` - Extension method
- **CORRECT:** `_logger.Error(ex, "message")` - Extension method
- **Why:** Framework LoggerExtensions provide standardized logging format and behavior.

---

## 17. Helper Rules

**üö® CRITICAL:** ResponseDTOHelper is mandatory for ALL Process Layers. Additional helpers are optional and project-specific. Helpers provide reusable utility methods for common operations.

### 17.1 Helper Rules - Pre-Creation Validation

**üõë PRE-CREATION VALIDATION (MANDATORY - STOP IF NOT COMPLETE)**

**üö® BEFORE creating any Helper (except ResponseDTOHelper), you MUST verify:**

1. ‚úÖ **STOP AND VERIFY:** Have I read this section completely?
2. ‚úÖ **STOP AND VERIFY:** Have I verified this helper is actually needed (not just convenient)?
3. ‚úÖ **STOP AND VERIFY:** Have I checked if Framework/Core already provides this functionality?
4. ‚úÖ **STOP AND VERIFY:** Have I checked if Extensions already provide this functionality?
5. ‚úÖ **STOP AND VERIFY:** Is this truly a reusable utility that belongs in a helper (not business logic that belongs in a Service)?
6. ‚úÖ **STOP AND VERIFY:** If email-related ‚Üí Have I read Section 17.4 (Email Template Helpers)?
7. ‚úÖ **STOP AND VERIFY:** Do I understand that ResponseDTOHelper is mandatory (see Section 12), but other helpers are optional?

**üõë IF ANY MISSING ‚Üí STOP ‚Üí Complete verification ‚Üí Then create Helper**

**Note:** ResponseDTOHelper is MANDATORY and covered in Section 12. This section covers additional/optional helpers.

### 17.2 Helper Rules - Mandatory Helpers

**üî¥ CRITICAL: ResponseDTOHelper is MANDATORY**

**ResponseDTOHelper.cs** - ALL Process Layers MUST have this helper.

**Location:** `Helper/ResponseDTOHelper.cs`

**Purpose:** Standardized JSON‚ÜíDTO mapping for all System Layer and Process Layer responses.

**Structure:**
```csharp
public static class ResponseDTOHelper {
    // All methods are public static
    public static <Entity>ResDTO PopulateEntity(string json, <Entity>ResDTO dto) { /* ... */ }
    public static ReferenceResDTO PopulateReference(string json) { /* ... */ }
    // ... other Populate methods
}
```

**Key Requirements:**
- ‚úÖ **MANDATORY:** ResponseDTOHelper MUST exist in ALL Process Layers
- ‚úÖ **Location:** `Helper/ResponseDTOHelper.cs` (exact location)
- ‚úÖ **Class:** `public static class ResponseDTOHelper`
- ‚úÖ **Methods:** All methods MUST be `public static`
- ‚úÖ **Purpose:** Standardized JSON‚ÜíDTO mapping for all System Layer and Process Layer responses

**üî¥ CROSS-REFERENCE:** See Section 12 (Response DTO Helper Rules) for complete details on ResponseDTOHelper patterns, usage, and implementation.

### 17.3 Helper Rules - Additional Helper Classes (Optional)

**‚ö†Ô∏è OPTIONAL: Project-Specific Helpers**

Additional helper classes are optional and project-specific. Only create if truly needed and not available in Framework or Extensions.

**When to Create Additional Helpers:**
- ‚úÖ Reusable utility methods that don't belong in Services (no business logic)
- ‚úÖ Common operations used across multiple Functions/Services
- ‚úÖ File/PDF processing, document manipulation
- ‚úÖ Type conversion utilities not available in Framework
- ‚úÖ Format transformers
- ‚úÖ Error message formatting, localization helpers
- ‚úÖ Email template reading (see Section 17.4)

**When NOT to Create Additional Helpers:**
- ‚ùå If Framework Extensions already provide the functionality
- ‚ùå If the logic belongs in a Service (business logic)
- ‚ùå If it's a one-time operation (not reusable)
- ‚ùå If it's just convenient (not truly needed)

**Location:** `Helper/<HelperName>Helper.cs` or `Helper/<HelperName>.cs`

**Namespace:** `<ProjectName>.Helper`

**Pattern:**
```csharp
namespace <ProjectName>.Helper;

public static class CustomHelper {
    // All methods MUST be public static
    public static string ProcessData(string input) { 
        /* Helper logic - no business logic */
    }
    
    public static T ConvertValue<T>(object value) { 
        /* Conversion logic */
    }
    
    // File/PDF processing example
    public static byte[] GeneratePDF(string content) {
        /* PDF generation logic */
    }
}
```

**Key Rules:**
- ‚úÖ **All methods MUST be `public static`** - Helpers are stateless utility classes
- ‚úÖ **No business logic** - Business logic belongs in Services, not Helpers
- ‚úÖ **Reusable operations only** - Helpers should contain operations used multiple times
- ‚úÖ **One helper class per file** - Standard C# convention

**File Structure:**
```
<ProjectName>/
‚îú‚îÄ‚îÄ Helper/
‚îÇ   ‚îú‚îÄ‚îÄ ResponseDTOHelper.cs        # MANDATORY
‚îÇ   ‚îú‚îÄ‚îÄ EmailTemplateHelper.cs      # Optional (if email templates needed)
‚îÇ   ‚îú‚îÄ‚îÄ PDFHelper.cs                # Optional (if PDF generation needed)
‚îÇ   ‚îî‚îÄ‚îÄ <CustomHelper>.cs           # Optional (project-specific)
```

### 17.4 Helper Rules - Email Template Helpers

**üî¥ MANDATORY: If you are implementing email functionality, you MUST read this section BEFORE writing any email code.**

**üõë BEFORE implementing email body generation (MANDATORY - STOP IF NOT COMPLETE):**

1. ‚úÖ **STOP AND VERIFY:** Have I read this section completely?
2. ‚úÖ **STOP AND VERIFY:** Have I read Phase 1 Section 9 (Subprocess Analysis) to identify email subprocess?
3. ‚úÖ **STOP AND VERIFY:** Have I located the Boomi subprocess JSON file (subprocess_*.json) for the email subprocess?
4. ‚úÖ **STOP AND VERIFY:** Have I searched the subprocess JSON for email template (look for "msgTxt" in message shapes or "MailBody" in documentproperties shapes)?
5. ‚úÖ **STOP AND VERIFY:** Have I extracted the EXACT email template HTML from Boomi subprocess JSON (including DOCTYPE, html, head, body tags, all whitespace)?
6. ‚úÖ **STOP AND VERIFY:** Have I verified placeholder numbering from msgParameters section (e.g., {1}, {2}, {3}, {4})?
7. ‚úÖ **STOP AND VERIFY:** Have I verified placeholder order matches msgParameters key order (check key values and their corresponding process properties)?
8. ‚úÖ **STOP AND VERIFY:** Have I verified I'm NOT hardcoding email HTML in Function code?
9. ‚úÖ **STOP AND VERIFY:** Do I understand that email templates MUST be embedded resources?
10. ‚úÖ **STOP AND VERIFY:** Have I checked "COMMON MISTAKES" #31 (Hardcoded Configuration Values)?
11. ‚úÖ **STOP AND VERIFY:** Do I understand that email addresses come from AppConfigs (see Section 13)?

**üõë IF ANY CHECKPOINT FAILS ‚Üí STOP ‚Üí Complete missing step ‚Üí Then implement email templates**

**üî¥ CRITICAL: Email Template Extraction from Boomi Subprocess JSON (MANDATORY)**

**Email Template Extraction Process:**

1. **Locate Email Subprocess:** From Phase 1 Section 9, identify the email subprocess ID (e.g., `a85945c5-3004-42b9-80b1-104f465cd1fb`)
2. **Find Subprocess JSON:** Locate `subprocess_<subprocess-id>.json` file
3. **Search for Template:** Search for `"msgTxt"` in message shapes or `"MailBody"` in documentproperties shapes
4. **Extract Template:** Copy the EXACT HTML from the `"_"` field in msgTxt (including all tags, whitespace, placeholders)
5. **Verify Placeholders:** Check msgParameters section to verify placeholder numbering (e.g., {1}, {2}, {3}, {4}) and their corresponding process properties
6. **Create Template File:** Create `EmailTemplate/<TemplateName>.html` with EXACT content from Boomi subprocess JSON
7. **Verify Match:** Compare template file line-by-line with Boomi subprocess JSON to ensure EXACT match

**Placeholder Population:**

- Placeholder order in `string.Format()` MUST match Boomi subprocess msgParameters key order
- Example: If Boomi msgParameters shows {1}=ProcessName, {2}=Environment, {3}=ExecutionID, {4}=ErrorMessage
  - ‚úÖ CORRECT: `string.Format(template, processName, environment, executionId, errorMessage)`
  - ‚ùå WRONG: `string.Format(template, environment, executionId, errorMessage)` (missing processName, wrong order)

**Pattern:** Helper classes may read embedded email templates for email generation.

**Template Location:** `EmailTemplate/<TemplateName>.html`

**Template Configuration (.csproj):**
```xml
<ItemGroup>
  <EmbeddedResource Include="EmailTemplate\TemplateName.html" />
</ItemGroup>
```

**Helper Method Pattern:**
```csharp
public static class ResponseDTOHelper {
    // Can add email template reading to ResponseDTOHelper or create separate EmailTemplateHelper
    public static string ReadEmailTemplate(string resourceName) {
        Assembly assembly = Assembly.GetExecutingAssembly();
        using Stream? stream = assembly.GetManifestResourceStream(resourceName);
        if (stream == null)
        {
            throw new FileNotFoundException($"Template {resourceName} not found");
        }
        using StreamReader reader = new StreamReader(stream);
        return reader.ReadToEnd();
    }
    
    // Usage
    string templateContent = ReadEmailTemplate("<ProjectName>.EmailTemplate.<TemplateName>.html");
}
```

**Key Rules:**
- ‚úÖ **Templates MUST be marked as `EmbeddedResource`** in .csproj
- ‚úÖ **Resource name format:** `<Namespace>.EmailTemplate.<FileName>.html`
- ‚úÖ **Helper methods should handle missing template errors gracefully** - Throw `FileNotFoundException` if template not found
- ‚úÖ **Email HTML MUST NOT be hardcoded** - Always use embedded templates
- ‚úÖ **Email addresses come from AppConfigs** - Never hardcode email addresses (see Section 13)
- ‚úÖ **üî¥ CRITICAL:** Email template HTML MUST be extracted EXACTLY from Boomi subprocess JSON file (subprocess_*.json) - locate in msgTxt section of message shapes
- ‚úÖ **üî¥ CRITICAL:** Email template placeholders MUST match Boomi subprocess placeholders EXACTLY (verify placeholder numbering and order from msgParameters section in subprocess JSON)
- ‚úÖ **üî¥ CRITICAL:** Placeholder population parameter order MUST match Boomi subprocess msgParameters key order (verify parameter order in string.Format matches msgParameters)

**üî¥ CRITICAL: Execution ID for Email Templates:**
- **MANDATORY:** Use `RequestHeaders.RequestId.Item2.Value?.ToString()` for Execution ID in email templates
- **DO NOT use:** `FunctionContext.InvocationId` or `Activity.Current?.Id` or `Guid.NewGuid()`
- **Pattern:** `string executionId = RequestHeaders.RequestId.Item2.Value?.ToString() ?? InfoConstants.DEFAULT_EXECUTION_ID;`
- **Reason:** Execution ID must come from the request header (`x-apim-correlation-id`) to maintain correlation across the entire request flow, matching Boomi's execution property behavior
- **Usage:** Replace placeholder `{3}` in email templates with `RequestHeaders.RequestId.Item2.Value?.ToString()`

**üî¥ CROSS-REFERENCES:**
- **Related:** See Section 12 (Response DTO Helper Rules) - ResponseDTOHelper can include email template reading methods
- **Related:** See Section 13 (Config Models Rules) - Email addresses come from AppConfigs, NOT hardcoded
- **Related:** See Section 2 (Azure Functions Rules) - Functions use helpers to read templates
- **Related:** See Section 14 (Constants Rules) - Use constants for default execution ID

### 17.5 Helper Rules - Folder Structure & Naming

**Location:**
- `Helper/ResponseDTOHelper.cs` - MANDATORY
- `Helper/<HelperName>Helper.cs` - Optional (additional helpers)

**Namespace:**
- `<ProjectName>.Helper`

**File Structure:**
```
<ProjectName>/
‚îú‚îÄ‚îÄ Helper/
‚îÇ   ‚îú‚îÄ‚îÄ ResponseDTOHelper.cs        # MANDATORY - Response mapping
‚îÇ   ‚îú‚îÄ‚îÄ EmailTemplateHelper.cs      # Optional - Email template reading
‚îÇ   ‚îî‚îÄ‚îÄ <CustomHelper>.cs           # Optional - Project-specific helpers
```

**Naming Conventions:**
- **File Name:** `<Purpose>Helper.cs` (e.g., `ResponseDTOHelper.cs`, `EmailTemplateHelper.cs`, `PDFHelper.cs`)
- **Class Name:** `<Purpose>Helper` (e.g., `ResponseDTOHelper`, `EmailTemplateHelper`, `PDFHelper`)
- **Methods:** `public static` methods with descriptive names (e.g., `ReadEmailTemplate()`, `GeneratePDF()`)

### 17.6 Helper Rules - Key Rules

| Component | Pattern | Mandatory |
|-----------|---------|-----------|
| **ResponseDTOHelper** | `Helper/ResponseDTOHelper.cs` | ‚úÖ **MANDATORY** - ALL Process Layers |
| **Additional Helpers** | `Helper/<HelperName>Helper.cs` | ‚ö†Ô∏è **OPTIONAL** - Only if needed |
| **Class Structure** | `public static class <HelperName>` | ‚úÖ Always |
| **Methods** | `public static` methods | ‚úÖ Always |
| **Business Logic** | ‚ùå NEVER in Helpers | ‚úÖ **CRITICAL** - Business logic belongs in Services |
| **Framework Extensions** | Use Framework extensions first | ‚úÖ Always - Check Framework before creating helpers |

**üî¥ CRITICAL RULES:**

1. ‚úÖ **ResponseDTOHelper is MANDATORY** - ALL Process Layers MUST have `Helper/ResponseDTOHelper.cs`
2. ‚úÖ **All helper methods MUST be `public static`** - Helpers are stateless utility classes
3. ‚úÖ **NO business logic in Helpers** - Business logic belongs in Services, not Helpers
4. ‚úÖ **Check Framework Extensions first** - Don't create helpers for functionality available in Framework
5. ‚úÖ **Helpers are for reusable utilities** - Only create if operation is used multiple times
6. ‚úÖ **Email templates MUST be embedded resources** - Never hardcode email HTML
7. ‚úÖ **Email addresses come from AppConfigs** - Never hardcode email addresses
8. ‚úÖ **Execution ID from RequestHeaders** - Use `RequestHeaders.RequestId.Item2.Value?.ToString()` for email templates

### 17.7 Helper Rules - Post-Creation Validation

**üõë POST-CREATION VALIDATION (MANDATORY - VERIFY BEFORE PROCEEDING)**

**üö® AFTER creating Helper, you MUST verify:**

**ResponseDTOHelper Validation:**
1. ‚úÖ **STOP AND VERIFY:** ResponseDTOHelper exists at `Helper/ResponseDTOHelper.cs`
2. ‚úÖ **STOP AND VERIFY:** ResponseDTOHelper class is `public static class ResponseDTOHelper`
3. ‚úÖ **STOP AND VERIFY:** All methods are `public static`
4. ‚úÖ **STOP AND VERIFY:** ResponseDTOHelper methods handle JSON‚ÜíDTO mapping correctly

**Additional Helpers Validation (if created):**
5. ‚úÖ **STOP AND VERIFY:** Helper is truly needed (not just convenient)
6. ‚úÖ **STOP AND VERIFY:** Framework doesn't already provide this functionality
7. ‚úÖ **STOP AND VERIFY:** Helper contains NO business logic (only utility methods)
8. ‚úÖ **STOP AND VERIFY:** All methods are `public static`
9. ‚úÖ **STOP AND VERIFY:** Helper file is in `Helper/` folder with correct naming

**Email Template Helpers Validation (if created):**
10. ‚úÖ **STOP AND VERIFY:** Email templates are marked as `EmbeddedResource` in .csproj
11. ‚úÖ **STOP AND VERIFY:** Resource name format is correct: `<Namespace>.EmailTemplate.<FileName>.html`
12. ‚úÖ **STOP AND VERIFY:** Helper method handles missing template errors gracefully
13. ‚úÖ **STOP AND VERIFY:** Execution ID uses `RequestHeaders.RequestId.Item2.Value?.ToString()`
14. ‚úÖ **STOP AND VERIFY:** Email addresses come from AppConfigs (NOT hardcoded)

**üõë IF ANY VIOLATION ‚Üí STOP ‚Üí Fix Helper ‚Üí Then proceed**

### 17.8 Helper Rules - Common Mistakes

**‚ùå Creating Helpers for Business Logic**

- **WRONG:** Putting business logic in Helper classes (e.g., validation, orchestration, decision-making)
- **CORRECT:** Business logic belongs in Services, Helpers are for stateless utility methods
- **Why:** Helpers should be pure utility functions. Business logic requires dependency injection and belongs in Services.

**‚ùå Creating Helpers When Framework Extensions Exist**

- **WRONG:** Creating custom string manipulation helper when Framework StringExtensions exists
- **WRONG:** Creating custom dictionary helper when Framework DictionaryExtensions exists
- **CORRECT:** Use Framework Extensions first, only create helpers if Framework doesn't provide the functionality
- **Why:** Framework extensions are tested, maintained, and provide consistent behavior across projects.

**‚ùå Hardcoding Email HTML**

- **WRONG:** Hardcoding email HTML in Function code: `string emailBody = $"<html><body>Error: {message}</body></html>";`
- **CORRECT:** Use embedded email templates and helper methods to read them
- **Why:** Email templates should be maintainable, reusable, and match Boomi template structure exactly.

**‚ùå Hardcoding Email Addresses**

- **WRONG:** Hardcoding email addresses in Helper methods or Function code
- **CORRECT:** Email addresses come from AppConfigs (see Section 13)
- **Why:** Email addresses are configuration values that differ per environment. They must be in AppConfigs.

**‚ùå Using Wrong Execution ID Source**

- **WRONG:** Using `FunctionContext.InvocationId` or `Guid.NewGuid()` for Execution ID in email templates
- **CORRECT:** Use `RequestHeaders.RequestId.Item2.Value?.ToString()` for Execution ID
- **Why:** Execution ID must come from request header to maintain correlation across the entire request flow, matching Boomi's execution property behavior.

**‚ùå Not Making Helper Methods Static**

- **WRONG:** Creating instance methods in Helper classes
- **CORRECT:** All helper methods MUST be `public static`
- **Why:** Helpers are stateless utility classes. Static methods don't require instantiation and are more efficient.

**‚ùå Missing ResponseDTOHelper**

- **WRONG:** Not creating ResponseDTOHelper or putting response mapping logic in Functions
- **CORRECT:** ResponseDTOHelper is MANDATORY - ALL Process Layers MUST have it
- **Why:** ResponseDTOHelper provides standardized JSON‚ÜíDTO mapping. All response mapping logic MUST be in ResponseDTOHelper, not in Functions.

**‚ùå Creating Unnecessary Helpers**

- **WRONG:** Creating helpers for one-time operations or just for convenience
- **CORRECT:** Only create helpers for truly reusable operations used multiple times
- **Why:** Unnecessary helpers add complexity and maintenance overhead. Keep code simple and only create helpers when truly needed.

---

## 18. Program.cs Rules

**üö® CRITICAL:** Program.cs handles dependency injection (DI) registration, configuration loading, and middleware setup. DI registration order is mandatory. System/Process Abstractions MUST be registered with interfaces.

### 18.1 Program.cs Rules - Pre-Creation Validation

**üõë PRE-CREATION VALIDATION (MANDATORY - STOP IF NOT COMPLETE)**

**üö® YOU CANNOT CREATE/MODIFY Program.cs UNTIL:**

1. ‚úÖ **STOP AND VERIFY:** Have I created all System Abstractions?
2. ‚úÖ **STOP AND VERIFY:** Have I created all Process Abstractions (if needed)?
3. ‚úÖ **STOP AND VERIFY:** Have I created all Services (if needed)?
4. ‚úÖ **STOP AND VERIFY:** Have I created AppConfigs?
5. ‚úÖ **STOP AND VERIFY:** Have I read this section completely?
6. ‚úÖ **STOP AND VERIFY:** Do I understand the DI registration order?
7. ‚úÖ **STOP AND VERIFY:** Do I understand that System/Process Abstractions MUST be registered with interfaces?

**üõë IF ANY MISSING ‚Üí STOP ‚Üí Complete missing components ‚Üí Then create/modify Program.cs**

### 18.2 Program.cs Rules - Critical Principles

**üö® CRITICAL PRINCIPLES:**

1. **DI registration order is mandatory** - Components must be registered in the correct order
2. **System/Process Abstractions: ALWAYS register and inject via interface**
   - ‚úÖ `builder.Services.AddScoped<IEntityMgmt, EntityMgmtSys>()`
   - ‚ùå `builder.Services.AddScoped<EntityMgmtSys>()` - WRONG
   - ‚úÖ `private readonly IEntityMgmt _entityMgmt` - CORRECT
   - ‚ùå `private readonly EntityMgmtSys _entityMgmt` - WRONG
3. **Services: Can be registered with or without interface**
   - ‚úÖ `builder.Services.AddScoped<EntityService>()` (direct injection)
   - ‚úÖ `builder.Services.AddScoped<IEntityService, EntityService>()` (with interface)
   - ‚úÖ `private readonly EntityService _service` (direct injection)
   - ‚úÖ `private readonly IEntityService _service` (interface injection)
4. **CALL FLOW MANDATORY PATTERN:**
   - Functions ‚Üí Service (inject directly OR via interface)
   - Service ‚Üí System Abstraction (via interface: `IEntityMgmt`) OR Process Abstraction (via interface: `IEntityProc`)
   - System/Process Abstraction ‚Üí System Layer OR Process Layer (HTTP calls)
5. **üî¥ CRITICAL: Process Layer Program.cs MUST NOT register System Layer services/handlers** - ONLY System Abstractions

### 18.3 Program.cs Rules - Registration Order (Standard Process Layer)

**üî¥ CRITICAL:** Process Layer Program.cs MUST NOT register System Layer services/handlers. ONLY System Abstractions.

**Complete Registration Order:**
```csharp
FunctionsHostBuilder builder = FunctionsApplication.CreateBuilder(args);

// 1. HTTP Client (FIRST)
builder.Services.AddHttpClient<CustomHTTPClient>();

// 2. Environment & Configuration Loading
string environment = Environment.GetEnvironmentVariable("ENVIRONMENT") 
    ?? Environment.GetEnvironmentVariable("ASPNETCORE_ENVIRONMENT") 
    ?? InfoConstants.DEFAULT_ENVIRONMENT;
builder.Configuration
    .AddJsonFile("appsettings.json", optional: true, reloadOnChange: true)
    .AddJsonFile($"appsettings.{environment}.json", optional: true, reloadOnChange: true)
    .AddEnvironmentVariables();

// 3. Application Insights & Logging
builder.Services.AddApplicationInsightsTelemetryWorkerService().ConfigureFunctionsApplicationInsights();
builder.Logging.AddConsole();
builder.Logging.AddFilter<ApplicationInsightsLoggerProvider>("", LogLevel.Information);

// 4. Configuration Binding
builder.Services.Configure<AppConfigs>(builder.Configuration.GetSection(AppConfigs.SectionName));

// 5. Domains - NOT registered (no constructor dependencies, simple POCOs)
// Domains are instantiated directly: EntityDomain domain = new EntityDomain();

// 6. Redis Caching
builder.Services.AddRedisCacheLibrary(builder.Configuration);

// 7. System Abstractions (AddScoped OR AddCachedService for caching)
// ‚úÖ ALWAYS register with interface
// üî¥ CRITICAL: ONLY System Abstractions here. NEVER System Layer services/handlers.
builder.Services.AddScoped<IEntityMgmt, EntityMgmtSys>();  // Without caching
builder.Services.AddCachedService<IDataMgmt, DataMgmtSys>();  // With caching

// ‚ùå NEVER DO THIS (System Layer components):
// builder.Services.AddScoped<ISystemLayerService, SystemLayerService>();  // ‚ùå WRONG
// builder.Services.AddScoped<SystemLayerHandler>();  // ‚ùå WRONG

// 8. Process Abstractions (AddScoped)
// ‚úÖ ALWAYS register with interface
builder.Services.AddScoped<IAuthProc, AuthProc>();

// 9. Services (AddScoped OR AddTransient)
// ‚úÖ Can register with or without interface
builder.Services.AddScoped<EntityService>();  // Direct injection (no interface)
// OR
builder.Services.AddScoped<IEntityService, EntityService>();  // With interface (if interface exists)
builder.Services.AddTransient<DataService>();

// 10. CustomHTTPClient (AddScoped - Framework/Core/Core/Middlewares/CustomHTTPClient.cs)
builder.Services.AddScoped<CustomHTTPClient>();  // HTTP client with hardcoded 50s timeout

// 11. Polly Policies (Singleton) - OPTIONAL
builder.Services.AddSingleton<IAsyncPolicy<HttpResponseMessage>>(sp => {
    IConfiguration config = sp.GetRequiredService<IConfiguration>();
    IAsyncPolicy<HttpResponseMessage> retryPolicy = Policy
        .Handle<HttpRequestException>()
        .OrResult<HttpResponseMessage>(r => (int)r.StatusCode >= 500)
        .WaitAndRetryAsync(
            retryCount: config.GetValue<int>("HttpClientPolicy:RetryCount"), 
            sleepDurationProvider: retryAttempt => TimeSpan.FromSeconds(retryAttempt * 5));
    IAsyncPolicy<HttpResponseMessage> timeoutPolicy = Policy
        .TimeoutAsync<HttpResponseMessage>(config.GetValue<int>("HttpClientPolicy:TimeoutSeconds"));
    return Policy.WrapAsync(retryPolicy, timeoutPolicy);
});

// 12. Configure Functions Web Application
builder.ConfigureFunctionsWebApplication();

// 13. Middleware Registration (STRICT ORDER - Non-Negotiable)
builder.UseMiddleware<ExecutionTimingMiddleware>();    // 1. FIRST - timing
builder.UseMiddleware<ExceptionHandlerMiddleware>();   // 2. SECOND - exception handling
// ‚ùå NO CustomAuthenticationMiddleware - System Layer concept

// 14. ServiceLocator (For nested domain object resolution)
ServiceLocator.ServiceProvider = builder.Services.BuildServiceProvider();

builder.Build().Run();
```

### 18.4 Program.cs Rules - Central Data Layer Registration

**üî¥ CRITICAL: Central Data Layer (Shared Services) Registration Pattern**

Central Data Layer has additional registrations for database access, repositories, AutoMapper, and KeyVault.

**Additional Registrations (after steps 1-4 from Standard Process Layer):**

```csharp
// 5. Configuration Binding (Multiple configs)
builder.Services.Configure<AppConfigs>(builder.Configuration.GetSection(AppConfigs.SectionName));
builder.Services.Configure<JwtOptions>(builder.Configuration.GetSection(JwtOptions.SectionName));
builder.Services.AddOptions<KeyVaultConfigs>().Bind(builder.Configuration.GetSection(KeyVaultConfigs.SectionName));

// 6. NO Domains registration (POCOs)

// 7. System Abstractions
builder.Services.AddScoped<IExternalMgmt, ExternalMgmtSys>();

// 8. Services
builder.Services.AddScoped<ISecurityService, SecurityService>();
builder.Services.AddScoped<IAuthService, AuthService>();
builder.Services.AddScoped<IReferenceService, ReferenceService>();

// 9. Repositories
builder.Services.AddScoped<ISecuritySettingsRepository, SecuritySettingsRepository>();
builder.Services.AddScoped<IAuthSettingsRepository, AuthSettingsRepository>();
builder.Services.AddScoped<IReferenceDataRepository, ReferenceDataRepository>();

// 10. AutoMapper (with configuration)
builder.Services.AddAutoMapper(cfg => { cfg.AllowNullCollections = false; }, typeof(EntityMapping).Assembly);

// 11. CustomHTTPClient
builder.Services.AddScoped<CustomHTTPClient>();

// 12. KeyVault (Singleton)
builder.Services.AddSingleton<KeyVaultReader>();
builder.Services.AddSingleton<DatabaseConnectionStringProvider>();

// 13. DbContext (with KeyVault secret retrieval)
builder.Services.AddDbContext<AppDbContext>((serviceProvider, options) => {
    DatabaseConnectionStringProvider connProvider = serviceProvider.GetRequiredService<DatabaseConnectionStringProvider>();
    if (string.IsNullOrWhiteSpace(connProvider.ConnectionString)) {
        KeyVaultReader kvReader = serviceProvider.GetRequiredService<KeyVaultReader>();
        KeyVaultSecretResponse secret = kvReader.GetSecretAsync(KeyVaultConfigs.DB_CONNECTION_STRING_KEY).GetAwaiter().GetResult();
        if (!secret.IsSuccess) throw new Exception("Failed to get DB connection string from Key Vault");
        connProvider.ConnectionString = secret.Secret;
    }
    options.UseSqlServer(connProvider.ConnectionString);
});

// 14. Redis Caching
builder.Services.AddRedisCacheLibrary(builder.Configuration);

// 15. Polly Policies (same as standard)
// 16. ConfigureFunctionsWebApplication(), Middleware, ServiceLocator, Build().Run()
```

### 18.5 Program.cs Rules - Critical Patterns Explained

**üö® IMPORTANT:** These patterns are documented with precise implementation details. Follow these patterns EXACTLY as shown.

**A. Environment Variable Loading:**
```csharp
string environment = Environment.GetEnvironmentVariable("ENVIRONMENT") 
    ?? Environment.GetEnvironmentVariable("ASPNETCORE_ENVIRONMENT") 
    ?? InfoConstants.DEFAULT_ENVIRONMENT;
```
**Purpose:** Prioritizes ENVIRONMENT, falls back to ASPNETCORE_ENVIRONMENT, defaults to constant from InfoConstants

**B. AddCachedService (Extension Method from Framework/Cache):**
```csharp
builder.Services.AddCachedService<IEntityMgmt, EntityMgmtSys>();  // With caching interceptor
builder.Services.AddScoped<IEntityMgmt, EntityMgmtSys>();  // Without caching
```
**Source:** Framework/Cache/Extensions/CachingExtensions.cs  
**Purpose:** Extension method that registers service with Castle DynamicProxy caching interceptor for methods decorated with `[CacheableService]` attribute  
**How It Works:** 
1. Creates instance of implementation (e.g., EntityMgmtSys)
2. Wraps it with CachingInterceptor (uses Castle DynamicProxy)
3. Intercepts methods with `[CacheableService]` attribute
4. Caches `HttpResponseSnapshot` results based on ICacheable domain's cache key
5. Returns cached response for subsequent calls with same cache key

**C. Domain Instantiation (NOT Registered in DI):**
```csharp
// ‚ùå WRONG - Do NOT register domains in DI
builder.Services.AddTransient<EntityDomain>();
builder.Services.AddScoped<EntityDomain>();

// ‚úÖ CORRECT - Instantiate directly when needed
EntityDomain domain = new EntityDomain();
dto.Populate(domain);
```
**Rule:** Domains are NOT registered in DI because they have NO constructor dependencies. They are simple POCOs instantiated directly.

**D. ServiceLocator Pattern:**
```csharp
ServiceLocator.ServiceProvider = builder.Services.BuildServiceProvider();
```
**Purpose:** Enables nested domain object resolution in DTO.Populate() methods using `ServiceLocator.ServiceProvider.GetService<T>()`

**E. Polly Retry/Timeout Policies (OPTIONAL - Default: NO Retries):**
```csharp
builder.Services.AddSingleton<IAsyncPolicy<HttpResponseMessage>>(sp => {
    IConfiguration config = sp.GetRequiredService<IConfiguration>();
    IAsyncPolicy<HttpResponseMessage> retryPolicy = Policy
        .Handle<HttpRequestException>()
        .OrResult<HttpResponseMessage>(r => (int)r.StatusCode >= 500)
        .WaitAndRetryAsync(
            retryCount: config.GetValue<int>("HttpClientPolicy:RetryCount"), 
            sleepDurationProvider: retryAttempt => TimeSpan.FromSeconds(retryAttempt * 5));
    IAsyncPolicy<HttpResponseMessage> timeoutPolicy = Policy
        .TimeoutAsync<HttpResponseMessage>(config.GetValue<int>("HttpClientPolicy:TimeoutSeconds"));
    return Policy.WrapAsync(retryPolicy, timeoutPolicy);
});
```
**‚ö†Ô∏è CRITICAL DEFAULTS:** 
- **RetryCount:** 0 (NO retries by default - set explicitly if retries needed)
- **TimeoutSeconds (HTTP Client):** 50 seconds - **HARDCODED** in `Framework/Core/Core/Middlewares/CustomHTTPClient.cs`
- **TimeoutSeconds (Polly Policy):** Configured in appsettings.json (typically 60 seconds)
- **IMPORTANT:** HTTP client timeout (50s) and Polly timeout (60s) are SEPARATE layers - Polly wraps the HTTP client
- **Only add HttpClientPolicy config** in appsettings.json if you need retries or different Polly timeout

**Configuration (appsettings.json):**
```json
{
  "HttpClientPolicy": {
    "RetryCount": 0,
    "TimeoutSeconds": 60
  }
}
```
**Note:** 
- HttpClientPolicy config is typically present in appsettings with RetryCount: 0
- Only increase RetryCount if specifically required for the integration
- TimeoutSeconds in config is for Polly policy timeout (separate from CustomHTTPClient's hardcoded 50s timeout)

### 18.6 Program.cs Rules - Key Rules

| Order | Component | Lifetime | Standard Process Layer | Central Data Layer |
|-------|-----------|----------|------------------------|-------------------|
| 1 | HTTP Client | N/A | ‚úÖ AddHttpClient | ‚úÖ AddHttpClient |
| 2 | Environment & Config Loading | N/A | ‚úÖ | ‚úÖ |
| 3 | Application Insights | N/A | ‚úÖ | ‚úÖ |
| 4 | Configuration Binding | N/A | ‚úÖ Configure<AppConfigs> | ‚úÖ Multiple Configure |
| 5 | Domains | N/A | ‚ùå NOT registered | ‚ùå NOT registered |
| 6 | Redis Caching | N/A | ‚úÖ AddRedisCacheLibrary | ‚úÖ (after KeyVault) |
| 7 | System Abstractions | Scoped/Cached | ‚úÖ AddScoped/AddCachedService | ‚úÖ AddScoped |
| 8 | Process Abstractions | Scoped | ‚ö†Ô∏è Optional | ‚ö†Ô∏è Optional |
| 9 | Services | Scoped/Transient | ‚ö†Ô∏è Optional | ‚úÖ |
| 10 | CustomHTTPClient | Scoped | ‚úÖ | ‚úÖ |
| 11 | Polly Policies | Singleton | ‚úÖ Optional | ‚úÖ Optional |
| 12 | Repositories | Scoped | ‚ùå | ‚úÖ |
| 13 | AutoMapper | Singleton | ‚ùå | ‚úÖ |
| 14 | KeyVault | Singleton | ‚ùå | ‚úÖ |
| 15 | DbContext | Scoped | ‚ùå | ‚úÖ |
| 16 | ConfigureFunctionsWebApplication | N/A | ‚úÖ | ‚úÖ |
| 17 | Middleware Registration | N/A | ‚úÖ (2 only) | ‚úÖ (2 only) |
| 18 | ServiceLocator | N/A | ‚úÖ | ‚úÖ |

**üî¥ CRITICAL RULES:**

1. ‚úÖ **DI registration order is mandatory** - Components must be registered in the exact order shown
2. ‚úÖ **System/Process Abstractions MUST be registered with interface** - Always use `AddScoped<IAbstraction, AbstractionImpl>()`
3. ‚úÖ **Services can be registered with or without interface** - Both patterns are valid
4. ‚úÖ **Domains are NOT registered in DI** - Instantiate directly: `EntityDomain domain = new EntityDomain();`
5. ‚úÖ **Process Layer Program.cs MUST NOT register System Layer services/handlers** - ONLY System Abstractions
6. ‚úÖ **Middleware order is non-negotiable** - ExecutionTimingMiddleware FIRST, ExceptionHandlerMiddleware SECOND
7. ‚úÖ **ServiceLocator MUST be set** - Required for nested domain object resolution in DTO.Populate()
8. ‚úÖ **Use constants for default environment** - Use `InfoConstants.DEFAULT_ENVIRONMENT` instead of hardcoded "dev"

### 18.7 Program.cs Rules - Update Checklist for New Operations

**üî¥ MANDATORY: When adding a new operation, you MUST update Program.cs:**

**Registration Checklist:**
1. ‚úÖ **Domain:** `builder.Services.AddTransient<<Entity>>();`
   - **When:** Always register Domain (even if simple POCO)
   - **Lifetime:** `AddTransient` (new instance per request)
   - **Example:** `builder.Services.AddTransient<<Entity>>();`

2. ‚úÖ **System Abstraction:** `builder.Services.AddScoped<<Entity>MgmtSys>();`
   - **When:** Always register System Abstraction
   - **Lifetime:** `AddScoped` (one instance per request scope)
   - **Example:** `builder.Services.AddScoped<<Entity>MgmtSys>();`
   - **üî¥ CRITICAL:** If caching is used, use `AddCachedService` instead of `AddScoped`

3. ‚úÖ **Service:** `builder.Services.AddScoped<<Entity>Service>();`
   - **When:** Always register Service
   - **Lifetime:** `AddScoped` (one instance per request scope)
   - **Example:** `builder.Services.AddScoped<<Entity>Service>();`

4. ‚úÖ **Verify AppConfigs Registration:** `builder.Services.Configure<AppConfigs>(builder.Configuration.GetSection(AppConfigs.SectionName));`
   - **When:** Verify this exists (only needs to be added once per project)
   - **Location:** Should be near the top of Program.cs configuration section

**üî¥ CROSS-REFERENCE:** This is STEP 9 of the "MANDATORY CODE GENERATION WORKFLOW" at the top of this document.

### 18.8 Program.cs Rules - Post-Creation Validation

**üõë POST-CREATION VALIDATION (MANDATORY - VERIFY BEFORE PROCEEDING)**

**üö® AFTER creating/modifying Program.cs, you MUST verify:**

1. ‚úÖ **STOP AND VERIFY:** NO System Layer project references in .csproj
2. ‚úÖ **STOP AND VERIFY:** NO System Layer services registered (only System Abstractions)
3. ‚úÖ **STOP AND VERIFY:** All System Abstractions registered with interface: `AddScoped<ISystemMgmt, SystemMgmtSys>()`
4. ‚úÖ **STOP AND VERIFY:** All Process Abstractions registered with interface: `AddScoped<IProcessProc, ProcessProc>()`
5. ‚úÖ **STOP AND VERIFY:** All Services registered (with or without interface)
6. ‚úÖ **STOP AND VERIFY:** CustomHTTPClient registered: `AddScoped<CustomHTTPClient>()`
7. ‚úÖ **STOP AND VERIFY:** AppConfigs configured: `Configure<AppConfigs>(...)`
8. ‚úÖ **STOP AND VERIFY:** Middleware order: ExecutionTiming ‚Üí ExceptionHandler (NO CustomAuthenticationMiddleware)
9. ‚úÖ **STOP AND VERIFY:** ServiceLocator set: `ServiceLocator.ServiceProvider = builder.Services.BuildServiceProvider()`
10. ‚úÖ **STOP AND VERIFY:** Domains are NOT registered in DI (instantiated directly)
11. ‚úÖ **STOP AND VERIFY:** Environment variable uses constant: `InfoConstants.DEFAULT_ENVIRONMENT` (NOT hardcoded "dev")
12. ‚úÖ **STOP AND VERIFY:** Registration order matches the template exactly

**üõë IF ANY VIOLATION ‚Üí STOP ‚Üí Fix Program.cs ‚Üí Then proceed**

### 18.8 Program.cs Rules - Common Mistakes

**‚ùå Registering System Layer Services in Process Layer Program.cs**

- **WRONG:** Registering System Layer services or handlers in Process Layer Program.cs
```csharp
// ‚ùå WRONG - Process Layer Program.cs
builder.Services.AddScoped<ISystemLayerService, SystemLayerService>();  // System Layer service
builder.Services.AddScoped<SystemLayerHandler>();  // System Layer handler
```
- **CORRECT:** Only register System Abstractions in Process Layer Program.cs
```csharp
// ‚úÖ CORRECT - Process Layer Program.cs (ONLY System Abstractions)
builder.Services.AddScoped<ISystemMgmt, SystemMgmtSys>();  // System Abstraction only
```
- **Why:** System Abstractions make HTTP calls to System Layer Functions. System Layer services are registered in System Layer Program.cs only.

**‚ùå Registering System/Process Abstractions Without Interface**

- **WRONG:** `builder.Services.AddScoped<EntityMgmtSys>();` - Registering implementation directly
- **WRONG:** `private readonly EntityMgmtSys _entityMgmt;` - Injecting implementation directly
- **CORRECT:** `builder.Services.AddScoped<IEntityMgmt, EntityMgmtSys>();` - Register with interface
- **CORRECT:** `private readonly IEntityMgmt _entityMgmt;` - Inject via interface
- **Why:** System/Process Abstractions MUST be registered and injected via interface for proper abstraction and testability.

**‚ùå Registering Domains in DI**

- **WRONG:** `builder.Services.AddScoped<EntityDomain>();` or `builder.Services.AddTransient<EntityDomain>();`
- **CORRECT:** Instantiate directly: `EntityDomain domain = new EntityDomain();`
- **Why:** Domains are simple POCOs with no constructor dependencies. They are instantiated directly when needed.

**‚ùå Wrong Middleware Order**

- **WRONG:** Registering ExceptionHandlerMiddleware before ExecutionTimingMiddleware
- **CORRECT:** ExecutionTimingMiddleware FIRST, ExceptionHandlerMiddleware SECOND
- **Why:** ExecutionTimingMiddleware must wrap all operations to measure total execution time. ExceptionHandlerMiddleware must be second to catch all exceptions.

**‚ùå Adding Custom Authentication Middleware**

- **WRONG:** Adding CustomAuthenticationMiddleware in Process Layer Program.cs
- **CORRECT:** Only ExecutionTimingMiddleware and ExceptionHandlerMiddleware
- **Why:** CustomAuthenticationMiddleware is a System Layer concept. Process Layer uses Framework middlewares only.

**‚ùå Not Setting ServiceLocator**

- **WRONG:** Missing `ServiceLocator.ServiceProvider = builder.Services.BuildServiceProvider();`
- **CORRECT:** Set ServiceLocator after building service provider
- **Why:** ServiceLocator is required for nested domain object resolution in DTO.Populate() methods using ServiceLocator pattern.

**‚ùå Hardcoding Environment Default**

- **WRONG:** `?? "dev"` - Hardcoded environment default
- **CORRECT:** `?? InfoConstants.DEFAULT_ENVIRONMENT` - Use constant from InfoConstants
- **Why:** Business logic string literals must use constants (see Section 14: Constants Rules). Exceptions: Function attribute names, stepName values, and logging messages are allowed as literal strings.

**‚ùå Wrong Registration Order**

- **WRONG:** Registering components in wrong order (e.g., Services before System Abstractions)
- **CORRECT:** Follow the exact registration order shown in Section 18.3
- **Why:** DI registration order matters. Some components depend on others being registered first.

---

## 19. host.json Rules

**üö® CRITICAL:** Azure Functions host runtime configuration. Use EXACTLY the mandatory template format. NO deviations. NO additional properties.

### 19.1 host.json Rules - Pre-Creation Validation

**üõë PRE-CREATION VALIDATION (MANDATORY - STOP IF NOT COMPLETE)**

**üö® BEFORE creating/modifying host.json, you MUST verify:**

1. ‚úÖ **STOP AND VERIFY:** Have I read this section completely?
2. ‚úÖ **STOP AND VERIFY:** Do I understand that host.json format is EXACT and MANDATORY?
3. ‚úÖ **STOP AND VERIFY:** Do I understand that host.json is the SAME for ALL environments (dev/qa/prod)?
4. ‚úÖ **STOP AND VERIFY:** Do I understand that app configs go in appsettings.json, NOT host.json?
5. ‚úÖ **STOP AND VERIFY:** Do I understand that retry policies go in Program.cs (Polly), NOT host.json?

**üõë IF ANY MISSING ‚Üí STOP ‚Üí Complete verification ‚Üí Then create/modify host.json**

### 19.2 host.json Rules - Standard Template (Mandatory - Exact Format)

**üî¥ CRITICAL: Use EXACTLY this format. NO deviations. NO additional properties.**

**Mandatory Template:**
```json
{"version": "2.0", "logging": {"fileLoggingMode": "always", "applicationInsights": {"samplingSettings": {"isEnabled": true}, "enableLiveMetricsFilters": true}}}
```

**üî¥ CRITICAL:** This is the EXACT format. Use it EXACTLY as shown. Do NOT add properties. Do NOT remove properties. Do NOT modify values.

**Formatted for Readability (same content):**
```json
{
  "version": "2.0",
  "logging": {
    "fileLoggingMode": "always",
    "applicationInsights": {
      "samplingSettings": {
        "isEnabled": true
      },
      "enableLiveMetricsFilters": true
    }
  }
}
```

**Note:** Both formats are equivalent. The single-line format is the exact template. The formatted version is shown for readability only.

### 19.3 host.json Rules - Configuration Breakdown

**Configuration Settings:**

| Setting | Value | Purpose | Mandatory |
|---------|-------|---------|-----------|
| **version** | `"2.0"` | .NET 8 Isolated Worker Model | ‚úÖ **MANDATORY** |
| **fileLoggingMode** | `"always"` | Log to file system (debugging) | ‚úÖ **MANDATORY** |
| **isEnabled** | `true` | Enable sampling for Application Insights | ‚úÖ **MANDATORY** |
| **enableLiveMetricsFilters** | `true` | Real-time metrics in Azure Portal | ‚úÖ **MANDATORY** |

**Key Points:**
- **version: "2.0"** - Required for .NET 8 Isolated Worker Model. Do NOT change.
- **fileLoggingMode: "always"** - Enables file logging for debugging. Always enabled.
- **isEnabled: true** - Enables Application Insights sampling. Always enabled.
- **enableLiveMetricsFilters: true** - Enables real-time metrics in Azure Portal. Always enabled.

### 19.4 host.json Rules - File Location & Properties

**File Location:**
```
<ProjectRoot>/
‚îú‚îÄ‚îÄ Program.cs
‚îú‚îÄ‚îÄ host.json
‚îú‚îÄ‚îÄ appsettings.json
‚îî‚îÄ‚îÄ <ProjectName>.csproj
```

**File Properties (.csproj):**
- **Build Action:** Content
- **Copy to Output Directory:** Copy always (or Copy if newer)

**Key Rules:**
- ‚úÖ **Same level as Program.cs** - host.json must be at project root level
- ‚úÖ **Same level as appsettings.json** - All configuration files at same level
- ‚úÖ **Content + Copy to Output Directory** - File must be included in build output

### 19.5 host.json Rules - Key Rules

| Aspect | Rule | Mandatory |
|--------|------|-----------|
| **Format** | EXACT template format (no deviations) | ‚úÖ **CRITICAL** |
| **Version** | `"2.0"` (for .NET 8 Isolated Worker Model) | ‚úÖ **MANDATORY** |
| **Environments** | Same host.json for ALL environments (dev/qa/stg/prod/dr) | ‚úÖ **MANDATORY** |
| **File Location** | Project root (same level as Program.cs) | ‚úÖ **MANDATORY** |
| **Build Action** | Content + Copy to Output Directory | ‚úÖ **MANDATORY** |
| **Additional Properties** | ‚ùå NEVER add additional properties | ‚úÖ **CRITICAL** |
| **Environment-Specific Files** | ‚ùå NEVER create host.dev.json or host.prod.json | ‚úÖ **CRITICAL** |

**üî¥ CRITICAL RULES:**

1. ‚úÖ **Use EXACT template format** - NO deviations, NO additional properties, NO modifications
2. ‚úÖ **Same host.json for ALL environments** - dev, qa, stg, prod, dr all use the same file
3. ‚úÖ **File must be Content + Copy to Output Directory** - Required for deployment
4. ‚úÖ **Version MUST be "2.0"** - Required for .NET 8 Isolated Worker Model
5. ‚ùå **NEVER add app configs to host.json** - Use appsettings.json for application configuration
6. ‚ùå **NEVER create environment-specific host.json files** - host.dev.json, host.prod.json are PROHIBITED
7. ‚ùå **NEVER add retry policies to host.json** - Use Polly policies in Program.cs for retry logic
8. ‚ùå **NEVER modify the template** - Use it EXACTLY as shown

### 19.6 host.json Rules - What NOT to Add

**‚ùå PROHIBITED Additions:**

**1. Application Configuration:**
- ‚ùå **DO NOT add app configs** - Use `appsettings.json` for application configuration
- ‚ùå **DO NOT add connection strings** - Use `appsettings.json` or AppConfigs
- ‚ùå **DO NOT add URLs or endpoints** - Use `appsettings.json` or AppConfigs

**2. Environment-Specific Files:**
- ‚ùå **DO NOT create `host.dev.json`** - Same host.json for all environments
- ‚ùå **DO NOT create `host.prod.json`** - Same host.json for all environments
- ‚ùå **DO NOT create `host.qa.json`** - Same host.json for all environments

**3. Retry Policies:**
- ‚ùå **DO NOT add retry policies** - Use Polly policies in Program.cs (see Section 18)
- ‚ùå **DO NOT add timeout configurations** - Use Polly timeout policies in Program.cs

**4. Custom Settings:**
- ‚ùå **DO NOT add custom properties** - Use the EXACT template only
- ‚ùå **DO NOT modify existing properties** - Use the EXACT template values

**Why:**
- host.json is for Azure Functions host runtime configuration only
- Application configuration belongs in appsettings.json
- Retry/timeout policies belong in Program.cs (Polly)
- Environment-specific configuration belongs in appsettings.{environment}.json

### 19.7 host.json Rules - Post-Creation Validation

**üõë POST-CREATION VALIDATION (MANDATORY - VERIFY BEFORE PROCEEDING)**

**üö® AFTER creating/modifying host.json, you MUST verify:**

1. ‚úÖ **STOP AND VERIFY:** host.json uses EXACT template format (no deviations)
2. ‚úÖ **STOP AND VERIFY:** version is `"2.0"` (for .NET 8 Isolated Worker Model)
3. ‚úÖ **STOP AND VERIFY:** fileLoggingMode is `"always"`
4. ‚úÖ **STOP AND VERIFY:** isEnabled is `true` (Application Insights sampling)
5. ‚úÖ **STOP AND VERIFY:** enableLiveMetricsFilters is `true`
6. ‚úÖ **STOP AND VERIFY:** NO additional properties added
7. ‚úÖ **STOP AND VERIFY:** File is at project root (same level as Program.cs)
8. ‚úÖ **STOP AND VERIFY:** File properties: Content + Copy to Output Directory
9. ‚úÖ **STOP AND VERIFY:** NO environment-specific host.json files created (host.dev.json, host.prod.json, etc.)
10. ‚úÖ **STOP AND VERIFY:** NO app configs added to host.json (use appsettings.json)
11. ‚úÖ **STOP AND VERIFY:** NO retry policies added to host.json (use Polly in Program.cs)

**üõë IF ANY VIOLATION ‚Üí STOP ‚Üí Fix host.json ‚Üí Then proceed**

### 19.8 host.json Rules - Common Mistakes

**‚ùå Modifying the Template Format**

- **WRONG:** Adding additional properties to host.json
- **WRONG:** Changing property values (e.g., `"version": "2.1"` or `"fileLoggingMode": "debugOnly"`)
- **WRONG:** Removing required properties
- **CORRECT:** Use EXACT template format with NO modifications
- **Why:** The template is standardized and mandatory. Modifications can cause runtime issues or deployment failures.

**‚ùå Creating Environment-Specific host.json Files**

- **WRONG:** Creating `host.dev.json`, `host.prod.json`, `host.qa.json`
- **CORRECT:** Use the same host.json for ALL environments
- **Why:** host.json is for Azure Functions host runtime configuration, which is the same across all environments. Environment-specific configuration belongs in appsettings.{environment}.json.

**‚ùå Adding Application Configuration to host.json**

- **WRONG:** Adding connection strings, URLs, or app settings to host.json
- **CORRECT:** Use appsettings.json for application configuration
- **Why:** host.json is for Azure Functions host runtime configuration only. Application configuration belongs in appsettings.json or AppConfigs.

**‚ùå Adding Retry Policies to host.json**

- **WRONG:** Adding retry or timeout policies to host.json
- **CORRECT:** Use Polly policies in Program.cs for retry/timeout logic (see Section 18)
- **Why:** Retry and timeout policies are application-level concerns, not host runtime configuration. They belong in Program.cs using Polly.

**‚ùå Wrong File Location**

- **WRONG:** Placing host.json in a subfolder or different location
- **CORRECT:** host.json must be at project root (same level as Program.cs)
- **Why:** Azure Functions runtime expects host.json at the project root level.

**‚ùå Wrong File Properties**

- **WRONG:** Not setting Build Action to Content or not copying to output directory
- **CORRECT:** Build Action = Content, Copy to Output Directory = Copy always (or Copy if newer)
- **Why:** host.json must be included in the build output for Azure Functions runtime to read it.

**‚ùå Using Wrong Version**

- **WRONG:** Using `"version": "1.0"` or other versions
- **CORRECT:** Use `"version": "2.0"` for .NET 8 Isolated Worker Model
- **Why:** Version 2.0 is required for .NET 8 Isolated Worker Model. Other versions are incompatible.

---

## 20. Exception Handling Rules

**üö® CRITICAL:** Use layer-appropriate exceptions. NEVER use try-catch blocks. Let all exceptions propagate to middleware for proper error handling.

### 20.1 Exception Handling Rules - Pre-Creation Validation

**üõë PRE-CREATION VALIDATION (MANDATORY - STOP IF NOT COMPLETE)**

**üö® BEFORE throwing exceptions, you MUST verify:**

1. ‚úÖ **STOP AND VERIFY:** Have I read this section completely?
2. ‚úÖ **STOP AND VERIFY:** Do I understand that try-catch blocks are PROHIBITED?
3. ‚úÖ **STOP AND VERIFY:** Do I understand which exception type to use for my scenario?
4. ‚úÖ **STOP AND VERIFY:** Do I have the correct stepName format?
5. ‚úÖ **STOP AND VERIFY:** Do I have errorDetails (if required by exception type)?
6. ‚úÖ **STOP AND VERIFY:** Do I understand that ExceptionHandlerMiddleware handles all exceptions?

**üõë IF ANY MISSING ‚Üí STOP ‚Üí Complete verification ‚Üí Then throw exception**

### 20.2 Exception Handling Rules - Critical Rule: Never Use Try-Catch

**üî¥ CRITICAL RULE - NEVER USE TRY-CATCH:**

**‚ùå PROHIBITED:**
- ‚ùå **NEVER use `try-catch` blocks** in Services, Functions, or any Process Layer code
- ‚ùå **NEVER catch exceptions** - Let all exceptions propagate to middleware
- ‚ùå **NEVER suppress exceptions** - ExceptionHandlerMiddleware handles all exception normalization
- ‚ùå **NEVER handle exceptions manually** - ExceptionHandlerMiddleware normalizes all exceptions to BaseResponseDTO

**‚úÖ CORRECT PATTERN:**
- ‚úÖ **Always throw exceptions** - Let exceptions propagate naturally
- ‚úÖ **Middleware handles exceptions** - ExceptionHandlerMiddleware catches all exceptions and normalizes to BaseResponseDTO
- ‚úÖ **Log before throwing** - Use `_logger.Error()` before throwing exceptions for debugging
- ‚úÖ **Check response status** - Check `IsSuccessStatusCode` and throw `PassThroughHttpException` for non-success

**Why:** ExceptionHandlerMiddleware is designed to catch ALL unhandled exceptions and normalize them to BaseResponseDTO. Using try-catch blocks prevents proper exception handling and error response formatting.

**‚ùå NEVER DO THIS:**
```csharp
// ‚ùå WRONG - try-catch is prohibited
try
{
    HttpResponseSnapshot response = await _systemAbstraction.CallSystemLayer();
}
catch (Exception ex)
{
    _logger.Error(ex, "Error occurred");
    // Handle or suppress exception - PROHIBITED
}
```

**‚úÖ ALWAYS DO THIS:**
```csharp
// ‚úÖ CORRECT - Let exceptions propagate to middleware
_logger.Error($"[Process Layer]-Calling System Layer");
HttpResponseSnapshot response = await _systemAbstraction.CallSystemLayer();
if (!response.IsSuccessStatusCode)
{
    throw new PassThroughHttpException(
        response.ExtractBaseResponse(), 
        (HttpStatusCode)response.StatusCode);
}
```

### 20.3 Exception Handling Rules - Exception Hierarchy

**Exception Types:**

**Process Layer Exceptions:**
- **BusinessCaseFailureException** - Business rule violations (e.g., entity not found, invalid state)
- **PassThroughHttpException** - Propagate downstream errors (System Layer or Process Layer failures)
- **RequestValidationFailureException** - DTO validation failures (mandatory fields missing, invalid format)

**Core Exceptions:**
- **NoRequestBodyException** - Missing request body (Function layer)
- **HttpBaseServerException** - Server errors (Central Data Layer only - DB/config failures)
- **NotFoundException** - Not found cases (when expected data is missing)

**Exception Hierarchy:**
```
Process Layer Exceptions
‚îú‚îÄ‚îÄ BusinessCaseFailureException      // Business rule violations
‚îú‚îÄ‚îÄ PassThroughHttpException          // Propagate downstream errors
‚îî‚îÄ‚îÄ RequestValidationFailureException // DTO validation failures

Core Exceptions
‚îú‚îÄ‚îÄ NoRequestBodyException            // Missing request body
‚îú‚îÄ‚îÄ HttpBaseServerException           // Server errors (central data layer)
‚îî‚îÄ‚îÄ NotFoundException                 // Not found cases
```

### 20.4 Exception Handling Rules - Usage by Layer

**Function Layer:**
```csharp
// Missing request body
if (dto == null) throw new NoRequestBodyException(
    errorDetails: [ErrorConstants.REQ_BODY_MISSING.Message], 
    stepName: "CreateEntityFunction.cs / Executing Run");

// Downstream HTTP failure
if (!r.IsSuccessStatusCode) throw new PassThroughHttpException(
    r.ExtractBaseResponse(), 
    (HttpStatusCode)r.StatusCode);
```

**DTO Layer:**
```csharp
// Validation failures
if (errors.Any()) throw new RequestValidationFailureException(
    errorDetails: errors, 
    stepName: "EntityReqDTO.cs / Validate");
```

**Service Layer:**
```csharp
// Business rule violations
if (data == null || !data.Any()) throw new BusinessCaseFailureException(
    ErrorConstants.ENTITY_NOT_FOUND, 
    [ErrorConstants.ENTITY_NOT_FOUND.Message], 
    stepName: "EntityService.cs / GetEntity");
```

**Central Data Layer:**
```csharp
// Server errors (DB/config failures)
if (cfg == null) throw new HttpBaseServerException(
    ErrorConstants.CONFIG_NOT_FOUND.Message, 
    ErrorConstants.CONFIG_NOT_FOUND.ErrorCode, 
    HttpStatusCode.InternalServerError, 
    [ErrorConstants.CONFIG_NOT_FOUND.Message], 
    stepName: "DataService.cs / ProcessData");
```

### 20.5 Exception Handling Rules - Exception Types & HTTP Status Codes

| Exception | Layer | Purpose | HTTP Status | When to Use |
|-----------|-------|---------|-------------|-------------|
| **NoRequestBodyException** | Function | Missing request body | 400 | When `dto == null` after `ReadBodyAsync<T>()` |
| **RequestValidationFailureException** | DTO | Validation failures | 400 | When DTO validation fails (mandatory fields missing, invalid format) |
| **BusinessCaseFailureException** | Service | Business rule violations | 400 | When business rules are violated (entity not found, invalid state, expired data) |
| **PassThroughHttpException** | All | Propagate downstream errors | Preserved | When System Layer or Process Layer returns non-success status code |
| **HttpBaseServerException** | Central Data Layer | Server errors | 500 | When DB/config failures occur (Central Data Layer only) |
| **NotFoundException** | All | Not found cases | 404 | When expected data is missing (optional, use BusinessCaseFailureException if preferred) |

**Key Rules:**
- ‚úÖ **400 status codes** - Client errors (validation, business rules, missing body)
- ‚úÖ **500 status codes** - Server errors (Central Data Layer only)
- ‚úÖ **Preserved status codes** - PassThroughHttpException preserves the original HTTP status from downstream

### 20.6 Exception Handling Rules - StepName Format

**üî¥ CRITICAL: StepName Format**

All exceptions MUST include `stepName` parameter with standardized format.

**Standard Format:** `"<FileName>.cs / Executing <MethodName> / <OptionalContext>"`

**Examples:**
```csharp
// Simple format
stepName: "CreateEntityFunction.cs / Executing Run"

// With context
stepName: "CreateEntityFunction.cs / Executing Run / NoRequestBodyException"

// Processing step
stepName: "BatchCreateFunction.cs / Executing ProcessBatch / Item validation"

// Nested operation
stepName: "EntityService.cs / GetEntity / Invalid entity type"
```

**Key Rules:**
- ‚úÖ **Format:** `"<FileName>.cs / Executing <MethodName> / <OptionalContext>"`
- ‚úÖ **FileName** - Actual file name (e.g., `CreateEntityFunction.cs`)
- ‚úÖ **MethodName** - Actual method name (e.g., `Run`, `GetEntity`, `ProcessBatch`)
- ‚úÖ **OptionalContext** - Additional context (e.g., exception type, validation step, operation name)
- ‚úÖ **Always include stepName** - All exceptions MUST have stepName parameter

**Note:** If stepName is reused across multiple exceptions, consider using constants from InfoConstants (see Section 14: Constants Rules).

### 20.7 Exception Handling Rules - ErrorDetails Format

**ErrorDetails Parameter:**

**For RequestValidationFailureException:**
```csharp
// List of error messages
throw new RequestValidationFailureException(
    errorDetails: ["FieldName is Required.", "AnotherField is Invalid."], 
    stepName: "EntityReqDTO.cs / Validate");
```

**For BusinessCaseFailureException:**
```csharp
// Error constant tuple and message list
throw new BusinessCaseFailureException(
    ErrorConstants.ENTITY_NOT_FOUND, 
    [ErrorConstants.ENTITY_NOT_FOUND.Message], 
    stepName: "EntityService.cs / GetEntity");
```

**For NoRequestBodyException:**
```csharp
// Error constant message
throw new NoRequestBodyException(
    errorDetails: [ErrorConstants.REQ_BODY_MISSING.Message], 
    stepName: "CreateEntityFunction.cs / Executing Run");
```

**For PassThroughHttpException:**
```csharp
// BaseResponseDTO from downstream response
throw new PassThroughHttpException(
    response.ExtractBaseResponse(), 
    (HttpStatusCode)response.StatusCode);
```

**Key Rules:**
- ‚úÖ **errorDetails** - List of error messages (for validation exceptions)
- ‚úÖ **ErrorConstants** - Use error constants for error codes and messages (see Section 14)
- ‚úÖ **BaseResponseDTO** - Use `ExtractBaseResponse()` for PassThroughHttpException

### 20.8 Exception Handling Rules - Key Rules

| Aspect | Rule | Mandatory |
|--------|------|-----------|
| **Try-Catch Blocks** | ‚ùå NEVER use try-catch | ‚úÖ **CRITICAL** |
| **Exception Propagation** | ‚úÖ Let exceptions propagate to middleware | ‚úÖ **MANDATORY** |
| **ExceptionHandlerMiddleware** | ‚úÖ Handles all exceptions | ‚úÖ Always |
| **StepName Format** | `"<FileName>.cs / Executing <MethodName> / <OptionalContext>"` | ‚úÖ Always |
| **ErrorDetails** | List of error messages or ErrorConstants | ‚úÖ When required |
| **Logging Before Exception** | Use `_logger.Error()` before throwing | ‚úÖ Recommended |
| **Response Status Check** | Check `IsSuccessStatusCode` and throw PassThroughHttpException | ‚úÖ Always for HTTP responses |

**üî¥ CRITICAL RULES:**

1. ‚úÖ **NEVER use try-catch blocks** - Let exceptions propagate to ExceptionHandlerMiddleware
2. ‚úÖ **Always include stepName** - All exceptions MUST have stepName parameter with standardized format
3. ‚úÖ **Use layer-appropriate exceptions** - Function layer uses NoRequestBodyException, DTO layer uses RequestValidationFailureException, Service layer uses BusinessCaseFailureException
4. ‚úÖ **Check response status** - Always check `IsSuccessStatusCode` and throw PassThroughHttpException for non-success
5. ‚úÖ **Use ErrorConstants** - Use error constants for error codes and messages (see Section 14)
6. ‚úÖ **Log before throwing** - Use `_logger.Error()` before throwing exceptions for debugging
7. ‚úÖ **ExceptionHandlerMiddleware handles all** - All exceptions are normalized to BaseResponseDTO by middleware
8. ‚úÖ **HttpBaseServerException for Central Data Layer only** - Use for DB/config failures in Central Data Layer

### 20.9 Exception Handling Rules - Post-Creation Validation

**üõë POST-CREATION VALIDATION (MANDATORY - VERIFY BEFORE PROCEEDING)**

**üö® AFTER throwing exceptions, you MUST verify:**

1. ‚úÖ **STOP AND VERIFY:** NO try-catch blocks in code (exceptions propagate to middleware)
2. ‚úÖ **STOP AND VERIFY:** Correct exception type used (layer-appropriate)
3. ‚úÖ **STOP AND VERIFY:** stepName follows standard format: `"<FileName>.cs / Executing <MethodName> / <OptionalContext>"`
4. ‚úÖ **STOP AND VERIFY:** errorDetails provided (if required by exception type)
5. ‚úÖ **STOP AND VERIFY:** ErrorConstants used (not hardcoded error messages)
6. ‚úÖ **STOP AND VERIFY:** Response status checked before throwing PassThroughHttpException
7. ‚úÖ **STOP AND VERIFY:** Logging added before throwing exceptions (for debugging)

**üõë IF ANY VIOLATION ‚Üí STOP ‚Üí Fix exception handling ‚Üí Then proceed**

### 20.10 Exception Handling Rules - Common Mistakes

**‚ùå Using Try-Catch Blocks**

- **WRONG:** Using try-catch blocks to handle exceptions
```csharp
try
{
    HttpResponseSnapshot response = await _systemAbstraction.CallSystemLayer();
}
catch (Exception ex)
{
    _logger.Error(ex, "Error occurred");
    // Handle exception - PROHIBITED
}
```
- **CORRECT:** Let exceptions propagate to middleware
```csharp
HttpResponseSnapshot response = await _systemAbstraction.CallSystemLayer();
if (!response.IsSuccessStatusCode)
{
    throw new PassThroughHttpException(
        response.ExtractBaseResponse(), 
        (HttpStatusCode)response.StatusCode);
}
```
- **Why:** ExceptionHandlerMiddleware catches ALL unhandled exceptions and normalizes them to BaseResponseDTO. Using try-catch prevents this automatic handling.

**‚ùå Wrong Exception Type**

- **WRONG:** Using `BusinessCaseFailureException` for validation failures
- **WRONG:** Using `RequestValidationFailureException` for business rule violations
- **WRONG:** Using `HttpBaseServerException` in standard Process Layer (only for Central Data Layer)
- **CORRECT:** Use layer-appropriate exceptions (see Section 20.5)
- **Why:** Each exception type has a specific purpose and HTTP status code. Using the wrong type causes incorrect error responses.

**‚ùå Missing StepName**

- **WRONG:** Throwing exceptions without stepName parameter
- **CORRECT:** Always include stepName with standardized format: `"<FileName>.cs / Executing <MethodName> / <OptionalContext>"`
- **Why:** stepName helps identify where exceptions occur for debugging and error tracking.

**‚ùå Wrong StepName Format**

- **WRONG:** `stepName: "CreateEntity"` - Missing file name and method name
- **WRONG:** `stepName: "Run"` - Missing file name
- **CORRECT:** `stepName: "CreateEntityFunction.cs / Executing Run"`
- **Why:** Standardized format makes it easy to locate exceptions in code and logs.

**‚ùå Not Checking Response Status**

- **WRONG:** Not checking `IsSuccessStatusCode` before using response
- **WRONG:** Using response data without checking status
- **CORRECT:** Always check `IsSuccessStatusCode` and throw PassThroughHttpException for non-success
- **Why:** Non-200 responses must be explicitly checked and converted to exceptions to ensure errors propagate correctly.

**‚ùå Hardcoding Error Messages**

- **WRONG:** `throw new BusinessCaseFailureException("Entity not found", ...)` - Hardcoded message
- **CORRECT:** `throw new BusinessCaseFailureException(ErrorConstants.ENTITY_NOT_FOUND, [ErrorConstants.ENTITY_NOT_FOUND.Message], ...)` - Use ErrorConstants
- **Why:** Error messages should use constants for consistency and maintainability (see Section 14: Constants Rules).

**‚ùå Suppressing Exceptions**

- **WRONG:** Catching exceptions and not rethrowing
- **WRONG:** Catching exceptions and returning default values
- **CORRECT:** Let exceptions propagate to middleware
- **Why:** ExceptionHandlerMiddleware handles all exception normalization. Suppressing exceptions prevents proper error handling.

---

## 21. Architecture Invariants Rules

**üö® CRITICAL:** These rules NEVER change. They define the fundamental architecture boundaries and constraints that must be followed across all Process Layer implementations.

### 21.1 Architecture Invariants Rules - Pre-Creation Validation

**üõë PRE-CREATION VALIDATION (MANDATORY - STOP IF NOT COMPLETE)**

**üö® BEFORE creating any Process Layer code, you MUST verify:**

1. ‚úÖ **STOP AND VERIFY:** Have I read this section completely?
2. ‚úÖ **STOP AND VERIFY:** Do I understand the layer boundaries (what is ALLOWED vs FORBIDDEN)?
3. ‚úÖ **STOP AND VERIFY:** Do I understand the Central Data Layer as database gateway pattern?
4. ‚úÖ **STOP AND VERIFY:** Do I understand the header standardization rules?
5. ‚úÖ **STOP AND VERIFY:** Do I understand the middleware restrictions?
6. ‚úÖ **STOP AND VERIFY:** Do I understand the folder naming conventions?
7. ‚úÖ **STOP AND VERIFY:** Do I understand the repository management principles?

**üõë IF ANY MISSING ‚Üí STOP ‚Üí Complete verification ‚Üí Then proceed**

### 21.2 Architecture Invariants Rules - Layer Boundaries

**üî¥ CRITICAL: Layer Boundaries (NEVER VIOLATE)**

**Allowed Communication Patterns:**
1. ‚úÖ **Process Layer ‚Üí System Layer** - ALLOWED (via System Abstractions)
2. ‚úÖ **Process Layer ‚Üí Process Layer** - ALLOWED (via Process Abstractions)

**Forbidden Communication Patterns:**
3. ‚ùå **System Layer ‚Üí Process Layer** - FORBIDDEN
4. ‚ùå **System Layer ‚Üí System Layer** - FORBIDDEN
5. ‚ùå **Process Layer ‚Üí Downstream API** - FORBIDDEN (must go through System Layer)

**Key Rules:**
- ‚úÖ **Process Layer calls System Layer** - Use System Abstractions with `SendProcessHTTPReqAsync()` (see Section 5)
- ‚úÖ **Process Layer calls Process Layer** - Use Process Abstractions with `SendProcessHTTPReqAsync()` (see Section 6)
- ‚ùå **System Layer MUST NOT call Process Layer** - This violates architecture boundaries
- ‚ùå **System Layer MUST NOT call System Layer** - System Layers are independent
- ‚ùå **Process Layer MUST NOT call Downstream APIs directly** - All external API calls must go through System Layer

**Why:** These boundaries ensure proper separation of concerns, maintainability, and scalability. Violating these boundaries creates architectural inconsistencies and makes the system harder to maintain.

### 21.3 Architecture Invariants Rules - Central Data Layer as Database Gateway

**üî¥ CRITICAL: Central Data Layer Database Access Pattern**

**Central Data Layer (Shared Services):**
1. ‚úÖ **Central data layer** - ONLY Process Layer with direct DB access
2. ‚úÖ **Direct database access** - Via EF Core, Repository<T>, and AppDbContext
3. ‚úÖ **Flyway migrations** - Integrated in central data layer CI/CD pipeline

**All Other Process Layers:**
1. ‚úÖ **Database access via central data layer** - MUST call Central Data Layer Azure Functions
2. ‚ùå **NO direct database access** - Cannot use EF Core, Repository<T>, or AppDbContext
3. ‚ùå **NO database migrations** - Flyway is only in Central Data Layer

**Key Rules:**
- ‚úÖ **Central Data Layer** - Has `Repositories/`, `Models/`, `AutoMapping/`, `AppDbContext`, `KeyVaultReader`, `DatabaseConnectionStringProvider`
- ‚úÖ **Standard Process Layer** - Has `Domains/`, `DTOs/`, `SystemAbstractions/`, `ProcessAbstractions/`, `Services/`, `Functions/`
- ‚ùå **Standard Process Layer MUST NOT have** - `Repositories/`, `Models/`, `AutoMapping/`, `AppDbContext`
- ‚úÖ **Standard Process Layer MUST call** - Central Data Layer Azure Functions for ANY database operations

**Why:** Central Data Layer acts as the single gateway for all database operations, ensuring data consistency, security, and maintainability. All other Process Layers must go through this gateway.

**See Also:**
- Section 9: Central Data Process Layer Unique Patterns
- Section 10: Calling Central Data Process Layer

### 21.4 Architecture Invariants Rules - Header Standardization

**üî¥ CRITICAL: Header Standardization (MANDATORY FORMAT)**

**Process‚ÜíSystem Layer Headers:**
```csharp
List<Tuple<string, string>> headers = new List<Tuple<string, string>> 
{ 
    RequestHeaders.TestRunId.Simplify(), 
    RequestHeaders.RequestId.Simplify() 
};
```

**Process‚ÜíProcess Layer Headers:**
```csharp
List<Tuple<string, string>> headers = new List<Tuple<string, string>> 
{ 
    RequestHeaders.TestRunId.Simplify(), 
    RequestHeaders.RequestId.Simplify() 
};
if (req.Headers != null) 
{
    headers.AddRange(req.Headers.Select(kvp => Tuple.Create(kvp.Key, kvp.Value)));
}
```

**Key Rules:**
- ‚úÖ **ALWAYS include TestRunId and RequestId** - Use `RequestHeaders.TestRunId.Simplify()` and `RequestHeaders.RequestId.Simplify()`
- ‚úÖ **Process‚ÜíSystem** - Only TestRunId and RequestId (no additional headers)
- ‚úÖ **Process‚ÜíProcess** - TestRunId, RequestId, plus all headers from incoming request (if `req.Headers != null`)
- ‚úÖ **Use `SendProcessHTTPReqAsync()`** - This extension method automatically adds TestRunId/RequestId headers (see Section 5.5 and Section 6.4)

**Why:** Standardized headers ensure consistent request tracing, logging, and error handling across all Process Layer communications.

**See Also:**
- Section 5.5: System Abstractions - HTTP Call Method
- Section 6.4: Process Abstractions - Header Management

### 21.5 Architecture Invariants Rules - Middleware Restrictions

**üî¥ CRITICAL: Middleware Restrictions (MANDATORY)**

**Process Layer Middleware (ONLY):**
1. ‚úÖ **ExecutionTimingMiddleware** - Request timing tracking (MANDATORY)
2. ‚úÖ **ExceptionHandlerMiddleware** - Centralized exception handling (MANDATORY)

**Forbidden Middleware:**
3. ‚ùå **NO CustomAuthenticationMiddleware** - System Layer concept (NOT for Process Layer)
4. ‚ùå **NO custom middlewares** - Use framework middlewares only
5. ‚ùå **NO additional middlewares** - Only ExecutionTiming and ExceptionHandler

**Key Rules:**
- ‚úÖ **ExecutionTimingMiddleware** - MUST be registered first (see Section 11.3)
- ‚úÖ **ExceptionHandlerMiddleware** - MUST be registered second (see Section 11.3)
- ‚ùå **NO custom authentication** - Process Layer does not handle authentication
- ‚ùå **NO custom middleware** - Only use framework-provided middlewares

**Why:** Process Layer focuses on business logic orchestration. Authentication and authorization are handled by System Layer. Custom middlewares can break the architecture and create inconsistencies.

**See Also:**
- Section 11: Middleware Rules

### 21.6 Architecture Invariants Rules - Folder Naming

**üî¥ CRITICAL: Folder Naming Conventions (MANDATORY)**

**Standard Process Layer Folders:**
1. ‚úÖ **DTOs/** - Request/response data transfer objects
2. ‚úÖ **SystemAbstractions/** - System Layer calls (Process‚ÜíSystem communication)
3. ‚úÖ **ProcessAbstractions/** - Process Layer calls (Process‚ÜíProcess communication)
4. ‚úÖ **Domains/** - Business objects with `IDomain<T>` interface
5. ‚úÖ **Services/** - Orchestration logic
6. ‚úÖ **Functions/** - Azure Functions (HTTP orchestrators)

**Central Data Layer Additional Folders:**
7. ‚úÖ **Repositories/** - Generic Repository<T> + specific repositories (Central Data Layer ONLY)
8. ‚úÖ **Models/** - EF Core entities (Central Data Layer ONLY)
9. ‚úÖ **AutoMapping/** - AutoMapper profiles (Central Data Layer ONLY)

**Key Rules:**
- ‚úÖ **DTOs/** - For ALL request/response DTOs (see Section 7)
- ‚úÖ **SystemAbstractions/** - For ALL System Layer calls (see Section 5)
- ‚úÖ **ProcessAbstractions/** - For ALL Process Layer calls (see Section 6)
- ‚úÖ **Domains/** - For ALL business objects with `IDomain<T>` (see Section 3) - EXCEPT Central Data Layer
- ‚ùå **Standard Process Layer MUST NOT have** - `Repositories/`, `Models/`, `AutoMapping/`
- ‚úÖ **Central Data Layer ONLY** - Has `Repositories/`, `Models/`, `AutoMapping/`

**Why:** Consistent folder naming ensures code organization, maintainability, and makes it easy to locate components. Violating folder naming creates confusion and makes code harder to navigate.

**See Also:**
- Section 1: Folder Structure Rules
- Section 9: Central Data Process Layer Unique Patterns

### 21.7 Architecture Invariants Rules - Repository Management

**üî¥ CRITICAL: Repository Management Principles (MANDATORY)**

**Repository Naming Convention:**
- **Format:** `proc-<reponame>`
- **Location:** Repository location follows standard conventions
- **Examples:**
  - `proc-appointmentcreate` (Appointment Create Process Layer)
  - `proc-workorder` (Work Order Process Layer)
  - `proc-employee` (Employee Process Layer)
  - `proc-facilities` (Facilities Process Layer)

**Repository Management Principles:**

1. ‚úÖ **One repository per business process**
   - Each Process Layer must be in a dedicated code repository
   - ‚ùå Multiple processes in one repository (unless closely related business domain)

2. ‚úÖ **Scan repositories before creating code**
   - Scan for existing repositories
   - Identify all repositories starting with `proc-` prefix
   - Map each repository to its business process

3. ‚úÖ **Use existing repository if available**
   - If Process Layer repository for target process already exists, implement functionality within existing repository
   - Follow existing repository structure and naming conventions
   - Maintain consistency with existing code

4. ‚úÖ **Create new repository if needed**
   - If no Process Layer repository exists for target process, create new repository
   - Use format: `proc-<reponame>`
   - Initialize with standard Process Layer structure
   - Follow all Process Layer rules from this document

5. ‚úÖ **Maintain repository awareness**
   - Document repository-to-process mapping
   - Update mapping when new repositories are created
   - Verify mapping before creating new code

**Function Reuse & Versioning Rules:**

**Before creating any new Function:**
1. ‚úÖ **Check if Function already exists** in target Process Layer repository
   - Scan `Functions/` directory
   - Check for Functions with similar names/purposes

2. ‚úÖ **If Function exists:**
   - **Non-breaking changes** ‚Üí Update existing Function
     - Adding optional fields to request DTO
     - Adding new fields to response DTO
     - Internal logic improvements (same input/output contract)
     - Performance optimizations
   - **Breaking changes** ‚Üí Create new versioned Function
     - Removed required fields from request DTO
     - Changed field types in request/response DTOs
     - Removed fields from response DTO
     - URL/route changes
     - Business logic changes that affect existing consumers

3. ‚úÖ **If Function does NOT exist:** Create new Function following naming conventions

**Function Versioning Pattern:**
- Original: `CreateEntity` (NO "API" suffix - see Section 2)
- Version 2: `CreateEntityV2` (if breaking changes)
- Version 3: `CreateEntityV3` (if further breaking changes)

**Breaking Change Examples:**
```csharp
// ‚ùå BREAKING: Removed required field
// Original: public string EntityId { get; set; }  // Required
// New: Field removed ‚Üí BREAKING

// ‚ùå BREAKING: Changed field type
// Original: public DateTime EntityDate { get; set; }
// New: public string EntityDate { get; set; } ‚Üí BREAKING

// ‚úÖ NON-BREAKING: Added optional field
// Original: public string EntityName { get; set; }
// New: public string EntityName { get; set; }
//      public string? EntityEmail { get; set; }  // Optional ‚Üí NON-BREAKING
```

**Decision Flow:**
```
Does Function exist?
‚îú‚îÄ NO ‚Üí Create new Function
‚îî‚îÄ YES ‚Üí Are changes breaking?
    ‚îú‚îÄ NO ‚Üí Update existing Function
    ‚îî‚îÄ YES ‚Üí Create versioned Function (V2, V3, etc.)
```

**Key Rules:**
- ‚úÖ **One repository per business process** - Maintain clear separation
- ‚úÖ **Scan before creating** - Check if repository/Function already exists
- ‚úÖ **Reuse existing** - Update existing Function for non-breaking changes
- ‚úÖ **Version for breaking changes** - Create V2, V3, etc. for breaking changes
- ‚ùå **NO multiple processes in one repository** - Unless closely related business domain

**Why:** Proper repository management ensures code organization, prevents duplication, and maintains consistency across Process Layer implementations.

### 21.8 Architecture Invariants Rules - Key Rules

| Aspect | Rule | Mandatory |
|--------|------|-----------|
| **Layer Boundaries** | Process‚ÜíSystem ‚úÖ, Process‚ÜíProcess ‚úÖ, System‚ÜíProcess ‚ùå, System‚ÜíSystem ‚ùå, Process‚ÜíDownstream API ‚ùå | ‚úÖ **CRITICAL** |
| **Central Data Layer** | ONLY Process Layer with direct DB access | ‚úÖ **CRITICAL** |
| **Standard Process Layer** | Database access via Central Data Layer Azure Functions | ‚úÖ **CRITICAL** |
| **Header Standardization** | TestRunId + RequestId (Process‚ÜíSystem), TestRunId + RequestId + req.Headers (Process‚ÜíProcess) | ‚úÖ **MANDATORY** |
| **Middleware** | ONLY ExecutionTiming + ExceptionHandler | ‚úÖ **MANDATORY** |
| **Folder Naming** | DTOs/, SystemAbstractions/, ProcessAbstractions/, Domains/, Services/, Functions/ | ‚úÖ **MANDATORY** |
| **Repository Naming** | `proc-<reponame>` format | ‚úÖ **MANDATORY** |
| **Function Reuse** | Check if Function exists, update for non-breaking, version for breaking | ‚úÖ **MANDATORY** |

**üî¥ CRITICAL RULES:**

1. ‚úÖ **NEVER violate layer boundaries** - Process‚ÜíSystem ‚úÖ, Process‚ÜíProcess ‚úÖ, System‚ÜíProcess ‚ùå, System‚ÜíSystem ‚ùå, Process‚ÜíDownstream API ‚ùå
2. ‚úÖ **NEVER add direct database access to Standard Process Layer** - Use Central Data Layer Azure Functions
3. ‚úÖ **ALWAYS use standardized headers** - TestRunId + RequestId for all Process Layer communications
4. ‚úÖ **NEVER add custom middleware** - Only ExecutionTiming + ExceptionHandler
5. ‚úÖ **ALWAYS follow folder naming conventions** - DTOs/, SystemAbstractions/, ProcessAbstractions/, Domains/, Services/, Functions/
6. ‚úÖ **ALWAYS use repository naming convention** - `proc-<reponame>` format
7. ‚úÖ **ALWAYS check for existing Functions** - Reuse or version appropriately

### 21.9 Architecture Invariants Rules - Post-Creation Validation

**üõë POST-CREATION VALIDATION (MANDATORY - VERIFY BEFORE PROCEEDING)**

**üö® AFTER creating Process Layer code, you MUST verify:**

1. ‚úÖ **STOP AND VERIFY:** NO layer boundary violations (System‚ÜíProcess, System‚ÜíSystem, Process‚ÜíDownstream API)
2. ‚úÖ **STOP AND VERIFY:** NO direct database access in Standard Process Layer (use Central Data Layer)
3. ‚úÖ **STOP AND VERIFY:** Headers follow standardization (TestRunId + RequestId)
4. ‚úÖ **STOP AND VERIFY:** ONLY ExecutionTiming + ExceptionHandler middleware (no custom middleware)
5. ‚úÖ **STOP AND VERIFY:** Folder names follow conventions (DTOs/, SystemAbstractions/, ProcessAbstractions/, Domains/, Services/, Functions/)
6. ‚úÖ **STOP AND VERIFY:** Repository follows naming convention (`proc-<reponame>`)
7. ‚úÖ **STOP AND VERIFY:** Function reuse/versioning rules followed (check existing, update or version appropriately)

**üõë IF ANY VIOLATION ‚Üí STOP ‚Üí Fix architecture violations ‚Üí Then proceed**

### 21.10 Architecture Invariants Rules - Common Mistakes

**‚ùå Violating Layer Boundaries**

- **WRONG:** System Layer calling Process Layer Functions
- **WRONG:** Process Layer calling Downstream APIs directly
- **WRONG:** System Layer calling System Layer Functions
- **CORRECT:** Process‚ÜíSystem ‚úÖ, Process‚ÜíProcess ‚úÖ, System‚ÜíProcess ‚ùå, System‚ÜíSystem ‚ùå, Process‚ÜíDownstream API ‚ùå
- **Why:** Layer boundaries ensure proper separation of concerns and maintainability. Violating boundaries creates architectural inconsistencies.

**‚ùå Direct Database Access in Standard Process Layer**

- **WRONG:** Adding `Repositories/`, `Models/`, `AutoMapping/`, `AppDbContext` to Standard Process Layer
- **WRONG:** Using EF Core or Repository<T> in Standard Process Layer
- **CORRECT:** Call Central Data Layer Azure Functions for database operations
- **Why:** Central Data Layer is the single gateway for all database operations. Direct access in Standard Process Layer violates architecture.

**‚ùå Wrong Header Format**

- **WRONG:** Not including TestRunId and RequestId headers
- **WRONG:** Adding custom headers without TestRunId and RequestId
- **CORRECT:** Always include TestRunId + RequestId (use `RequestHeaders.TestRunId.Simplify()` and `RequestHeaders.RequestId.Simplify()`)
- **Why:** Standardized headers ensure consistent request tracing and error handling.

**‚ùå Adding Custom Middleware**

- **WRONG:** Adding CustomAuthenticationMiddleware to Process Layer
- **WRONG:** Creating custom middleware for Process Layer
- **CORRECT:** Only ExecutionTiming + ExceptionHandler middleware
- **Why:** Process Layer focuses on business logic. Authentication is handled by System Layer. Custom middleware breaks architecture.

**‚ùå Wrong Folder Names**

- **WRONG:** Using `DTO/`, `SystemAbstraction/`, `ProcessAbstraction/` (singular)
- **WRONG:** Using `DataTransferObjects/`, `SystemAbstractionLayer/` (long names)
- **CORRECT:** Use exact folder names: `DTOs/`, `SystemAbstractions/`, `ProcessAbstractions/`, `Domains/`, `Services/`, `Functions/`
- **Why:** Consistent folder naming ensures code organization and makes it easy to locate components.

**‚ùå Wrong Repository Naming**

- **WRONG:** Using `appointment-create`, `work_order`, `EmployeeProcess` (wrong format)
- **CORRECT:** Use `proc-appointmentcreate`, `proc-workorder`, `proc-employee` (`proc-` prefix, lowercase, no hyphens/underscores)
- **Why:** Consistent repository naming makes it easy to identify Process Layer repositories.

**‚ùå Not Checking for Existing Functions**

- **WRONG:** Creating new Function without checking if similar Function exists
- **WRONG:** Creating versioned Function for non-breaking changes
- **CORRECT:** Check if Function exists, update for non-breaking changes, version for breaking changes
- **Why:** Function reuse prevents duplication and maintains consistency.

---

## 22. Constants Update Rules

**üö® CRITICAL:** Constants centralize all business logic string literals. When adding a new operation, you MUST update Constants files.

### 22.1 Constants Update Rules - Checklist

**üî¥ MANDATORY: When adding a new operation, you MUST update Constants:**

**ErrorConstants.cs Checklist:**
- [ ] **MANDATORY:** Add error constant for operation failure:
  ```csharp
  public static readonly (string ErrorCode, string Message) <OPERATION>_FAILURE = ("<ERROR_CODE>", "<Error message>");
  ```
- [ ] **Example:** `public static readonly (string ErrorCode, string Message) <OPERATION>_FAILURE = ("<SOR>_<ABBREVIATION>_<NUMBER>", "<Error message>");`
- [ ] **Format:** ErrorCode follows pattern: `<SOR>_<ABBREVIATION>_<NUMBER>` (e.g., `<SOR>_<ABBREVIATION>_0001`)
- [ ] **When:** Add if operation can fail and needs error constant

**InfoConstants.cs Checklist:**
- [ ] **MANDATORY:** Add success message constant:
  ```csharp
  public const string <OPERATION>_SUCCESS = "<Success message>";
  ```
- [ ] **Example:** `public const string <OPERATION>_SUCCESS = "<Entity> retrieved successfully";`
- [ ] **When:** Always add for new operations

- [ ] **MANDATORY:** Add process name constant:
  ```csharp
  public const string PROCESS_NAME_<OPERATION> = "<Process Name>";
  ```
- [ ] **Example:** `public const string PROCESS_NAME_<OPERATION> = "<Operation>";`
- [ ] **When:** Always add for new operations (used in error notifications)

### 22.2 Constants Update Rules - Usage Verification

**üî¥ CRITICAL: Constants MUST be used in Functions (NOT hardcoded strings):**

**Verification Checklist:**
- [ ] **STOP AND VERIFY:** Function uses `InfoConstants.<OPERATION>_SUCCESS` (not hardcoded success message)
- [ ] **STOP AND VERIFY:** Function uses `InfoConstants.PROCESS_NAME_<OPERATION>` (not hardcoded process name)
- [ ] **STOP AND VERIFY:** Function uses `ErrorConstants.<OPERATION>_FAILURE` (if error constant exists, not hardcoded error message)
- [ ] **STOP AND VERIFY:** Constants are used in business logic (NOT in logging messages - logging uses literal strings)

**Exceptions (Literal Strings Allowed):**
- ‚úÖ Function attribute names: `[Function("<Operation>")]` (literal string)
- ‚úÖ stepName values: `"<Operation>Function.cs / Executing Run"` (literal string)
- ‚úÖ Logging messages: `_logger.Info("<Operation> completed successfully.");` (literal string)

**‚ùå WRONG (Hardcoded in Business Logic):**
```csharp
return new BaseResponseDTO("<Entity> retrieved successfully", string.Empty, resDto);  // ‚ùå Hardcoded
```

**‚úÖ CORRECT (Using Constants):**
```csharp
return new BaseResponseDTO(InfoConstants.<OPERATION>_SUCCESS, string.Empty, resDto);  // ‚úÖ Constant
```

### 22.3 Constants Update Rules - Naming Conventions

**ErrorConstants Naming:**
- **Format:** `<OPERATION>_FAILURE` (uppercase with underscores)
- **Example:** `<OPERATION>_FAILURE` (e.g., `GET_<ENTITY>_FAILURE`, `CREATE_<ENTITY>_FAILURE`)
- **ErrorCode Format:** `<SOR>_<ABBREVIATION>_<NUMBER>` (e.g., `<SOR>_<ABBREVIATION>_0001`)

**InfoConstants Naming:**
- **Success Message:** `<OPERATION>_SUCCESS` (uppercase with underscores)
- **Process Name:** `PROCESS_NAME_<OPERATION>` (uppercase with underscores)
- **Example:** `<OPERATION>_SUCCESS`, `PROCESS_NAME_<OPERATION>` (e.g., `GET_<ENTITY>_SUCCESS`, `PROCESS_NAME_GET_<ENTITY>`)

### 22.4 Constants Update Rules - Post-Update Validation

**üõë POST-UPDATE VALIDATION (MANDATORY - VERIFY BEFORE PROCEEDING):**

**üö® AFTER updating Constants, you MUST verify:**

1. ‚úÖ **STOP AND VERIFY:** ErrorConstants.cs has error constant (if needed): `public static readonly (string ErrorCode, string Message) <OPERATION>_FAILURE = ...`
2. ‚úÖ **STOP AND VERIFY:** InfoConstants.cs has success message: `public const string <OPERATION>_SUCCESS = "...";`
3. ‚úÖ **STOP AND VERIFY:** InfoConstants.cs has process name: `public const string PROCESS_NAME_<OPERATION> = "...";`
4. ‚úÖ **STOP AND VERIFY:** Function uses constants (not hardcoded strings) in business logic
5. ‚úÖ **STOP AND VERIFY:** Constants follow naming conventions (uppercase with underscores)
6. ‚úÖ **STOP AND VERIFY:** ErrorCode follows format: `<SOR>_<ABBREVIATION>_<NUMBER>`

**üõë IF ANY VIOLATION ‚Üí STOP ‚Üí Fix Constants ‚Üí Then proceed**

**üî¥ CROSS-REFERENCE:** This is STEP 10 of the "MANDATORY CODE GENERATION WORKFLOW" at the top of this document.

---
